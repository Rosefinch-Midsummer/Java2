<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Java语言程序设计</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="前言.html"><strong aria-hidden="true">1.</strong> 前言</a></li><li class="chapter-item expanded "><a href="Google编码风格.html"><strong aria-hidden="true">2.</strong> Google编码风格</a></li><li class="chapter-item expanded "><a href="数据类型理论.html"><strong aria-hidden="true">3.</strong> 数据类型理论</a></li><li class="chapter-item expanded "><a href="运算符.html"><strong aria-hidden="true">4.</strong> 运算符理论</a></li><li class="chapter-item expanded "><a href="循环语句理论.html"><strong aria-hidden="true">5.</strong> 循环语句理论</a></li><li class="chapter-item expanded "><a href="异常处理理论.html"><strong aria-hidden="true">6.</strong> 异常处理理论</a></li><li class="chapter-item expanded "><a href="函数理论.html"><strong aria-hidden="true">7.</strong> 函数理论</a></li><li class="chapter-item expanded "><a href="文件理论.html"><strong aria-hidden="true">8.</strong> 文件理论</a></li><li class="chapter-item expanded "><a href="面向对象理论.html"><strong aria-hidden="true">9.</strong> 面向对象理论</a></li><li class="chapter-item expanded "><a href="数据库理论.html"><strong aria-hidden="true">10.</strong> 数据库理论</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Java语言程序设计</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="window10安装jdk21并配置eclipse"><a class="header" href="#window10安装jdk21并配置eclipse">Window10安装jdk21并配置Eclipse</a></h1>
<ul>
<li><a href="%E5%89%8D%E8%A8%80.html#jdk%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE">JDK环境配置</a></li>
<li><a href="%E5%89%8D%E8%A8%80.html#%E7%94%A8eclipse%E5%86%99hello-world">用eclipse写hello world</a></li>
</ul>
<p><a href="https://blog.csdn.net/weixin_50455331/article/details/126083021">JDK的环境配置（超详细教程）</a></p>
<p><a href="https://blog.csdn.net/weixin_50455331/article/details/126324741">eclipse下载与安装（汉化教程）超详细</a></p>
<p><a href="https://blog.csdn.net/qq_46110497/article/details/124607392">eclipse工具栏图标太小了，这样修改</a></p>
<p><a href="https://cloud.tencent.com/developer/article/1795246">Eclipse 小技巧之设置 Java 代码自动提示和补全设置</a></p>
<h2 id="jdk环境配置"><a class="header" href="#jdk环境配置">JDK环境配置</a></h2>
<p>JDK环境配置是JDK安装过程中最为重要的内容，大多数初学者安装JDK最大的问题就是出在环境配置上面，所以这里我以windows 10为例，分享一下JDK环境配置的过程。</p>
<p>（PS：以下环境配置的标点符号是在英文状态下的）</p>
<p>1.点击 我的电脑 ——&gt; 右键 ——&gt; 选择属性 ，跳出如下图所示（windows 10系统），点击“高级系统设置”。或者 控制面板——&gt;系统和安全——&gt;系统   也可以找到“高级系统设置”。</p>
<p>2.跳出如下图所示内容，点击“系统环境变量”，</p>
<p>3.点击环境变量后，跳出如下图所示对话框，第一步点击 “新建”，随后跳出 “新建系统变量” 对话框，一般来说系统变量中是没有JAVA_HOME的，所以我们在弹出的“新建系统变量”对话框中的“变量名”填入 ：JAVA_HOME ，“变量值 ”填入 ：C:\Program Files\Java\jdk-12.0.1（安装Java时jdk 所在的文件夹，   默认安装都是在C盘的）。如果已经存在JAVA_HOME的，那么就在它的变量值的最后面加上分号（即；），然后再将 jdk 的路径添加在这个分号的后面。</p>
<p>注意：JAVA_HOME的变量值一定要进入到 jdk 所在的目录，然后再复制这个路径放进去。</p>
<p>4.新建变量名：CLASSPATH，变量值：.;%JAVA_HOME%\lib\dt.jar;%JAVA_HOME%\lib\tools.jar （注意前面的  .;  也要放进去）如下图：</p>
<p>注意：如果已经存在CLASSPATH，则在它的最前面或者最后面添加变量值，如果在最前面添加，应该先添加一个分号（即；），然后再在分号前面添加 .;%JAVA_HOME%\lib\dt.jar;%JAVA_HOME%\lib\tools.jar （ .; 也要放进去）；如果在最后面添加，应该先添加一个分号（即；），然后再在分号后面添加  .;%JAVA_HOME%\lib\dt.jar;%JAVA_HOME%\lib\tools.jar （ .; 也要放进去）。</p>
<p>5.打开Path，点击新建按钮，添加变量值：%JAVA_HOME%\bin;%JAVA_HOME%\jre\bin（注意：从分号分开作为两行）。</p>
<p>注意：在window 10系统中，配置JDK环境变量时，如果不将 Path 的 变量值：%JAVA_HOME%\bin;%JAVA_HOME%\jre\bin 进行如下图这样配置，不分开两行，则会出错。但是如果你的系统是window 7的话，则可以不分开。</p>
<p>6.记得点击两次确定，如下图：</p>
<p>三. 验证JDK环境是否配置成功。</p>
<p>1.按住Window+R ，输入cmd，如下图：</p>
<p>2.回车，在cmd命令行分别输入java和javac（可以不区分大小写） ，出现如下图所示的画面而不是“javac不是内部变量……”即表示安装成功。</p>
<h2 id="用eclipse写hello-world"><a class="header" href="#用eclipse写hello-world">用eclipse写hello world</a></h2>
<p>1.新建一个Java project（Java项目）文件</p>
<p>选择File→new→java project</p>
<p>如果找不到java project ,可以先找到project…</p>
<p>然后在里面找到java project</p>
<p><img src="https://img-blog.csdnimg.cn/f492027ea5f9408fbfcab94d12c3cc31.png#pic_center" alt="a" /></p>
<p>2.在Project name（项目名称）里填入 Helloworld，然后点击finish （完成）会生成一个项目</p>
<p><img src="https://img-blog.csdnimg.cn/03ce6d3995b64b78b93d5332fc584cb0.png#pic_center" alt="a" /></p>
<p><img src="https://img-blog.csdnimg.cn/4237772d1a6e484f81e0e3e6fb7702a1.png#pic_center" alt="a" /></p>
<p>3.创建完项目后，右键Helloworld→new→Package（包），然后点击Finish会在Helloworld文件下生成一个包</p>
<p><img src="https://img-blog.csdnimg.cn/c9299c03023a450ea3c445c0035d5a1b.png#pic_center" alt="a" /></p>
<p><img src="https://img-blog.csdnimg.cn/f87db52076f34b58825d098d63893c4c.png#pic_center" alt="a" /></p>
<p>4.右键hello包（新生成的包）hello→new→Class (类)，新建一个类</p>
<p><img src="https://img-blog.csdnimg.cn/40b5a0cd4a5b47b085179d77f378b744.png#pic_center" alt="a" /></p>
<p>5.在生成的代码中的第七行填上下面这句代码：注意缩进</p>
<p><code>System.out.println(&quot;hello world&quot;)</code></p>
<p><img src="https://img-blog.csdnimg.cn/a32ea550651e4a9c96477f9d5a7d1bbe.png#pic_center" alt="a" /></p>
<p>6.点击运行之后会弹出一个新的窗口，点击OK</p>
<p><img src="https://img-blog.csdnimg.cn/0d3e4c3241ed4491aed820b13861da2d.png#pic_center" alt="a" /></p>
<p>底部控制台出现hello world 则表示运行成功</p>
<p><img src="https://img-blog.csdnimg.cn/7ef0afd6553445bca289ace49dbd0ed5.png#pic_center" alt="a" /></p>
<p>如果运行没有出任何问题的话，那么恭喜你，eclipse已经配置成功了。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="google编码风格"><a class="header" href="#google编码风格">Google编码风格</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="数据类型"><a class="header" href="#数据类型">数据类型</a></h1>
<ul>
<li><a href="%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%90%86%E8%AE%BA.html#%E5%86%85%E7%BD%AE%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B">内置数据类型</a>
<ul>
<li><a href="%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%90%86%E8%AE%BA.html#%E6%95%B0%E5%80%BC%E7%B1%BB%E5%9E%8B%E5%8F%96%E5%80%BC%E8%8C%83%E5%9B%B4">数值类型取值范围</a></li>
<li><a href="%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%90%86%E8%AE%BA.html#%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2">进制转换</a></li>
<li><a href="%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%90%86%E8%AE%BA.html#%E7%B1%BB%E5%9E%8B%E9%BB%98%E8%AE%A4%E5%80%BC">类型默认值</a></li>
</ul>
</li>
<li><a href="%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%90%86%E8%AE%BA.html#%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B">引用类型</a></li>
<li><a href="%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%90%86%E8%AE%BA.html#%E5%B8%B8%E9%87%8F">常量</a></li>
<li><a href="%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%90%86%E8%AE%BA.html#%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2">类型转换</a>
<ul>
<li><a href="%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%90%86%E8%AE%BA.html#%E8%87%AA%E5%8A%A8%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2">自动类型转换</a></li>
<li><a href="%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%90%86%E8%AE%BA.html#%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2">强制类型转换</a></li>
<li><a href="%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%90%86%E8%AE%BA.html#%E9%9A%90%E5%90%AB%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2">隐含强制类型转换</a></li>
</ul>
</li>
</ul>
<p>变量就是申请内存来存储值。也就是说，当创建变量的时候，需要在内存中申请空间。</p>
<p>内存管理系统根据变量的类型为变量分配存储空间，分配的空间只能用来储存该类型数据。</p>
<p>因此，通过定义不同类型的变量，可以在内存中储存整数、小数或者字符。</p>
<p>Java 有两大数据类型:</p>
<ul>
<li>内置数据类型</li>
<li>引用数据类型</li>
</ul>
<h2 id="内置数据类型"><a class="header" href="#内置数据类型">内置数据类型</a></h2>
<p>Java语言提供了八种基本类型。六种数字类型（四个整数型，两个浮点型），一种字符类型，还有一种布尔型。</p>
<p>其中long型数据的&quot;L&quot;理论上不分大小写，但是若写成&quot;l&quot;容易与数字&quot;1&quot;混淆，不容易分辩。所以最好大写。</p>
<p><strong>浮点数比较不能用<code>==</code>！！！例如8.1/3和2.7。</strong></p>
<p>浮点数定义时可以省略一部分内容，但不能省略小数点。</p>
<pre><code class="language-java">public class helloworld {
 
	public static void main(String[] args) {
		// TODO Auto-generated method stub
		float f1 = .0001f;
		float f2 = 1.0e-1f;
		double d = 1.;
		System.out.println(f1);
		System.out.println(f2);
		System.out.println(d);
	}
}
</code></pre>
<p>输出结果：</p>
<pre><code>1.0E-4
0.1
1.0
</code></pre>
<p><strong>字符型数据占16位</strong>。</p>
<pre><code class="language-java">public class helloworld {
 
	public static void main(String[] args) {
		// TODO Auto-generated method stub
		char c = 'b' + 1;
		System.out.println(c); //c
		System.out.println((int)c); //99
		System.out.println((char)38889); //韩
	}
}
</code></pre>
<p>在Java中不能使用0表示false，也不能使用非0的整数表示true。</p>
<h3 id="数值类型取值范围"><a class="header" href="#数值类型取值范围">数值类型取值范围</a></h3>
<p>float数据类型精度7位，double数据类型精度11位。</p>
<p>对于数值类型的基本类型的取值范围，我们无需强制去记忆，因为它们的值都已经以常量的形式定义在对应的包装类中了。请看下面的例子：</p>
<pre><code class="language-java">public class PrimitiveTypeTest {  
    public static void main(String[] args) {  
        // byte  
        System.out.println(&quot;基本类型：byte 二进制位数：&quot; + Byte.SIZE);  
        System.out.println(&quot;包装类：java.lang.Byte&quot;);  
        System.out.println(&quot;最小值：Byte.MIN_VALUE=&quot; + Byte.MIN_VALUE);  
        System.out.println(&quot;最大值：Byte.MAX_VALUE=&quot; + Byte.MAX_VALUE);  
        System.out.println();  
  
        // short  
        System.out.println(&quot;基本类型：short 二进制位数：&quot; + Short.SIZE);  
        System.out.println(&quot;包装类：java.lang.Short&quot;);  
        System.out.println(&quot;最小值：Short.MIN_VALUE=&quot; + Short.MIN_VALUE);  
        System.out.println(&quot;最大值：Short.MAX_VALUE=&quot; + Short.MAX_VALUE);  
        System.out.println();  
  
        // int  
        System.out.println(&quot;基本类型：int 二进制位数：&quot; + Integer.SIZE);  
        System.out.println(&quot;包装类：java.lang.Integer&quot;);  
        System.out.println(&quot;最小值：Integer.MIN_VALUE=&quot; + Integer.MIN_VALUE);  
        System.out.println(&quot;最大值：Integer.MAX_VALUE=&quot; + Integer.MAX_VALUE);  
        System.out.println();  
  
        // long  
        System.out.println(&quot;基本类型：long 二进制位数：&quot; + Long.SIZE);  
        System.out.println(&quot;包装类：java.lang.Long&quot;);  
        System.out.println(&quot;最小值：Long.MIN_VALUE=&quot; + Long.MIN_VALUE);  
        System.out.println(&quot;最大值：Long.MAX_VALUE=&quot; + Long.MAX_VALUE);  
        System.out.println();  
  
        // float  
        System.out.println(&quot;基本类型：float 二进制位数：&quot; + Float.SIZE);  
        System.out.println(&quot;包装类：java.lang.Float&quot;);  
        System.out.println(&quot;最小值：Float.MIN_VALUE=&quot; + Float.MIN_VALUE);  
        System.out.println(&quot;最大值：Float.MAX_VALUE=&quot; + Float.MAX_VALUE);  
        System.out.println();  
  
        // double  
        System.out.println(&quot;基本类型：double 二进制位数：&quot; + Double.SIZE);  
        System.out.println(&quot;包装类：java.lang.Double&quot;);  
        System.out.println(&quot;最小值：Double.MIN_VALUE=&quot; + Double.MIN_VALUE);  
        System.out.println(&quot;最大值：Double.MAX_VALUE=&quot; + Double.MAX_VALUE);  
        System.out.println();  
  
        // char  
        System.out.println(&quot;基本类型：char 二进制位数：&quot; + Character.SIZE);  
        System.out.println(&quot;包装类：java.lang.Character&quot;);  
        // 以数值形式而不是字符形式将Character.MIN_VALUE输出到控制台  
        System.out.println(&quot;最小值：Character.MIN_VALUE=&quot;  
                + (int) Character.MIN_VALUE);  
        // 以数值形式而不是字符形式将Character.MAX_VALUE输出到控制台  
        System.out.println(&quot;最大值：Character.MAX_VALUE=&quot;  
                + (int) Character.MAX_VALUE);  
    }  
}
</code></pre>
<p>编译以上代码输出结果如下所示：</p>
<pre><code>基本类型：byte 二进制位数：8
包装类：java.lang.Byte
最小值：Byte.MIN_VALUE=-128
最大值：Byte.MAX_VALUE=127

基本类型：short 二进制位数：16
包装类：java.lang.Short
最小值：Short.MIN_VALUE=-32768
最大值：Short.MAX_VALUE=32767

基本类型：int 二进制位数：32
包装类：java.lang.Integer
最小值：Integer.MIN_VALUE=-2147483648
最大值：Integer.MAX_VALUE=2147483647

基本类型：long 二进制位数：64
包装类：java.lang.Long
最小值：Long.MIN_VALUE=-9223372036854775808
最大值：Long.MAX_VALUE=9223372036854775807

基本类型：float 二进制位数：32
包装类：java.lang.Float
最小值：Float.MIN_VALUE=1.4E-45
最大值：Float.MAX_VALUE=3.4028235E38

基本类型：double 二进制位数：64
包装类：java.lang.Double
最小值：Double.MIN_VALUE=4.9E-324
最大值：Double.MAX_VALUE=1.7976931348623157E308

基本类型：char 二进制位数：16
包装类：java.lang.Character
最小值：Character.MIN_VALUE=0
最大值：Character.MAX_VALUE=65535
</code></pre>
<p>float和double的最小值和最大值都是以科学记数法的形式输出的，结尾的&quot;E+数字&quot;表示E之前的数字要乘以10的多少次方。比如3.14E3就是3.14 × 10^3 =3140，3.14E-3 就是 3.14x10^{-3} =0.00314。</p>
<p>实际上，JAVA中还存在另外一种基本类型 void，它也有对应的包装类 java.lang.Void，不过我们无法直接对它们进行操作。</p>
<h3 id="进制转换"><a class="header" href="#进制转换">进制转换</a></h3>
<pre><code class="language-java">public class helloworld {
 
	public static void main(String[] args) {
		// TODO Auto-generated method stub
		int num1 = 0b1010;
		int num2 = 01010;
		int num3 = 1010;
		int num4 = 0x1010;
		char c = '漢';
		
		System.out.println(&quot;num1 = &quot; + num1);
		System.out.println(&quot;num2 = &quot; + num2);
		System.out.println(&quot;num3 = &quot; + num3);
		System.out.println(&quot;num4 = &quot; + num4);
		System.out.println(&quot;漢的utf-8编码为： &quot; + (int)c);
	}
}
</code></pre>
<p>输出结果如下：</p>
<pre><code>num1 = 10
num2 = 520
num3 = 1010
num4 = 4112
漢的utf-8编码为： 28450
</code></pre>
<h3 id="类型默认值"><a class="header" href="#类型默认值">类型默认值</a></h3>
<p>下表列出了 Java 各个类型的默认值：</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left"><strong>数据类型</strong></th><th style="text-align: left"><strong>默认值</strong></th></tr></thead><tbody>
<tr><td style="text-align: left">byte</td><td style="text-align: left">0</td></tr>
<tr><td style="text-align: left">short</td><td style="text-align: left">0</td></tr>
<tr><td style="text-align: left">int</td><td style="text-align: left">0</td></tr>
<tr><td style="text-align: left">long</td><td style="text-align: left">0L</td></tr>
<tr><td style="text-align: left">float</td><td style="text-align: left">0.0f</td></tr>
<tr><td style="text-align: left">double</td><td style="text-align: left">0.0d</td></tr>
<tr><td style="text-align: left">char</td><td style="text-align: left">'u0000'</td></tr>
<tr><td style="text-align: left">String (or any object)</td><td style="text-align: left">null</td></tr>
<tr><td style="text-align: left">boolean</td><td style="text-align: left">false</td></tr>
<tr><td style="text-align: left">测试示例：</td><td style="text-align: left"></td></tr>
</tbody></table>
</div>
<pre><code class="language-java">public class Test {
    static boolean bool;
    static byte by;
    static char ch;
    static double d;
    static float f;
    static int i;
    static long l;
    static short sh;
    static String str;
 
    public static void main(String[] args) {
        System.out.println(&quot;Bool :&quot; + bool);
        System.out.println(&quot;Byte :&quot; + by);
        System.out.println(&quot;Character:&quot; + ch);
        System.out.println(&quot;Double :&quot; + d);
        System.out.println(&quot;Float :&quot; + f);
        System.out.println(&quot;Integer :&quot; + i);
        System.out.println(&quot;Long :&quot; + l);
        System.out.println(&quot;Short :&quot; + sh);
        System.out.println(&quot;String :&quot; + str);
    }
}
</code></pre>
<p>实例输出结果：</p>
<pre><code>Bool     :false
Byte     :0
Character:
Double   :0.0
Float    :0.0
Integer  :0
Long     :0
Short    :0
String   :null
</code></pre>
<h2 id="引用类型"><a class="header" href="#引用类型">引用类型</a></h2>
<p>引用类型主要包括类（class）、接口（interface）和数组。</p>
<ul>
<li>在Java中，引用类型的变量非常类似于C/C++的指针。引用类型指向一个对象，指向对象的变量是引用变量。这些变量在声明时被指定为一个特定的类型，比如 Employee、Puppy 等。变量一旦声明后，类型就不能被改变了。</li>
<li>对象、数组都是引用数据类型。</li>
<li>所有引用类型的默认值都是null。</li>
<li>一个引用变量可以用来引用任何与之兼容的类型。</li>
<li>例子：Site site = new Site(&quot;Runoob&quot;)。</li>
</ul>
<h2 id="常量"><a class="header" href="#常量">常量</a></h2>
<p>常量在程序运行时是不能被修改的。</p>
<p>在 Java 中使用 final 关键字来修饰常量，声明方式和变量类似：</p>
<pre><code class="language-java">final double PI = 3.1415927;
</code></pre>
<p>常量名虽然也可以用小写，但为了便于识别，通常使用大写字母表示常量。</p>
<p>字面量可以赋给任何内置类型的变量。例如：</p>
<pre><code class="language-java">byte a = 68;
char a = 'A'
</code></pre>
<p>byte、int、long和short都可以用十进制、16进制以及8进制的方式来表示。</p>
<p>当使用字面量的时候，前缀 0 表示 8 进制，而前缀 0x 代表 16 进制, 例如：</p>
<pre><code class="language-java">int decimal = 100;
int octal = 0144;
int hexa =  0x64;
</code></pre>
<p>和其他语言一样，Java的字符串常量也是包含在两个引号之间的字符序列。下面是字符串型字面量的例子：</p>
<pre><code class="language-java">&quot;Hello World&quot;
&quot;two\nlines&quot;
&quot;\&quot;This is in quotes\&quot;&quot;
</code></pre>
<p>字符串常量和字符变量都可以包含任何 Unicode 字符。例如：</p>
<pre><code class="language-java">char a = '\u0001';
String a = &quot;\u0001&quot;;
</code></pre>
<p>Java语言支持一些特殊的转义字符序列。</p>
<div class="table-wrapper"><table><thead><tr><th>符号</th><th>字符含义</th></tr></thead><tbody>
<tr><td>\n</td><td>换行 (0x0a)</td></tr>
<tr><td>\r</td><td>回车 (0x0d)</td></tr>
<tr><td>\f</td><td>换页符(0x0c)</td></tr>
<tr><td>\b</td><td>退格 (0x08)</td></tr>
<tr><td>\0</td><td>空字符 (0x0)</td></tr>
<tr><td>\s</td><td>空格 (0x20)</td></tr>
<tr><td>\t</td><td>制表符</td></tr>
<tr><td>&quot;</td><td>双引号</td></tr>
<tr><td>'</td><td>单引号</td></tr>
<tr><td>\</td><td>反斜杠</td></tr>
<tr><td>\ddd</td><td>八进制字符 (ddd)</td></tr>
<tr><td>\uxxxx</td><td>16进制Unicode字符 (xxxx)</td></tr>
</tbody></table>
</div>
<h2 id="类型转换"><a class="header" href="#类型转换">类型转换</a></h2>
<h3 id="自动类型转换"><a class="header" href="#自动类型转换">自动类型转换</a></h3>
<p><strong>整型、实型（常量）、字符型数据可以混合运算。运算中，不同类型的数据先转化为同一类型（容量最大的那种类型），然后进行运算。</strong></p>
<p>转换从低级到高级顺序：</p>
<pre><code>低  ------------------------------------&gt;  高

byte,short,char—&gt; int —&gt; long—&gt; float —&gt; double 

</code></pre>
<p>（byte、short）和char之间赋值时不会发生自动类型转换，例如<code>byte b = 97;char c = b;</code>这种写法会报错。（byte、short）和char之间可以通过转换为int类型然后运算，例如<code>byte b = 97;short s = 10;short s2 = s + b;</code>也会报错。byte类型数据和byte类型数据之间运算结果也是int类型数据，例如<code>byte b1 = 97;byte b2 = 1;byte b = b1 + b2;</code>也会报错。</p>
<p><strong>自动类型转换必须满足转换前的数据类型的位数要低于转换后的数据类型，例如: short数据类型的位数为16位，就可以自动转换位数为32的int类型，同样float数据类型的位数为32，可以自动转换为64位的double类型。</strong></p>
<pre><code class="language-java">public class helloworld {
 
	public static void main(String[] args) {
		// TODO Auto-generated method stub
		char c1='a';//定义一个char类型
        int i1 = c1;//char自动类型转换为int
        System.out.println(&quot;char自动类型转换为int后的值等于&quot;+i1);
        char c2 = 'A';//定义一个char类型
        int i2 = c2+1;//char 类型和 int 类型计算
        System.out.println(&quot;char类型和int计算后的值等于&quot;+i2);
	}

}
</code></pre>
<p>运行结果为：</p>
<pre><code>char自动类型转换为int后的值等于97
char类型和int计算后的值等于66
</code></pre>
<p>数据类型转换必须满足如下规则：</p>
<p>1.不能对boolean类型进行类型转换。</p>
<p>2.不能把对象类型转换成不相关类的对象。</p>
<p>3.<strong>在把容量大的类型转换为容量小的类型时必须使用强制类型转换。</strong></p>
<p>4.转换过程中可能导致溢出或损失精度，例如：</p>
<pre><code class="language-java">public class helloworld {
 
	public static void main(String[] args) {
		// TODO Auto-generated method stub
		int i =128;   
		byte b = (byte)i;

		System.out.println(b);//输出-128
	}

}
</code></pre>
<p>因为 byte 类型是 8 位，最大值为127，所以当 int 强制转换为 byte 类型时，值 128 时候就会导致溢出。</p>
<p>5.<strong>浮点数到整数的转换是通过舍弃小数得到，而不是四舍五入，也可以视为向零舍去</strong>，例如：</p>
<pre><code class="language-java">public class helloworld {
 
	public static void main(String[] args) {
		// TODO Auto-generated method stub
		System.out.println((int)23.7 == 23);//true
		System.out.println((int)-45.89f == -45);//true
	}

}
</code></pre>
<h3 id="强制类型转换"><a class="header" href="#强制类型转换">强制类型转换</a></h3>
<p>定义语句<code>int n1 = 9L;</code>会报错，定义语句<code>float f = 1.1;</code>也会报错。</p>
<ul>
<li>
<ol>
<li>条件是转换的数据类型必须是兼容的。</li>
</ol>
</li>
<li>
<ol start="2">
<li>格式：(type)value中 type是要强制类型转换后的数据类型 </li>
</ol>
</li>
<li>3.强制转换符号只对最近的操作数有效，可以用小括号指定强制类型转换范围</li>
<li>4.char类型可以保存int类型常量值，但不能保存int类型变量值（此时需要强制类型转换）</li>
<li>5.byte、short、char类型数据参与运算时当作int类型处理</li>
</ul>
<p>基本数据类型和String类型的转换：</p>
<ul>
<li>基本数据类型转String类型：加“”即可</li>
<li>String类型转基本数据类型：根据基本数据类型的包装类调用parserXX方法即可，要获取特定字符可以使用字符串变量的charAt()方法</li>
</ul>
<pre><code class="language-java">public class helloworld {
 
	public static void main(String[] args) {
		// TODO Auto-generated method stub
		int num1 = 10;
		String s1 = num1 + &quot;&quot;;
		System.out.println(s1);
		
		String s2 = &quot;123&quot;;
		int num2 = Integer.parseInt(s2);
		System.out.println(num2);
		double num3 = Double.parseDouble(s2);
		System.out.println(num3);
		char c = s2.charAt(1);
		System.out.println(c);
	}
}
</code></pre>
<p>输出结果如下：</p>
<pre><code>10
123
123.0
2
</code></pre>
<h3 id="隐含强制类型转换"><a class="header" href="#隐含强制类型转换">隐含强制类型转换</a></h3>
<ul>
<li>1.整数的默认类型是 int。</li>
<li>2.小数默认是 double 类型浮点型，在定义 float 类型时必须在数字后面跟上 F 或者 f。</li>
</ul>
<p>涉及+号的数值类型转换，从左向右运算。如果+号左右两边都是数值类型则做加法运算；如果左右有一部分是字符串则作字符串拼接。</p>
<pre><code class="language-java">public class helloworld {
 
	public static void main(String[] args) {
		// TODO Auto-generated method stub
		System.out.println(100 + 98);
		System.out.println(&quot;100&quot; + 98);
		System.out.println(100 + 98 + &quot;hello&quot;);
		System.out.println(&quot;hello&quot; + 100 + 98);
	}
}
</code></pre>
<pre><code>198
10098
198hello
hello10098
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="java运算符"><a class="header" href="#java运算符">Java运算符</a></h1>
<ul>
<li><a href="%E8%BF%90%E7%AE%97%E7%AC%A6.html#%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97%E7%AC%A6">算术运算符</a></li>
<li><a href="%E8%BF%90%E7%AE%97%E7%AC%A6.html#%E5%85%B3%E7%B3%BB%E8%BF%90%E7%AE%97%E7%AC%A6">关系运算符</a></li>
<li><a href="%E8%BF%90%E7%AE%97%E7%AC%A6.html#instanceof-%E8%BF%90%E7%AE%97%E7%AC%A6">instanceof 运算符</a></li>
<li><a href="%E8%BF%90%E7%AE%97%E7%AC%A6.html#%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6">位运算符</a></li>
<li><a href="%E8%BF%90%E7%AE%97%E7%AC%A6.html#%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6">逻辑运算符</a></li>
<li><a href="%E8%BF%90%E7%AE%97%E7%AC%A6.html#%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6">赋值运算符</a></li>
<li><a href="%E8%BF%90%E7%AE%97%E7%AC%A6.html#%E6%9D%A1%E4%BB%B6%E8%BF%90%E7%AE%97%E7%AC%A6">条件运算符（?:）</a></li>
<li><a href="%E8%BF%90%E7%AE%97%E7%AC%A6.html#java%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7">Java运算符优先级</a></li>
</ul>
<p>计算机的最基本用途之一就是执行数学运算，作为一门计算机语言，Java也提供了一套丰富的运算符来操纵变量。我们可以把运算符分成以下几组：</p>
<ul>
<li>算术运算符</li>
<li>关系运算符</li>
<li>位运算符</li>
<li>逻辑运算符</li>
<li>赋值运算符</li>
<li>其他运算符</li>
</ul>
<h2 id="算术运算符"><a class="header" href="#算术运算符">算术运算符</a></h2>
<p>算术运算符用在数学表达式中，它们的作用和在数学中的作用一样。下表列出了所有的算术运算符。</p>
<p>表格中的实例假设整数变量A的值为10，变量B的值为20：</p>
<div class="table-wrapper"><table><thead><tr><th>操作符</th><th>描述</th><th>例子</th></tr></thead><tbody>
<tr><td>+</td><td>加法 - 相加运算符两侧的值</td><td>A + B 等于 30</td></tr>
<tr><td>-</td><td>减法 - 左操作数减去右操作数</td><td>A – B 等于 -10</td></tr>
<tr><td>*</td><td>乘法 - 相乘操作符两侧的值</td><td>A * B等于200</td></tr>
<tr><td>/</td><td>除法 - 左操作数除以右操作数</td><td>B / A等于2</td></tr>
<tr><td>％</td><td>取余 - 左操作数除以右操作数的余数</td><td>B%A等于0</td></tr>
<tr><td>++</td><td>自增: 操作数的值增加1</td><td>B++ 或 ++B 等于 21（区别详见下文）</td></tr>
<tr><td>--</td><td>自减: 操作数的值减少1</td><td>B-- 或 --B 等于 19（区别详见下文）</td></tr>
</tbody></table>
</div>
<pre><code class="language-java">public class helloworld {
 
	public static void main(String[] args) {
		// TODO Auto-generated method stub
		int a = 10;
	    int b = 20;
	    int c = 25;
	    System.out.println(&quot;a + b = &quot; + (a + b) );
	    System.out.println(&quot;a - b = &quot; + (a - b) );
	    System.out.println(&quot;a * b = &quot; + (a * b) );
	    System.out.println(&quot;b / a = &quot; + (b / a) );
	    System.out.println(&quot;b % a = &quot; + (b % a) );
	    System.out.println(&quot;c % a = &quot; + (c % a) );
	    System.out.println(&quot;a++   = &quot; +  (a++) );
	    System.out.println(&quot;a--   = &quot; +  (a--) );
	    // 查看  d++ 与 ++d 的不同
	    int d = 25;
	    System.out.println(&quot;d++   = &quot; +  (d++) );
	    d = 25;
	    System.out.println(&quot;++d   = &quot; +  (++d) );
	}
}
</code></pre>
<pre><code>a + b = 30
a - b = -10
a * b = 200
b / a = 2
b % a = 0
c % a = 5
a++   = 10
a--   = 11
d++   = 25
++d   = 26
</code></pre>
<p><strong>自增自减运算符</strong></p>
<p><strong>1、自增（++）自减（--）运算符</strong>是一种特殊的算术运算符，在算术运算符中需要两个操作数来进行运算，而自增自减运算符是一个操作数。</p>
<p>2、前缀自增自减法(++a,--a): 先进行自增或者自减运算，再进行表达式运算。</p>
<p>3、后缀自增自减法(a++,a--): 先进行表达式运算，再进行自增或者自减运算。</p>
<p>典例：</p>
<pre><code class="language-java">public class helloworld {
 
	public static void main(String[] args) {
		// TODO Auto-generated method stub
		int i = 10;
		i = i++;
		System.out.println(i);
		i = 10;
		i = ++i;
		System.out.println(i);
	}
}
</code></pre>
<p>输出结果如下：</p>
<pre><code>10
11
</code></pre>
<p>原因解释：</p>
<p>对于<code>i = i++;</code>这种自增运算需要一个临时变量temp，即（1）temp = i;（2）i = i + 1;（3）i = temp;第（1）步中的i是表达式右边的i，第（3）步中的i是表达式左边的i。</p>
<p>对于<code>i = ++i;</code>这种自增运算需要一个临时变量temp，即（1）i = i + 1;（2）temp = i;（3）i = temp;第（1）步中的i是表达式右边的i，第（3）步中的i是表达式左边的i。</p>
<h2 id="关系运算符"><a class="header" href="#关系运算符">关系运算符</a></h2>
<p>下表为Java支持的关系运算符</p>
<p>表格中的实例整数变量A的值为10，变量B的值为20：</p>
<div class="table-wrapper"><table><thead><tr><th>运算符</th><th>描述</th><th>例子</th></tr></thead><tbody>
<tr><td>==</td><td>检查如果两个操作数的值是否相等，如果相等则条件为真。</td><td>（A == B）为假。</td></tr>
<tr><td>!=</td><td>检查如果两个操作数的值是否相等，如果值不相等则条件为真。</td><td>(A != B) 为真。</td></tr>
<tr><td>&gt;</td><td>检查左操作数的值是否大于右操作数的值，如果是那么条件为真。</td><td>（A&gt; B）为假。</td></tr>
<tr><td>&lt;</td><td>检查左操作数的值是否小于右操作数的值，如果是那么条件为真。</td><td>（A &lt;B）为真。</td></tr>
<tr><td>&gt;=</td><td>检查左操作数的值是否大于或等于右操作数的值，如果是那么条件为真。</td><td>（A&gt; = B）为假。</td></tr>
<tr><td>&lt;=</td><td>检查左操作数的值是否小于或等于右操作数的值，如果是那么条件为真。</td><td>（A &lt;= B）为真。</td></tr>
<tr><td>实例：</td><td></td><td></td></tr>
</tbody></table>
</div>
<pre><code class="language-java">public class helloworld {
 
	public static void main(String[] args) {
		// TODO Auto-generated method stub
		int a = 10;
	    int b = 20;
	    System.out.println(&quot;a == b = &quot; + (a == b) );
	    System.out.println(&quot;a != b = &quot; + (a != b) );
	    System.out.println(&quot;a &gt; b = &quot; + (a &gt; b) );
	    System.out.println(&quot;a &lt; b = &quot; + (a &lt; b) );
	    System.out.println(&quot;b &gt;= a = &quot; + (b &gt;= a) );
	    System.out.println(&quot;b &lt;= a = &quot; + (b &lt;= a) );
	}
}

</code></pre>
<p>输出结果如下：</p>
<pre><code>a == b = false
a != b = true
a &gt; b = false
a &lt; b = true
b &gt;= a = true
b &lt;= a = false
</code></pre>
<h2 id="instanceof-运算符"><a class="header" href="#instanceof-运算符">instanceof 运算符</a></h2>
<p>该运算符用于操作对象实例，检查该对象是否是一个特定类型（类类型或接口类型）。</p>
<p>instanceof运算符使用格式如下：</p>
<pre><code class="language-java">( Object reference variable ) instanceof  (class/interface type)
</code></pre>
<p>如果运算符左侧变量所指的对象，是操作符右侧类或接口(class/interface)的一个对象，那么结果为真。</p>
<p>下面是一个例子：</p>
<pre><code class="language-java">String name = &quot;James&quot;;
boolean result = name instanceof String; // 由于 name 是 String 类型，所以返回真
</code></pre>
<p>如果被比较的对象兼容于右侧类型，该运算符仍然返回 true。</p>
<p>看下面的例子：</p>
<pre><code class="language-java">class Vehicle {}
 
public class Car extends Vehicle {
   public static void main(String[] args){
      Vehicle a = new Car();
      boolean result =  a instanceof Car;
      System.out.println(result);
   }
}
</code></pre>
<p>以上实例编译运行结果如下：</p>
<pre><code>true
</code></pre>
<h2 id="位运算符"><a class="header" href="#位运算符">位运算符</a></h2>
<p>Java定义了位运算符，应用于整数类型(int)，长整型(long)，短整型(short)，字符型(char)，和字节型(byte)等类型。</p>
<p>位运算符作用在所有的位上，并且按位运算。假设a = 60，b = 13;它们的二进制格式表示将如下：</p>
<pre><code class="language-java">A = 0011 1100
B = 0000 1101
-----------------
A&amp;B = 0000 1100
A | B = 0011 1101
A ^ B = 0011 0001
~A= 1100 0011
</code></pre>
<p>下表列出了位运算符的基本运算，假设整数变量 A 的值为 60 和变量 B 的值为 13：</p>
<div class="table-wrapper"><table><thead><tr><th>操作符</th><th>描述</th><th>例子</th></tr></thead><tbody>
<tr><td>＆</td><td>如果相对应位都是1，则结果为1，否则为0</td><td>（A＆B），得到12，即0000 1100</td></tr>
<tr><td>|</td><td>如果相对应位都是 0，则结果为 0，否则为 1</td><td>（A | B）得到61，即 0011 1101</td></tr>
<tr><td>^</td><td>如果相对应位值相同，则结果为0，否则为1</td><td>（A ^ B）得到49，即 0011 0001</td></tr>
<tr><td>〜</td><td>按位取反运算符翻转操作数的每一位，即0变成1，1变成0。</td><td>（〜A）得到-61，即1100 0011</td></tr>
<tr><td>&lt;&lt;</td><td>按位左移运算符。左操作数按位左移右操作数指定的位数。</td><td>A &lt;&lt; 2得到240，即 1111 0000</td></tr>
<tr><td>&gt;&gt;</td><td>按位右移运算符。左操作数按位右移右操作数指定的位数。</td><td>A &gt;&gt; 2得到15即 1111</td></tr>
<tr><td>&gt;&gt;&gt;</td><td>按位右移补零操作符。左操作数的值按右操作数指定的位数右移，移动得到的空位以零填充。</td><td>A&gt;&gt;&gt;2得到15即0000 1111</td></tr>
</tbody></table>
</div>
<p>实例：</p>
<pre><code class="language-java">public class helloworld {
 
	public static void main(String[] args) {
		// TODO Auto-generated method stub
		int a = 60; /* 60 = 0011 1100 */ 
	    int b = 13; /* 13 = 0000 1101 */
	    int c = 0;
	    c = a &amp; b;       /* 12 = 0000 1100 */
	    System.out.println(&quot;a &amp; b = &quot; + c );
	 
	    c = a | b;       /* 61 = 0011 1101 */
	    System.out.println(&quot;a | b = &quot; + c );
	 
	    c = a ^ b;       /* 49 = 0011 0001 */
	    System.out.println(&quot;a ^ b = &quot; + c );
	 
	    c = ~a;          /*-61 = 1100 0011 */
	    System.out.println(&quot;~a = &quot; + c );
	 
	    c = a &lt;&lt; 2;     /* 240 = 1111 0000 */
	    System.out.println(&quot;a &lt;&lt; 2 = &quot; + c );
	 
	    c = a &gt;&gt; 2;     /* 15 = 1111 */
	    System.out.println(&quot;a &gt;&gt; 2  = &quot; + c );
	  
	    c = a &gt;&gt;&gt; 2;     /* 15 = 0000 1111 */
	    System.out.println(&quot;a &gt;&gt;&gt; 2 = &quot; + c );
	}
}
</code></pre>
<p>输出结果如下：</p>
<pre><code>a &amp; b = 12
a | b = 61
a ^ b = 49
~a = -61
a &lt;&lt; 2 = 240
a &gt;&gt; 2  = 15
a &gt;&gt;&gt; 2 = 15
</code></pre>
<h2 id="逻辑运算符"><a class="header" href="#逻辑运算符">逻辑运算符</a></h2>
<p>下表列出了逻辑运算符的基本运算，假设布尔变量A为真，变量B为假</p>
<div class="table-wrapper"><table><thead><tr><th>操作符</th><th>描述</th><th>例子</th></tr></thead><tbody>
<tr><td>&amp;&amp;</td><td>称为逻辑与运算符。当且仅当两个操作数都为真，条件才为真。</td><td>（A &amp;&amp; B）为假。</td></tr>
<tr><td>| |</td><td>称为逻辑或操作符。如果任何两个操作数任何一个为真，条件为真。</td><td>（A | | B）为真。</td></tr>
<tr><td>！</td><td>称为逻辑非运算符。用来反转操作数的逻辑状态。如果条件为true，则逻辑非运算符将得到false。</td><td>！（A &amp;&amp; B）为真。</td></tr>
<tr><td>下面的简单示例程序演示了逻辑运算符。</td><td></td><td></td></tr>
</tbody></table>
</div>
<pre><code class="language-java">public class helloworld {
 
	public static void main(String[] args) {
		// TODO Auto-generated method stub
		boolean a = true;
	    boolean b = false;
	    System.out.println(&quot;a &amp;&amp; b = &quot; + (a&amp;&amp;b));
	    System.out.println(&quot;a || b = &quot; + (a||b) );
	    System.out.println(&quot;!(a &amp;&amp; b) = &quot; + !(a &amp;&amp; b));
	}
}

</code></pre>
<p>以上实例编译运行结果如下：</p>
<pre><code>a &amp;&amp; b = false
a || b = true
!(a &amp;&amp; b) = true
</code></pre>
<p><strong>短路逻辑运算符</strong></p>
<p>当使用与逻辑运算符时，在两个操作数都为true时，结果才为true，但是当得到第一个操作为false时，其结果就必定是false，这时候就不会再判断第二个操作了。</p>
<pre><code class="language-java">public class helloworld {
 
	public static void main(String[] args) {
		// TODO Auto-generated method stub
		int a = 5;//定义一个变量；
        boolean b = (a&lt;4)&amp;&amp;(a++&lt;10);
        System.out.println(&quot;使用短路逻辑运算符的结果为&quot;+b);
        System.out.println(&quot;a的结果为&quot;+a);
	}
}
</code></pre>
<pre><code>使用短路逻辑运算符的结果为false
a的结果为5
</code></pre>
<p><strong>解析：</strong> 该程序使用到了短路逻辑运算符(&amp;&amp;)，首先判断 a&lt;4 的结果为 false，则 b 的结果必定是 false，所以不再执行第二个操作 a++&lt;10 的判断，所以 a 的值为 5。</p>
<p>位运算符也可以用在逻辑比较中。如下面例子所示：</p>
<pre><code class="language-java">public class helloworld {
 
	public static void main(String[] args) {
		// TODO Auto-generated method stub
		int x = 5;
        int y = 5;
        if(x++ == 6 &amp; ++y == 6)//位运算 
        {
        	x = 11;
        }
        System.out.println(&quot;x = &quot; + x + &quot; y = &quot; + y );//6,6
        x = 5;
        y = 5;
        if(x++ == 6 &amp;&amp; ++y == 6) //逻辑与，短路运算
        {
        	x = 11;
        }
        System.out.println(&quot;x = &quot; + x + &quot; y = &quot; + y );//6,5
        x = 5;
        y = 5;
        if(x++ == 6 | ++y == 6)//位运算
        {
        	x = 11;
        }
        System.out.println(&quot;x = &quot; + x + &quot; y = &quot; + y );//11,6
        
        x = 5;
        y = 5;
        if(x++ == 6 || ++y == 6)//逻辑或，短路运算
        {
        	x = 11;
        }
        System.out.println(&quot;x = &quot; + x + &quot; y = &quot; + y );//11,5
	}
}
</code></pre>
<p>输出结果如下：</p>
<pre><code>x = 6 y = 6
x = 6 y = 5
x = 11 y = 6
x = 11 y = 6
</code></pre>
<h2 id="赋值运算符"><a class="header" href="#赋值运算符">赋值运算符</a></h2>
<p>下面是Java语言支持的赋值运算符：</p>
<div class="table-wrapper"><table><thead><tr><th>操作符</th><th>描述</th><th>例子</th></tr></thead><tbody>
<tr><td>=</td><td>简单的赋值运算符，将右操作数的值赋给左侧操作数</td><td>C = A + B将把A + B得到的值赋给C</td></tr>
<tr><td>+ =</td><td>加和赋值操作符，它把左操作数和右操作数相加赋值给左操作数</td><td>C + = A等价于C = C + A</td></tr>
<tr><td>- =</td><td>减和赋值操作符，它把左操作数和右操作数相减赋值给左操作数</td><td>C - = A等价于C = C - A</td></tr>
<tr><td>* =</td><td>乘和赋值操作符，它把左操作数和右操作数相乘赋值给左操作数</td><td>C * = A等价于C = C * A</td></tr>
<tr><td>/ =</td><td>除和赋值操作符，它把左操作数和右操作数相除赋值给左操作数</td><td>C / = A，C 与 A 同类型时等价于 C = C / A</td></tr>
<tr><td>（％）=</td><td>取模和赋值操作符，它把左操作数和右操作数取模后赋值给左操作数</td><td>C％= A等价于C = C％A</td></tr>
<tr><td>&lt;&lt; =</td><td>左移位赋值运算符</td><td>C &lt;&lt; = 2等价于C = C &lt;&lt; 2</td></tr>
<tr><td>&gt;&gt; =</td><td>右移位赋值运算符</td><td>C &gt;&gt; = 2等价于C = C &gt;&gt; 2</td></tr>
<tr><td>＆=</td><td>按位与赋值运算符</td><td>C＆= 2等价于C = C＆2</td></tr>
<tr><td>^ =</td><td>按位异或赋值操作符</td><td>C ^ = 2等价于C = C ^ 2</td></tr>
<tr><td>| =</td><td>按位或赋值操作符</td><td>C | = 2等价于C = C | 2</td></tr>
</tbody></table>
</div>
<p>下面的简单示例程序演示了赋值运算符。</p>
<pre><code class="language-java">public class helloworld {
 
	public static void main(String[] args) {
		// TODO Auto-generated method stub
		int a = 10;
        int b = 20;
        int c = 0;
        c = a + b;
        System.out.println(&quot;c = a + b = &quot; + c );
        c += a ;
        System.out.println(&quot;c += a  = &quot; + c );
        c -= a ;
        System.out.println(&quot;c -= a = &quot; + c );
        c *= a ;
        System.out.println(&quot;c *= a = &quot; + c );
        a = 10;
        c = 15;
        c /= a ;
        System.out.println(&quot;c /= a = &quot; + c );
        a = 10;
        c = 15;
        c %= a ;
        System.out.println(&quot;c %= a  = &quot; + c );
        c &lt;&lt;= 2 ;
        System.out.println(&quot;c &lt;&lt;= 2 = &quot; + c );
        c &gt;&gt;= 2 ;
        System.out.println(&quot;c &gt;&gt;= 2 = &quot; + c );
        c &gt;&gt;= 2 ;
        System.out.println(&quot;c &gt;&gt;= 2 = &quot; + c );
        c &amp;= a ;
        System.out.println(&quot;c &amp;= a  = &quot; + c );
        c ^= a ;
        System.out.println(&quot;c ^= a   = &quot; + c );
        c |= a ;
        System.out.println(&quot;c |= a   = &quot; + c );
	}
}
</code></pre>
<p>以上实例编译运行结果如下：</p>
<pre><code>c = a + b = 30
c += a  = 40
c -= a = 30
c *= a = 300
c /= a = 1
c %= a  = 5
c &lt;&lt;= 2 = 20
c &gt;&gt;= 2 = 5
c &gt;&gt;= 2 = 1
c &amp;= a  = 0
c ^= a   = 10
c |= a   = 10
</code></pre>
<h2 id="条件运算符"><a class="header" href="#条件运算符">条件运算符（?:）</a></h2>
<p>条件运算符也被称为三元运算符。该运算符有3个操作数，并且需要判断布尔表达式的值。该运算符的主要是决定哪个值应该赋值给变量。</p>
<pre><code class="language-java">variable x = (expression) ? value if true : value if false
</code></pre>
<p>实例</p>
<pre><code class="language-java">public class helloworld {
 
	public static void main(String[] args) {
		// TODO Auto-generated method stub
		int a , b;
	    a = 10;
	    // 如果 a 等于 1 成立，则设置 b 为 20，否则为 30
	    b = (a == 1) ? 20 : 30;
	    System.out.println( &quot;Value of b is : &quot; +  b );
	 
	    // 如果 a 等于 10 成立，则设置 b 为 20，否则为 30
	    b = (a == 10) ? 20 : 30;
	    System.out.println( &quot;Value of b is : &quot; + b );
	}
}
</code></pre>
<p>输出结果如下：</p>
<pre><code>Value of b is : 30
Value of b is : 20
</code></pre>
<h2 id="java运算符优先级"><a class="header" href="#java运算符优先级">Java运算符优先级</a></h2>
<p>当多个运算符出现在一个表达式中，谁先谁后呢？这就涉及到运算符的优先级别的问题。在一个多运算符的表达式中，运算符优先级不同会导致最后得出的结果差别甚大。</p>
<p>例如，（1+3）＋（3+2）*2，这个表达式如果按加号最优先计算，答案就是 18，如果按照乘号最优先，答案则是 14。</p>
<p>再如，x = 7 + 3 * 2;这里x得到13，而不是20，因为乘法运算符比加法运算符有较高的优先级，所以先计算3 * 2得到6，然后再加7。</p>
<p>下表中具有最高优先级的运算符在的表的最上面，最低优先级的在表的底部。</p>
<div class="table-wrapper"><table><thead><tr><th>类别</th><th>操作符</th><th>关联性</th></tr></thead><tbody>
<tr><td>后缀</td><td>() [] . (点操作符)</td><td>左到右</td></tr>
<tr><td>一元</td><td>expr++ expr--</td><td>从左到右</td></tr>
<tr><td>一元</td><td>++expr --expr + - ～ ！</td><td>从右到左</td></tr>
<tr><td>乘性</td><td>* /％</td><td>左到右</td></tr>
<tr><td>加性</td><td>+ -</td><td>左到右</td></tr>
<tr><td>移位</td><td>&gt;&gt; &gt;&gt;&gt;  &lt;&lt;</td><td>左到右</td></tr>
<tr><td>关系</td><td>&gt; &gt;= &lt; &lt;=</td><td>左到右</td></tr>
<tr><td>相等</td><td>==  !=</td><td>左到右</td></tr>
<tr><td>按位与</td><td>＆</td><td>左到右</td></tr>
<tr><td>按位异或</td><td>^</td><td>左到右</td></tr>
<tr><td>按位或</td><td>|</td><td>左到右</td></tr>
<tr><td>逻辑与</td><td>&amp;&amp;</td><td>左到右</td></tr>
<tr><td>逻辑或</td><td>| |</td><td>左到右</td></tr>
<tr><td>条件</td><td>？：</td><td>从右到左</td></tr>
<tr><td>赋值</td><td>= + = - = * = / =％= &gt;&gt; = &lt;&lt; =＆= ^ = | =</td><td>从右到左</td></tr>
<tr><td>逗号</td><td>，</td><td>左到右</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="循环语句理论"><a class="header" href="#循环语句理论">循环语句理论</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="异常处理理论"><a class="header" href="#异常处理理论">异常处理理论</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="函数理论"><a class="header" href="#函数理论">函数理论</a></h1>
<ul>
<li><a href="%E5%87%BD%E6%95%B0%E7%90%86%E8%AE%BA.html#%E6%96%B9%E6%B3%95%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E8%B0%83%E7%94%A8">方法的定义和调用</a>
<ul>
<li><a href="%E5%87%BD%E6%95%B0%E7%90%86%E8%AE%BA.html#%E6%96%B9%E6%B3%95%E7%9A%84%E4%BC%98%E7%82%B9">方法的优点</a></li>
<li><a href="%E5%87%BD%E6%95%B0%E7%90%86%E8%AE%BA.html#%E6%96%B9%E6%B3%95%E7%9A%84%E5%91%BD%E5%90%8D%E8%A7%84%E5%88%99">方法的命名规则</a></li>
<li><a href="%E5%87%BD%E6%95%B0%E7%90%86%E8%AE%BA.html#%E6%96%B9%E6%B3%95%E7%9A%84%E5%AE%9A%E4%B9%89">方法的定义</a>
<ul>
<li><a href="%E5%87%BD%E6%95%B0%E7%90%86%E8%AE%BA.html#%E5%AE%9E%E4%BE%8B">实例</a></li>
</ul>
</li>
<li><a href="%E5%87%BD%E6%95%B0%E7%90%86%E8%AE%BA.html#%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8">方法调用</a>
<ul>
<li><a href="%E5%87%BD%E6%95%B0%E7%90%86%E8%AE%BA.html#%E5%AE%9E%E4%BE%8B-1">实例</a></li>
</ul>
</li>
<li><a href="%E5%87%BD%E6%95%B0%E7%90%86%E8%AE%BA.html#void-%E5%85%B3%E9%94%AE%E5%AD%97">void 关键字</a>
<ul>
<li><a href="%E5%87%BD%E6%95%B0%E7%90%86%E8%AE%BA.html#%E7%A4%BA%E4%BE%8B">示例</a></li>
</ul>
</li>
<li><a href="%E5%87%BD%E6%95%B0%E7%90%86%E8%AE%BA.html#%E9%80%9A%E8%BF%87%E5%80%BC%E4%BC%A0%E9%80%92%E5%8F%82%E6%95%B0">通过值传递参数</a>
<ul>
<li><a href="%E5%87%BD%E6%95%B0%E7%90%86%E8%AE%BA.html#%E7%A4%BA%E4%BE%8B-1">示例</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="%E5%87%BD%E6%95%B0%E7%90%86%E8%AE%BA.html#%E6%96%B9%E6%B3%95%E9%87%8D%E8%BD%BD">方法重载</a></li>
<li><a href="%E5%87%BD%E6%95%B0%E7%90%86%E8%AE%BA.html#%E5%8F%98%E9%87%8F%E4%BD%9C%E7%94%A8%E5%9F%9F">变量作用域</a></li>
<li><a href="%E5%87%BD%E6%95%B0%E7%90%86%E8%AE%BA.html#%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%BC%A0%E5%8F%82">命令行传参</a>
<ul>
<li><a href="%E5%87%BD%E6%95%B0%E7%90%86%E8%AE%BA.html#%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95">构造方法</a>
<ul>
<li><a href="%E5%87%BD%E6%95%B0%E7%90%86%E8%AE%BA.html#%E5%AE%9E%E4%BE%8B-2">实例</a></li>
<li><a href="%E5%87%BD%E6%95%B0%E7%90%86%E8%AE%BA.html#%E5%AE%9E%E4%BE%8B-3">实例</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="%E5%87%BD%E6%95%B0%E7%90%86%E8%AE%BA.html#%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0">可变参数</a>
<ul>
<li><a href="%E5%87%BD%E6%95%B0%E7%90%86%E8%AE%BA.html#%E5%AE%9E%E4%BE%8B-4">实例</a></li>
</ul>
</li>
<li><a href="%E5%87%BD%E6%95%B0%E7%90%86%E8%AE%BA.html#%E9%80%92%E5%BD%92">递归</a>
<ul>
<li><a href="%E5%87%BD%E6%95%B0%E7%90%86%E8%AE%BA.html#finalize-%E6%96%B9%E6%B3%95">finalize() 方法</a>
<ul>
<li><a href="%E5%87%BD%E6%95%B0%E7%90%86%E8%AE%BA.html#%E5%AE%9E%E4%BE%8B-5">实例</a></li>
<li><a href="%E5%87%BD%E6%95%B0%E7%90%86%E8%AE%BA.html#stringbuilder%E7%B1%BB">StringBuilder类</a></li>
<li><a href="%E5%87%BD%E6%95%B0%E7%90%86%E8%AE%BA.html#%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E6%97%A0%E6%B3%95%E8%B0%83%E7%94%A8%E8%87%AA%E5%B7%B1%E5%AE%9A%E4%B9%89%E7%9A%84%E9%9D%9E%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95">静态方法无法调用自己定义的非静态方法</a></li>
<li><a href="%E5%87%BD%E6%95%B0%E7%90%86%E8%AE%BA.html#%E9%80%92%E5%BD%92%E5%AE%9E%E8%B7%B5">递归实践</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="方法的定义和调用"><a class="header" href="#方法的定义和调用">方法的定义和调用</a></h1>
<p>Java方法是语句的集合，它们在一起执行一个功能。</p>
<ul>
<li>方法是解决一类问题的步骤的有序组合</li>
<li>方法包含于类或对象中</li>
<li>方法在程序中被创建，在其他地方被引用</li>
</ul>
<h3 id="方法的优点"><a class="header" href="#方法的优点">方法的优点</a></h3>
<ul>
<li>
<ol>
<li>使程序变得更简短而清晰。</li>
</ol>
</li>
<li>
<ol start="2">
<li>有利于程序维护。</li>
</ol>
</li>
<li>
<ol start="3">
<li>可以提高程序开发的效率。</li>
</ol>
</li>
<li>
<ol start="4">
<li>提高了代码的重用性。</li>
</ol>
</li>
</ul>
<h3 id="方法的命名规则"><a class="header" href="#方法的命名规则">方法的命名规则</a></h3>
<p>1.方法的名字的第一个单词应以小写字母作为开头，后面的单词则用大写字母开头写，不使用连接符。例如：<strong>addPerson</strong>。</p>
<p>2.下划线可能出现在 JUnit 测试方法名称中用以分隔名称的逻辑组件。一个典型的模式是：<strong>test<MethodUnderTest>_<state></strong>，例如 <strong>testPop_emptyStack</strong>。</p>
<h2 id="方法的定义"><a class="header" href="#方法的定义">方法的定义</a></h2>
<p>一般情况下，定义一个方法包含以下语法：</p>
<pre><code class="language-java">修饰符 返回值类型 方法名(参数类型 参数名){
    ...
    方法体
    ...
    return 返回值;
}
</code></pre>
<p>方法包含一个方法头和一个方法体。下面是一个方法的所有部分：</p>
<ul>
<li>**修饰符：**修饰符，这是可选的，告诉编译器如何调用该方法。定义了该方法的访问类型。</li>
<li><strong>返回值类型 ：<strong>方法可能会返回值。returnValueType 是方法返回值的数据类型。有些方法执行所需的操作，但没有返回值。在这种情况下，returnValueType 是关键字</strong>void</strong>。</li>
<li>**方法名：**是方法的实际名称。方法名和参数表共同构成方法签名。</li>
<li>**参数类型：**参数像是一个占位符。当方法被调用时，传递值给参数。这个值被称为实参或变量。参数列表是指方法的参数类型、顺序和参数的个数。参数是可选的，方法可以不包含任何参数。</li>
<li>**方法体：**方法体包含具体的语句，定义该方法的功能。</li>
</ul>
<p><img src="https://www.runoob.com/wp-content/uploads/2013/12/D53C92B3-9643-4871-8A72-33D491299653.jpg" alt="img" /></p>
<p>如：</p>
<pre><code class="language-java">public static int age(int birthday){...}
</code></pre>
<p>参数可以有多个：</p>
<pre><code class="language-java">static float interest(float principal, int year){...}
</code></pre>
<p><strong>注意：</strong> 在一些其它语言中方法指过程和函数。一个返回非void类型返回值的方法称为函数；一个返回void类型返回值的方法叫做过程。</p>
<h3 id="实例"><a class="header" href="#实例">实例</a></h3>
<p>下面的方法包含 2 个参数 num1 和 num2，它返回这两个参数的最大值。</p>
<pre><code class="language-java">/** 返回两个整型变量数据的较大值 */
public static int max(int num1, int num2) {
   int result;
   if (num1 &gt; num2)
      result = num1;
   else
      result = num2;
 
   return result; 
}
</code></pre>
<p>更简略的写法（三元运算符）：</p>
<pre><code class="language-java">public static int max(int num1, int num2) {
  return num1 &gt; num2 ? num1 : num2;
}
</code></pre>
<p>练习：加法函数</p>
<pre><code class="language-java">package method;

public class Demo1 {
    public static void main(String[] args) {
        //实参，实际调用
        int sum = add(1,2);
        System.out.println(sum);
    }
    //形参，用来定义作用
    public static int add(int a, int b){
        return a+b;
    }
}

</code></pre>
<p>return 0;可以终止函数执行</p>
<h2 id="方法调用"><a class="header" href="#方法调用">方法调用</a></h2>
<p>Java 支持两种调用方法的方式，根据方法是否返回值来选择。</p>
<p>当程序调用一个方法时，程序的控制权交给了被调用的方法。当被调用方法的返回语句执行或者到达方法体闭括号时候交还控制权给程序。</p>
<p>当方法返回一个值的时候，方法调用通常被当做一个值。例如：</p>
<pre><code class="language-java">int larger = max(30, 40);
</code></pre>
<p>如果方法返回值是void，方法调用一定是一条语句。例如，方法println返回void。下面的调用是个语句：</p>
<pre><code class="language-java">System.out.println(&quot;欢迎访问菜鸟教程！&quot;);
</code></pre>
<h3 id="实例-1"><a class="header" href="#实例-1">实例</a></h3>
<p>下面的例子演示了如何定义一个方法，以及如何调用它。TestMax.java 文件代码：</p>
<pre><code class="language-java">public class TestMax {
   /** 主方法 */
   public static void main(String[] args) {
      int i = 5;
      int j = 2;
      int k = max(i, j);
      System.out.println( i + &quot; 和 &quot; + j + &quot; 比较，最大值是：&quot; + k);
   }
 
   /** 返回两个整数变量较大的值 */
   public static int max(int num1, int num2) {
      int result;
      if (num1 &gt; num2)
         result = num1;
      else
         result = num2;
 
      return result; 
   }
}
</code></pre>
<p>以上实例编译运行结果如下：</p>
<pre><code>5 和 2 比较，最大值是：5
</code></pre>
<p>这个程序包含 main 方法和 max 方法。main 方法是被 JVM 调用的，除此之外，main 方法和其它方法没什么区别。</p>
<p>main 方法的头部是不变的，如例子所示，带修饰符 public 和 static,返回 void 类型值，方法名字是 main,此外带个一个 String[] 类型参数。String[] 表明参数是字符串数组。</p>
<h2 id="void-关键字"><a class="header" href="#void-关键字">void 关键字</a></h2>
<p>本节说明如何声明和调用一个 void 方法。</p>
<p>下面的例子声明了一个名为 printGrade 的方法，并且调用它来打印给定的分数。</p>
<h3 id="示例"><a class="header" href="#示例">示例</a></h3>
<p>TestVoidMethod.java 文件代码：</p>
<pre><code class="language-java">public class TestVoidMethod {
  public static void main(String[] args) {
    printGrade(78.5);
  }
 
  public static void printGrade(double score) {
    if (score &gt;= 90.0) {
       System.out.println('A');
    }
    else if (score &gt;= 80.0) {
       System.out.println('B');
    }
    else if (score &gt;= 70.0) {
       System.out.println('C');
    }
    else if (score &gt;= 60.0) {
       System.out.println('D');
    }
    else {
       System.out.println('F');
    }
  }
}
</code></pre>
<p>以上实例编译运行结果如下：</p>
<pre><code>C
</code></pre>
<p>这里printGrade方法是一个void类型方法，它不返回值。</p>
<p>一个void方法的调用一定是一个语句。 所以，它被在main方法第三行以语句形式调用。就像任何以分号结束的语句一样。</p>
<h2 id="通过值传递参数"><a class="header" href="#通过值传递参数">通过值传递参数</a></h2>
<p>调用一个方法时候需要提供参数，你必须按照参数列表指定的顺序提供。</p>
<p>例如，下面的方法连续n次打印一个消息：</p>
<p>TestVoidMethod.java 文件代码：</p>
<pre><code class="language-java">public static void nPrintln(String message, int n) {
  for (int i = 0; i &lt; n; i++) {
    System.out.println(message);
  }
}
</code></pre>
<h3 id="示例-1"><a class="header" href="#示例-1">示例</a></h3>
<p>下面的例子演示按值传递的效果。</p>
<p>该程序创建一个方法，该方法用于交换两个变量。</p>
<p>TestPassByValue.java 文件代码：</p>
<pre><code class="language-java">public class TestPassByValue {
  public static void main(String[] args) {
    int num1 = 1;
    int num2 = 2;
 
    System.out.println(&quot;交换前 num1 的值为：&quot; +
                        num1 + &quot; ，num2 的值为：&quot; + num2);
 
    // 调用swap方法
    swap(num1, num2);
    System.out.println(&quot;交换后 num1 的值为：&quot; +
                       num1 + &quot; ，num2 的值为：&quot; + num2);
  }
  /** 交换两个变量的方法 */
  public static void swap(int n1, int n2) {
    System.out.println(&quot;\t进入 swap 方法&quot;);
    System.out.println(&quot;\t\t交换前 n1 的值为：&quot; + n1
                         + &quot;，n2 的值：&quot; + n2);
    // 交换 n1 与 n2的值
    int temp = n1;
    n1 = n2;
    n2 = temp;
 
    System.out.println(&quot;\t\t交换后 n1 的值为 &quot; + n1
                         + &quot;，n2 的值：&quot; + n2);
  }
}
</code></pre>
<p>以上实例编译运行结果如下：</p>
<pre><code>交换前 num1 的值为：1 ，num2 的值为：2
    进入 swap 方法
        交换前 n1 的值为：1，n2 的值：2
        交换后 n1 的值为 2，n2 的值：1
交换后 num1 的值为：1 ，num2 的值为：2
</code></pre>
<p>传递两个参数调用swap方法。有趣的是，方法被调用后，实参的值并没有改变。</p>
<h1 id="方法重载"><a class="header" href="#方法重载">方法重载</a></h1>
<p>方法重载：同一个类中方法名字相同，而形式参数不同</p>
<p>原理：编译器逐个匹配</p>
<p>原则：</p>
<ul>
<li>方法名必须相同</li>
<li>参数列表必须不同，如个数不同，类型不同，参数排列顺序不同等</li>
<li>方法的返回类型可以相同也可以不同</li>
<li>仅仅返回类型不同不足以成为方法重载</li>
</ul>
<p>上面使用的max方法仅仅适用于int型数据。但如果你想得到两个浮点类型数据的最大值呢？</p>
<p>解决方法是创建另一个有相同名字但参数不同的方法，如下面代码所示：</p>
<pre><code class="language-java">public static double max(double num1, double num2) {  if (num1 &gt; num2)    return num1;  else    return num2; }
</code></pre>
<p>如果你调用max方法时传递的是int型参数，则 int型参数的max方法就会被调用；</p>
<p>如果传递的是double型参数，则double类型的max方法体会被调用，这叫做方法重载；</p>
<p>就是说一个类的两个方法拥有相同的名字，但是有不同的参数列表。</p>
<p>Java编译器根据方法签名判断哪个方法应该被调用。</p>
<p>方法重载可以让程序更清晰易读。执行密切相关任务的方法应该使用相同的名字。</p>
<p>重载的方法必须拥有不同的参数列表。你不能仅仅依据修饰符或者返回类型的不同来重载方法。</p>
<h1 id="变量作用域"><a class="header" href="#变量作用域">变量作用域</a></h1>
<p>变量的范围是程序中该变量可以被引用的部分。</p>
<p>方法内定义的变量被称为局部变量。</p>
<p>局部变量的作用范围从声明开始，直到包含它的块结束。</p>
<p>局部变量必须声明才可以使用。</p>
<p>方法的参数范围涵盖整个方法。参数实际上是一个局部变量。</p>
<p>for循环的初始化部分声明的变量，其作用范围在整个循环。</p>
<p>但循环体内声明的变量其适用范围是从它声明到循环体结束。它包含如下所示的变量声明：</p>
<p><img src="https://www.runoob.com/wp-content/uploads/2013/12/12-130Q1221013F0.jpg" alt="img" /></p>
<p>你可以在一个方法里，不同的非嵌套块中多次声明一个具有相同的名称局部变量，但你不能在嵌套块内两次声明局部变量。</p>
<h1 id="命令行传参"><a class="header" href="#命令行传参">命令行传参</a></h1>
<p>程序运行时再传参如Demo2.java</p>
<pre><code class="language-java">package method;

public class Demo2 {
    public static void main(String[] args) {
        //args.length数组长度
        for (int i = 0; i &lt; args.length; i++) {
            System.out.println(&quot;args[&quot;+i+&quot;]: &quot;+args[i]);
        }
    }
}
</code></pre>
<p>执行命令行</p>
<pre><code class="language-shell">javac Demo2.java

java method.Demo2 this is RM
</code></pre>
<p>输出结果：</p>
<pre><code class="language-txt">args[0命令行]: this
args[1]: is
args[2]: RM
</code></pre>
<h2 id="构造方法"><a class="header" href="#构造方法">构造方法</a></h2>
<p>当一个对象被创建时候，构造方法用来初始化该对象。构造方法和它所在类的名字相同，但构造方法没有返回值。</p>
<p>通常会使用构造方法给一个类的实例变量赋初值，或者执行其它必要的步骤来创建一个完整的对象。</p>
<p>不管你是否自定义构造方法，所有的类都有构造方法，因为 Java 自动提供了一个默认构造方法，默认构造方法的访问修饰符和类的访问修饰符相同(类为 public，构造函数也为 public；类改为 protected，构造函数也改为 protected)。</p>
<p>一旦你定义了自己的构造方法，默认构造方法就会失效。</p>
<h3 id="实例-2"><a class="header" href="#实例-2">实例</a></h3>
<p>下面是一个使用构造方法的例子：</p>
<pre><code class="language-java">// 一个简单的构造函数
class MyClass {
  int x;
 
  // 以下是构造函数
  MyClass() {
    x = 10;
  }
}
</code></pre>
<p>你可以像下面这样调用构造方法来初始化一个对象：</p>
<p>ConsDemo.java 文件代码：</p>
<pre><code class="language-java">public class ConsDemo {
   public static void main(String args[]) {
      MyClass t1 = new MyClass();
      MyClass t2 = new MyClass();
      System.out.println(t1.x + &quot; &quot; + t2.x);
   }
}
</code></pre>
<p>大多时候需要一个有参数的构造方法。</p>
<h3 id="实例-3"><a class="header" href="#实例-3">实例</a></h3>
<p>下面是一个使用构造方法的例子：</p>
<pre><code class="language-java">// 一个简单的构造函数
class MyClass {
  int x;
 
  // 以下是构造函数
  MyClass(int i ) {
    x = i;
  }
}
</code></pre>
<p>你可以像下面这样调用构造方法来初始化一个对象：</p>
<p>ConsDemo.java 文件代码：</p>
<pre><code class="language-java">public class ConsDemo {
  public static void main(String args[]) {
    MyClass t1 = new MyClass( 10 );
    MyClass t2 = new MyClass( 20 );
    System.out.println(t1.x + &quot; &quot; + t2.x);
  }
}
</code></pre>
<p>运行结果如下：</p>
<pre><code>10 20
</code></pre>
<h1 id="可变参数"><a class="header" href="#可变参数">可变参数</a></h1>
<p>JDK 1.5 开始，Java支持传递同类型的可变参数给一个方法。</p>
<p>方法的可变参数的声明如下所示：</p>
<p><code>typeName... parameterName</code></p>
<p>在方法声明中，在指定参数类型后加一个省略号(...) 。</p>
<p>一个方法中只能指定一个可变参数，它必须是方法的最后一个参数。任何普通的参数必须在它之前声明。</p>
<h3 id="实例-4"><a class="header" href="#实例-4">实例</a></h3>
<p>Demo3.java</p>
<pre><code class="language-java">package method;

public class Demo3 {
    public static void main(String[] args) {
        Demo3 demo3 = new Demo3();
        demo3.test(1,2,3,4,5);
    }
    public void test(int... i){
        System.out.println(i[0]);
    }
}
</code></pre>
<p>输出结果为1</p>
<p>VarargsDemo.java 文件代码：</p>
<pre><code class="language-java">public class VarargsDemo {
    public static void main(String args[]) {
        // 调用可变参数的方法
        printMax(34, 3, 3, 2, 56.5);
        printMax(new double[]{1, 2, 3});
    }
 
    public static void printMax( double... numbers) {
        if (numbers.length == 0) {
            System.out.println(&quot;No argument passed&quot;);
            return;
        }
 
        double result = numbers[0];
 
        for (int i = 1; i &lt;  numbers.length; i++){
            if (numbers[i] &gt;  result) {
                result = numbers[i];
            }
        }
        System.out.println(&quot;The max value is &quot; + result);
    }
}
</code></pre>
<p>以上实例编译运行结果如下：</p>
<pre><code>The max value is 56.5
The max value is 3.0
</code></pre>
<h1 id="递归"><a class="header" href="#递归">递归</a></h1>
<p>必须有终止条件！！！</p>
<pre><code class="language-java">package method;

public class Demo4 {
    public static void main(String[] args) {
        Demo4 demo4 = new Demo4();

        int num = 5;
        int result = demo4.factorial(num);
        System.out.println(result);
    }
    public int factorial(int i){
        if(i==0){
            return 1;
        }else {
            return factorial(i-1)*i;
        }

    }
}
</code></pre>
<p>输出结果120</p>
<h2 id="finalize-方法"><a class="header" href="#finalize-方法">finalize() 方法</a></h2>
<p>Java 允许定义这样的方法，它在对象被垃圾收集器析构(回收)之前调用，这个方法叫做 finalize( )，它用来清除回收对象。</p>
<p>例如，你可以使用 finalize() 来确保一个对象打开的文件被关闭了。</p>
<p>在 finalize() 方法里，你必须指定在对象销毁时候要执行的操作。</p>
<p>finalize() 一般格式是：</p>
<pre><code class="language-java">protected void finalize()
{
   // 在这里终结代码
}
</code></pre>
<p>关键字 protected 是一个限定符，它确保 finalize() 方法不会被该类以外的代码调用。</p>
<p>当然，Java 的内存回收可以由 JVM 来自动完成。如果你手动使用，则可以使用上面的方法。</p>
<h3 id="实例-5"><a class="header" href="#实例-5">实例</a></h3>
<p>FinalizationDemo.java 文件代码：</p>
<pre><code class="language-java">public class FinalizationDemo {  
  public static void main(String[] args) {  
    Cake c1 = new Cake(1);  
    Cake c2 = new Cake(2);  
    Cake c3 = new Cake(3);  
      
    c2 = c3 = null;  
    System.gc(); //调用Java垃圾收集器
  }  
}  
 
class Cake extends Object {  
  private int id;  
  public Cake(int id) {  
    this.id = id;  
    System.out.println(&quot;Cake Object &quot; + id + &quot;is created&quot;);  
  }  
    
  protected void finalize() throws java.lang.Throwable {  
    super.finalize();  
    System.out.println(&quot;Cake Object &quot; + id + &quot;is disposed&quot;);  
  }  
}
</code></pre>
<p>运行以上代码，输出结果如下：</p>
<pre><code>$ javac FinalizationDemo.java 
$ java FinalizationDemo
Cake Object 1is created
Cake Object 2is created
Cake Object 3is created
Cake Object 3is disposed
Cake Object 2is disposed
</code></pre>
<h3 id="stringbuilder类"><a class="header" href="#stringbuilder类">StringBuilder类</a></h3>
<p>1.借助StringBuilder类中的方法屏蔽手机号中间四位数字，如输入手机号”13796105569”,输出示例如下：</p>
<p><img src="https://i.imgtg.com/2022/11/10/tWwai.png" alt="t1.png" /></p>
<p>代码:</p>
<pre><code class="language-java">import java.util.Scanner;
public class Quiz {
public static void main(String[] args) {

	System.out.println(&quot;请输入手机号&quot;);

    Scanner input=new Scanner(System.in);

    String str=input.nextLine(); //获取键盘输入的字符串
	
	StringBuilder sb = new StringBuilder(str);
	
	sb.replace(3,7,&quot;****&quot;);//从0计数，左取，右不取

    System.out.println(sb);
}

}
</code></pre>
<h3 id="静态方法无法调用自己定义的非静态方法"><a class="header" href="#静态方法无法调用自己定义的非静态方法">静态方法无法调用自己定义的非静态方法</a></h3>
<pre><code class="language-java">public class DoSum{

            public static void main(String[] args) {

                   int a = 23;

                   int b = 52;

                  int c = sum(a, b);//省略static的话调用报错 error: non-static method sum(int,int) cannot be referenced from a static context即静态方法无法调用自己定义的非静态方法

//解决方法之一是改变非静态方法为静态方法，在sum方法中的int前加static
                System.out.println(&quot;The sum is: &quot; + c);
          }

           public static int sum(int a, int b) {

                  return a + b;

           }

  }
</code></pre>
<h3 id="递归实践"><a class="header" href="#递归实践">递归实践</a></h3>
<p>1.（编程题）分别使用递归方式计算斐波那契数列的前n项。如果计算前24项并输出，每行输出6个数字，程序的运行效果如下。
<img src="https://i.imgtg.com/2022/11/10/tbMNX.png" alt="t2.png" />
请完成计算该数列的前30项的功能并输出</p>
<pre><code class="language-java">public class BC1 {

 public static void main(String[] args) {

 System.out.println(&quot;使用递归方法计算斐波那契数列&quot;);

 int[] r1 = func(30);//计算斐波那契数列的前30项

 display(r1,6);//输出数组r1，每行输出6个元素

 }

 

 static int[] func(int n) {// 递归方法获取斐波那契数列的前n项

 int[] nums = new int[n];

 for (int i = 0; i &lt; n; i++) {

 nums[i] = f(i + 1);

 }

 return nums;

 }



 static int f(int k) { // 用递归方式求斐波那契数列第k项的值

 if(k==1||k==2){
	return 1; 
 }else{
	 return f(k-1)+f(k-2);
 }

 }





 static void display(int[] values,int m) {// 输出一个数组中的所有元素，每行输出m个元素

for(int j=1;j&lt;=values.length;j++){
	System.out.print(values[j-1]+&quot;\t&quot;);
	if(j%6==0){
		System.out.println();
	}
}

 }

}

</code></pre>
<p>2.以下程序完成奇数的累加和功能，计算1到不大于n的所有奇数的和。请将sum方法补充完整，要求使用递归方式实现累加和。</p>
<pre><code class="language-java">public class RecursiveMethods {

	public static void main(String[] args) {

		System.out.println(sum(6)); 

	}

	

	static int sum(int n) {//使用递归方法求解从1开始到不大于n的所有奇数的累加和

		if(n&lt;=0) {

			System.out.println(&quot;不合法的n&quot;);

			return 0;

		}
		
		if(n==1){
		return 1;	
		}
		else if(n&gt;1&amp;&amp;n%2==1){
			
			return n+sum(n-2);
		}
		else{
		return sum(n-1);	
		}
	//if....else语句不完整报错：Missing return statement	
	
	}

}

</code></pre>
<p>3.（编程题）编程实现二分查找法，在一个从大到小排列的有序数组中查找指定的元素。实现以下步骤：（1）假设数组长度是30，数组中的元素是1到100之间的整数，数组中的元素随机生成。（2）将数组中的元素从大到小排序。 （3）要查找的目标数值是45，若找到该数值，返回下标（如果有多个目标数值，任意返回一个对应的下标即可）；否则返回-1。程序的某两次输出结果示意图如下：</p>
<p><img src="https://i.imgtg.com/2022/11/10/tbOEt.png" alt="t3.png" /></p>
<p><img src="https://i.imgtg.com/2022/11/10/tbaIx.png" alt="t4.png" /></p>
<pre><code class="language-java">public class BinarySearch {

public static void main(String[] args) {

int n=30;

int[] d=new int[n];

for(int i=0;i&lt;n;i++) {

d[i]=(int)(1+Math.random()*100); //随机生成1~100的整数

}

System.out.print(&quot;随机生成的数组：&quot;);

printArray(d);


arraySort(d);

System.out.print(&quot;从大到小排序后的数组：&quot;);

printArray(d);


int target=45;

int p=binarySearch(d,target,0,d.length-1);

if(p==-1) {

System.out.println(&quot;没有找到目标值&quot;+target);

}

else {

System.out.printf(&quot;目标值%d的下标是%d&quot;,target,p);

}

}


static void printArray(int[] data) { //打印数组

              for(int i=0;i&lt;data.length;i++){
				System.out.print(data[i]+&quot;\t&quot;);  
			  }

}


static void arraySort(int[] data) { //数组排序，从大到小

for(int i=0;i&lt;data.length;i++){
	
	for(int j=i+1;j&lt;data.length;j++){
	
		if(data[i]&lt;data[j]){
		
			int temp = data[j];
			data[j]=data[i];
			data[i]=temp;
		}
	}
}

}


//递归方式实现二分查找

public static int binarySearch(int[] data, int target, int beginIndex, int endIndex) {


	if(target&gt;data[beginIndex]||target&lt;data[endIndex]){
	
		return -1;
	}
    //没有异常处理机制容易stackoverflow
	int middle =  beginIndex+(endIndex-beginIndex)/2;
	if(data[middle]&gt;target){
		return binarySearch(data,target,middle+1,endIndex);
	}
	else if(data[middle]&lt;target){
		return binarySearch(data,target,beginIndex,middle-1);
	}
	else{
		return middle;
	}

}



}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="java文件读写"><a class="header" href="#java文件读写">java文件读写</a></h1>
<ul>
<li><a href="%E6%96%87%E4%BB%B6%E7%90%86%E8%AE%BA.html#%E7%BC%96%E7%A8%8B%E9%A2%98">编程题</a></li>
</ul>
<p>1.FileWriter类的某个构造方法声明如下：</p>
<p>public FileWriter(String name, boolean append) throws FileNotFoundException</p>
<p>其中参数append的值为true时表示在原文件的尾部添加数据。</p>
<p>2.下列程序实现的功能是往文件Alphabets.dat中写入从a开始的10个字母，下列代码执行后，文件Alphabets.dat的大小是20字节。</p>
<pre><code class="language-java">import java.io.*;

public class FileSize{
	
	 public static void main(String[] args) {
		 
		 File file = new File(&quot;Alphabets.dat&quot;);
		 
		 try(DataOutputStream dos = new DataOutputStream(new BufferedOutputStream(new FileOutputStream(file)))){
			 for(int i=0;i&lt;10;i++){
				 dos.writeChar((char)('a'+i));//写入一个char类型数据，占2字节
			 }
			 
		 }catch(IOException e){
			
			 e.printStackTrace();
		 }
		 
	 }
	
	
}
	
</code></pre>
<h3 id="编程题"><a class="header" href="#编程题">编程题</a></h3>
<p>1.抄写并修改课堂案例（写入文本文件（方式2）），完成以下功能：将歌词内容保存到当前目录下的文本文件jinglebells.txt；读取jinglebells.txt中的内容，将前三行输出到控制台。 </p>
<pre><code class="language-java">import java.io.*;


public class SaveSong {

public static void main(String[] args) {

String[] contents = { 

&quot;jingle bells, jingle bells,&quot;,

&quot;jingle all the way!&quot;,

&quot;oh what fun it is to ride&quot;,

&quot;in a one-horse open sleigh.&quot;

};

File file = new File(&quot;jinglebells.txt&quot;);

try(PrintWriter pw = new PrintWriter(new BufferedWriter(new FileWriter(file)))) {
	for(int i = 0; i &lt; contents.length; i++) {
	pw.println(contents[i]);//向文件中写入一行

}

}catch(IOException e) {

e.printStackTrace();

}


try(BufferedReader bufferedfr = new BufferedReader(new FileReader(file))) {

String s = null;//用于存储一行内容

int i=0;

while((s=bufferedfr.readLine())!=null &amp;&amp; i++&lt;3) {// 逐行读取，最多读3次

System.out.println(s);//输出当前行的内容

}

}catch(IOException e) {

e.printStackTrace();

}
}


}

</code></pre>
<p>2.（程序填空题）下面程序的功能是从键盘输入一个小于100的数字，计算并输出从该整数到100之间能被7整除的整数的累加和。</p>
<pre><code class="language-java">import java.util.Scanner;

public class Sum {

 public static void main(String[] args) {

 System.out.println(&quot;请输入一个小于100的整数：&quot;);

 Scanner input = new Scanner(System.in);

 int num = input.nextInt();

 if (num &gt;= 100) {

 System.out.println(&quot;输入的数已超出范围&quot;);

 } else {

int sum=0;

 for (int i = num; i &lt;= 100; i++) {

 if (i%7==0) {

 sum += i;

 }

 }

 System.out.println(&quot;和是&quot; + sum);

 }

 }

}

</code></pre>
<p>3.（程序填空题）以下程序将热点新闻写入文本文件news.txt中，每行写一条新闻。格式如下图所示。</p>
<p><img src="https://p.ananas.chaoxing.com/star3/origin/57995e0b9959592cba9c8f4c3c9c9b18.png" alt="r" /></p>
<pre><code class="language-java">import java.io.*;


public class FileOperation {

 public static void main(String[] args) {

 String[] news = { &quot;香港将禁止所有英国载客航班抵港&quot;, &quot;朴槿惠所在拘留所发生疫情&quot;, &quot;中国新冠疫苗首针将于1月15日接种&quot; };

 File file = new File(&quot;news.txt&quot;);

try(PrintWriter pw = new PrintWriter(new BufferedWriter(new FileWriter(file)))) {

 for (int i = 0; i &lt; news.length; i++) {

 pw.println(i+1+&quot;:&quot;+news[i]);

 }

 } catch (Exception e) {

 e.printStackTrace();

 }

 }

}
</code></pre>
<p>4.（编程题）下列程序完成计算加权成绩并保存成绩到文件的功能，请把下面的程序补充完整。</p>
<p><img src="https://p.ananas.chaoxing.com/star3/origin/d639f2b19f8ce14cb85e1d491ec37122.png" alt="i" /></p>
<pre><code class="language-java">import java.io.BufferedOutputStream;

import java.io.BufferedWriter;

import java.io.DataOutputStream;

import java.io.File;

import java.io.FileOutputStream;

import java.io.FileWriter;

import java.io.IOException;

import java.io.PrintWriter;



public class SaveData {



public static void main(String[] args) {

// 数组scores记录学生成绩，每行表示一名学生，每列表示一名学生各门课程的成绩

double[][] scores = { { 80, 90, 60 }, { 99, 86.5, 93 }, { 80, 76, 79 } };



// 每门成绩的权重

double[] w = { 0.6, 0.2, 0.2 };



// 数组weightedScores记录学生成绩，每行表示一名学生，除最后一列表示一名学生各门课程的成绩，最后一列表示该学生的加权成绩。

double[][] weightedScores = computeWeightedScores(scores, w);



// 将数组数据按照写入文本文件，每行写入一名同学的成绩，数值之间用逗号隔开。

writeToTextFile(weightedScores, &quot;scores.txt&quot;);



// 将数组数据按照写入二进制文件，数值之间无需分割，无需换行。

writeToTextFile(weightedScores, &quot;scores.dat&quot;);

}



static double[][] computeWeightedScores(double[][] scores, double[] w) {

                    //请将方法体补充完整，填入第1空
   //        for(int i=0;i&lt;3;i++){
			 
		//	   for(int j=0;j&lt;3;j++){
				 
			//	   weightedScores[i][j]=scores[i][j]+w[i];
			  // }
			   
		   //}
		   double[][] weightedScores = new double[scores.length][scores[0].length + 1];

		   for (int i = 0; i &lt; scores.length; i++) {

		   double s = 0;

 		   for (int j = 0; j &lt; scores[i].length; j++) {

		  weightedScores[i][j] = scores[i][j];

   		  s += scores[i][j] * w[j]; // 计算加权成绩

}

		  weightedScores[i][scores[i].length] = s;

}

          return weightedScores;





}



static void writeToTextFile(double[][] data, String fname) {

         File file = new File(fname);

		try (PrintWriter pw = new PrintWriter(new BufferedWriter(new FileWriter(file)))) {

		for (int i = 0; i &lt; data.length; i++) {

		String str = &quot;&quot; + data[i][0];

		for (int j = 1; j &lt; data[i].length; j++) {

		str += &quot;,&quot; + data[i][j]; // 使用逗号分隔数据

}

	pw.println(str);

}

} catch (IOException e) {

	e.printStackTrace();

}

}



static void writeToBinaryFile(double[][] data, String fname) {

         File file = new File(fname);

		try (DataOutputStream dos = new DataOutputStream(new BufferedOutputStream(new FileOutputStream(file)))) {

		for (int i = 0; i &lt; data.length; i++) {

		for (int j = 0; j &lt; data[i].length; j++) {

		dos.writeDouble(data[i][j]);

}

}

} catch (IOException e) {

		e.printStackTrace();

}

}

}

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="面向对象理论"><a class="header" href="#面向对象理论">面向对象理论</a></h1>
<pre><code>* [区分类和对象](#区分类和对象)
</code></pre>
<ul>
<li><a href="%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%90%86%E8%AE%BA.html#%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8">方法调用</a>
<ul>
<li><a href="%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%90%86%E8%AE%BA.html#%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E5%8F%AF%E4%BB%A5%E7%9B%B4%E6%8E%A5%E8%B0%83%E7%94%A8">静态方法可以直接调用</a></li>
<li><a href="%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%90%86%E8%AE%BA.html#%E9%9D%9E%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E9%9C%80%E8%A6%81%E5%85%88%E5%AE%9E%E4%BE%8B%E5%8C%96%E5%AF%B9%E8%B1%A1">非静态方法需要先实例化对象</a></li>
<li><a href="%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%90%86%E8%AE%BA.html#%E5%80%BC%E4%BC%A0%E9%80%92">值传递</a></li>
</ul>
</li>
<li><a href="%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%90%86%E8%AE%BA.html#%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA">类与对象的创建</a></li>
<li><a href="%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%90%86%E8%AE%BA.html#%E6%9E%84%E9%80%A0%E5%99%A8%E8%AF%A6%E8%A7%A3">构造器详解</a>
<ul>
<li><a href="%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%90%86%E8%AE%BA.html#%E6%97%A0%E5%8F%82%E6%9E%84%E9%80%A0">无参构造</a></li>
<li><a href="%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%90%86%E8%AE%BA.html#%E6%9C%89%E5%8F%82%E6%9E%84%E9%80%A0">有参构造</a></li>
</ul>
</li>
<li><a href="%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%90%86%E8%AE%BA.html#%E4%B8%89%E5%A4%A7%E5%B1%9E%E6%80%A7">三大属性</a>
<ul>
<li><a href="%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%90%86%E8%AE%BA.html#%E5%B0%81%E8%A3%85">封装</a></li>
<li><a href="%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%90%86%E8%AE%BA.html#%E7%BB%A7%E6%89%BF">继承</a>
<ul>
<li><a href="%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%90%86%E8%AE%BA.html#super%E8%AF%A6%E8%A7%A3">Super详解</a></li>
<li><a href="%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%90%86%E8%AE%BA.html#%E6%96%B9%E6%B3%95%E9%87%8D%E5%86%99">方法重写</a></li>
</ul>
</li>
<li><a href="%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%90%86%E8%AE%BA.html#%E5%A4%9A%E6%80%81">多态</a>
<ul>
<li><a href="%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%90%86%E8%AE%BA.html#instanceof%E5%92%8C%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2">Instanceof和类型转换</a>
<ul>
<li><a href="%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%90%86%E8%AE%BA.html#%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2">类型转换</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%90%86%E8%AE%BA.html#static%E5%85%B3%E9%94%AE%E5%AD%97">Static关键字</a>
<ul>
<li><a href="%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%90%86%E8%AE%BA.html#%E9%9D%99%E6%80%81%E5%AF%BC%E5%85%A5%E5%8C%85">静态导入包</a></li>
</ul>
</li>
<li><a href="%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%90%86%E8%AE%BA.html#%E6%8A%BD%E8%B1%A1%E7%B1%BB">抽象类</a></li>
<li><a href="%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%90%86%E8%AE%BA.html#%E6%8E%A5%E5%8F%A3">接口</a></li>
<li><a href="%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%90%86%E8%AE%BA.html#n%E7%A7%8D%E5%86%85%E9%83%A8%E7%B1%BB">N种内部类</a>
<ul>
<li><a href="%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%90%86%E8%AE%BA.html#%E7%89%B9%E6%AE%8A%E5%86%85%E9%83%A8%E7%B1%BB">特殊内部类</a></li>
<li><a href="%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%90%86%E8%AE%BA.html#%E6%88%90%E5%91%98%E5%86%85%E9%83%A8%E7%B1%BB">成员内部类</a></li>
<li><a href="%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%90%86%E8%AE%BA.html#%E9%9D%99%E6%80%81%E5%86%85%E9%83%A8%E7%B1%BB">静态内部类</a></li>
<li><a href="%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%90%86%E8%AE%BA.html#%E5%B1%80%E9%83%A8%E5%86%85%E9%83%A8%E7%B1%BB">局部内部类</a></li>
<li><a href="%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%90%86%E8%AE%BA.html#%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB">匿名内部类</a></li>
</ul>
</li>
<li><a href="%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%90%86%E8%AE%BA.html#java%E5%A4%9A%E6%80%81%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB">java多态和抽象类</a>
<ul>
<li><a href="%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%90%86%E8%AE%BA.html#%E5%8C%85%E4%B9%8B%E9%97%B4%E7%9A%84%E4%BA%92%E7%9B%B8%E8%B0%83%E7%94%A8ide%E5%8F%AF%E8%A1%8C%E4%BD%86terminal%E4%B8%8D%E8%A1%8C%E4%B8%8D%E7%9F%A5%E5%8E%9F%E5%9B%A0">包之间的互相调用（ide可行但terminal不行，不知原因）</a></li>
<li><a href="%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%90%86%E8%AE%BA.html#%E7%B1%BB%E7%9A%84%E5%BA%94%E7%94%A8%E5%AE%9E%E4%BE%8B">类的应用实例</a>
<ul>
<li><a href="%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%90%86%E8%AE%BA.html#%E6%B3%A8super%E7%9A%84%E4%B8%89%E7%A7%8D%E7%94%A8%E6%B3%95">注：super的三种用法</a></li>
<li><a href="%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%90%86%E8%AE%BA.html#%E6%B3%A8this%E7%9A%84%E4%B8%89%E7%A7%8D%E7%94%A8%E6%B3%95">注：this的三种用法</a></li>
<li><a href="%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%90%86%E8%AE%BA.html#%E4%B8%89%E7%A7%8D%E5%8F%98%E9%87%8F%E7%9A%84%E5%8C%BA%E5%88%AB">三种变量的区别</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<p>面向对象Object-Oriented Programming</p>
<p>本质：<strong>以类的方式组织代码，以对象的组织（封装）数据</strong></p>
<p>抽象</p>
<p>三大特性：封装、继承、多态</p>
<h3 id="区分类和对象"><a class="header" href="#区分类和对象">区分类和对象</a></h3>
<p>1.对象是实体，需要被创建，可以为我们做事情</p>
<p>如这只猫</p>
<ul>
<li>表达东西或事件</li>
<li>运行时响应消息（提供服务）</li>
</ul>
<p>对象=属性+服务</p>
<p>数据：属性或状态</p>
<p>操作：函数</p>
<p>封装：内数据外操作</p>
<p>2.类是规范，根据类的定义来创建对象</p>
<p>如猫</p>
<ul>
<li>定义所有猫的属性</li>
<li>就是java中的类型</li>
<li>可以用来定义变量</li>
</ul>
<p>例子：自动售货机</p>
<pre><code class="language-java">public class VendingMachine {
	
	
	int price=80;
	int balance;
	int total;
	//3个属性即类定义的对象中所具有的成员变量
	int f(){
		return 10;	
	}
	
	VendingMachine(){  //构造函数：成员函数名字和类的名字完全相同，在创建这个类的每一个对象的时候会自动调用这个函数，这个函数不能有返回类型
		total = 0;	
	}
	VendingMachine(int price){ 
        this();//调用另一个构造函数，只能在开头用一次
		this.price = price;	
	}
	
	void setPrice(int price){
		this.price = price;
		this.getFood();//在成员函数内部直接调用自己(this)的其他函数
	}
	
    
    void showPrompt(){
	      System.out.println(&quot;Welcome&quot;);	
	}
	
	void insertMoney(int amount){
		balance = balance+amount;
	}
	
	void showBalance(){
	      System.out.println(balance);	
	}
	void getFood(){
		if(balance&gt;=price){
			 System.out.println(&quot;Here you are.&quot;);	
			balance = balance-price;
			total=total+price;
		}
	}
	
	//四个动作
	
	
	public static void main(String[] args) {
		VendingMachine vm = new VendingMachine();//创建对象，对象变量是对象的管理者，不是所有者
		vm.showPrompt();
		vm.showBalance();
		vm.insertMoney(100);
		vm.getFood();
		vm.showBalance();
        
        VendingMachine vm1 = new VendingMachine(100);
		vm1.insertMoney(200);
		vm1.showBalance();
		vm1.getFood();
		vm1.showBalance();
	}
}

</code></pre>
<p>一个类可以有多个构造函数，只要它们的参数表不同。创造对象的时候给出不同的参数值，就会调用不同的构造函数，通过this()还可以调用其他构造函数，一个类里同名但参数表不同的函数构成<code>重载</code>关系。</p>
<pre><code class="language-java">Welcome
10
Here you are.
30
210
Here you are.
110
</code></pre>
<p>本地变量：定义在函数内部的变量，生存期与作用域都是函数内部</p>
<p>成员变量：类中定义的变量，成员变量的生存期是对象的生存期，作用域是类内部的成员函数</p>
<p>成员变量在定义的地方就可以给出初始值，没有给出初始值的成员变量会自动获得零值，对象变量的0值表示没有任何管理对象，也可以主动给null值</p>
<p>定义初始化可以调用函数，甚至可以使用已经定义的成员变量</p>
<h1 id="方法调用-1"><a class="header" href="#方法调用-1">方法调用</a></h1>
<p>带static的方法和类一起加载,而不带static的方法需要类实例化後才能加载</p>
<h2 id="静态方法可以直接调用"><a class="header" href="#静态方法可以直接调用">静态方法可以直接调用</a></h2>
<p>类名.方法()</p>
<pre><code class="language-java">package oop;

public class Student {
    public static void say() {
        System.out.println(&quot;学生说话了!!&quot;);
    }
}
</code></pre>
<pre><code class="language-java">package oop;

public class Demo2 {
    public static void main(String[] args) {
        Student.say();
    }
}
</code></pre>
<p>输出结果:</p>
<pre><code class="language-txt">学生说话了!!
</code></pre>
<h2 id="非静态方法需要先实例化对象"><a class="header" href="#非静态方法需要先实例化对象">非静态方法需要先实例化对象</a></h2>
<p>用new实例化这个类</p>
<pre><code class="language-java">package oop;

public class Student {
    public void say() {
        System.out.println(&quot;学生说话了!!&quot;);
    }
}
</code></pre>
<pre><code class="language-java">package oop;

public class Demo2 {
    public static void main(String[] args) {
        //对象类型 对象名 = 对象值
        Student student = new Student();
        student.say();
    }
}
</code></pre>
<p>输出结果:</p>
<pre><code class="language-txt">学生说话了!!
</code></pre>
<h2 id="值传递"><a class="header" href="#值传递">值传递</a></h2>
<pre><code class="language-java">package oop;

public class Demo3 {
    public static void main(String[] args) {
        int a = 1;
        System.out.println(a);
        Demo3.change(a);
        System.out.println(a);
    }
    //返回值为空
    public static void change(int a ){
        a = 10;
    }
}
</code></pre>
<p>输出结果为</p>
<pre><code class="language-txt">1
1
</code></pre>
<h1 id="类与对象的创建"><a class="header" href="#类与对象的创建">类与对象的创建</a></h1>
<p>面向对象Object-Oriented Programming</p>
<p>本质：<strong>以类的方式组织代码，以对象的组织（封装）数据</strong></p>
<pre><code class="language-java">package oop;

public class Student {
    //属性：字段
    String name;//模板，不能直接赋值
    int age;

    //方法
    public void study() {
        System.out.println(this.name+&quot;在学习!!&quot;);
    }
}
</code></pre>
<pre><code class="language-java">package oop;
//一个项目应该只存在一个main方法
public class Application {
    public static void main(String[] args) {
        //类是抽象的，需要实例化
        //类实例化後会返回一个自己的对象
        //student对象是Student类的一个具体实例
        Student student = new Student();
        System.out.println(student.name);
        student.name = &quot;小豹子&quot;;//需要用&quot;&quot;
        System.out.println(student.name);
    }
}
</code></pre>
<p>输出结果：</p>
<pre><code class="language-txt">null
小豹子
</code></pre>
<h1 id="构造器详解"><a class="header" href="#构造器详解">构造器详解</a></h1>
<p>使用new关键字创建和初始化对象，除了分配内存空间之外，还会给创建好的对象进行默认的初始化以及对类中构造器的调用。</p>
<p>类中的构造器也被成为构造方法，是在进行创建对象时侯必须要调用的，并且构造器具有以下两个特点：</p>
<ul>
<li>必须和类的名字相同</li>
<li>必须没有返回类型，也不能写void</li>
</ul>
<h3 id="无参构造"><a class="header" href="#无参构造">无参构造</a></h3>
<pre><code class="language-java">package oop;

public class Person {
    //一个类即使什么都不写，它也会存在一个方法
    //显式定义构造器
    String name;

    //实例化初始值
    //1.使用new关键字，本质上是调用构造器
    //2.用来初始化值
    public Person(){
        this.name = &quot;RM&quot;;

    }
}
</code></pre>
<pre><code class="language-java">package oop;
//一个项目应该只存在一个main方法
public class Application {
    public static void main(String[] args) {
        //new 实例化了一个对象
        Person person = new Person();
        System.out.println(person.name);
    }
}
</code></pre>
<p>输出RM</p>
<h3 id="有参构造"><a class="header" href="#有参构造">有参构造</a></h3>
<pre><code class="language-java">package oop;

public class Person {
    //一个类即使什么都不写，它也会存在一个方法
    //显式定义构造器
    String name;

    //实例化初始值
    //1.使用new关键字，本质上是调用构造器
    //2.用来初始化值
    public Person(){

    }
    //有参构造：一旦定义了有参构造，无参构造必须显式定义
    public Person(String name){
        this.name = name;//和上面的不同
    }
}

</code></pre>
<pre><code class="language-java">package oop;
//一个项目应该只存在一个main方法
public class Application {
    public static void main(String[] args) {
        //new 实例化了一个对象
        Person person = new Person(&quot;kuangshen&quot;);
        System.out.println(person.name);
    }
}
</code></pre>
<p>输出kuangshen</p>
<p>只有有参构造，而无无参构造，将会报错，要默认无参构造为空</p>
<p>快捷键Alt+Insert</p>
<pre><code class="language-txt">java: 无法将类 oop.Person中的构造器 Person应用到给定类型;
  需要: java.lang.String
  找到: 没有参数
  原因: 实际参数列表和形式参数列表长度不同
</code></pre>
<pre><code class="language-java">package oop;

public class Person {
    //一个类即使什么都不写，它也会存在一个方法
    //显式定义构造器
    String name;

    //实例化初始值
    //1.使用new关键字，本质上是调用构造器
    //2.用来初始化值
    
    //有参构造：一旦定义了有参构造，如果想使用无参构造，无参构造必须显式定义
    public Person(String name){
        this.name = name;
    }

}
</code></pre>
<pre><code class="language-java">package oop;
//一个项目应该只存在一个main方法
public class Application {
    public static void main(String[] args) {
        //new 实例化了一个对象
        Person person = new Person();
        System.out.println(person.name);
    }
}
</code></pre>
<h1 id="三大属性"><a class="header" href="#三大属性">三大属性</a></h1>
<h2 id="封装"><a class="header" href="#封装">封装</a></h2>
<p>追求高内聚，低耦合</p>
<p><strong>属性私有，get/set</strong></p>
<p>好处：</p>
<ul>
<li>提高程序的安全性，保护数据</li>
<li>隐藏代码的实现细节</li>
<li>提高系统的可维护性</li>
<li>统一接口</li>
</ul>
<p>IDEA中按右键选择generator，选中setter/getter，自动生成</p>
<pre><code class="language-java">package oop;

public class Student {
    //属性私有
    private String name;
    private int id;
    private char gender;
    //提供一些可以操作这个属性的方法
    //如提供一些get/set方法
    //get获得这个数据
    public String getName(){
        return this.name;
    }
    //set给这个属性设置值
    public void setName(String name){
        this.name=name;
    }
}
</code></pre>
<pre><code class="language-java">package oop;

//一个项目应该只存在一个main方法
public class Application {
    public static void main(String[] args) {

        Student student = new Student();
        student.setName(&quot;RM&quot;);
        System.out.println(student.getName());
    }
}
</code></pre>
<p>输出结果：RM</p>
<pre><code class="language-java">package oop;

public class Student {
    //属性私有
    private String name;
    private int id;
    private char gender;
    private int age;
    //提供一些可以操作这个属性的方法
    //如提供一些get/set方法
    //get获得这个数据
    public String getName(){
        return this.name;
    }
    //set给这个属性设置值
    public void setName(String name){
        this.name=name;
    }

    public int getId() {
        return id;
    }

    public void setId(int id) {
        this.id = id;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        //检查输入格式
        if(age&gt;120||age&lt;0){
            this.age = 3;
        }else{
            this.age = age;
        }
    }
}
</code></pre>
<pre><code class="language-java">package oop;

//一个项目应该只存在一个main方法
public class Application {
    public static void main(String[] args) {

        Student student = new Student();
        student.setName(&quot;RM&quot;);
        System.out.println(student.getName());
        student.setAge(999);
        System.out.println(student.getAge());
    }
}
</code></pre>
<p>输出结果：</p>
<pre><code class="language-txt">RM
3
</code></pre>
<h2 id="继承"><a class="header" href="#继承">继承</a></h2>
<p>本质是对某一批类的抽象，Java中类只有单继承，单继承意思是只有一个直接父类，ctrl+H查看继承关系</p>
<p>关键字extends</p>
<p>父类</p>
<pre><code class="language-java">package oop;

public class Person {
    public void say(){
        System.out.println(&quot;川普说话了！&quot;);
    }
}

</code></pre>
<p>子类：子类继承父类所有的public方法，在java中都默认直接或间接继承Object类</p>
<pre><code class="language-java">package oop;

public class Student extends Person {

}

</code></pre>
<pre><code class="language-java">package oop;

import oop.Student;

//一个项目应该只存在一个main方法
public class Application {
    public static void main(String[] args) {

        Student student = new Student();

        student.say();

    }
}
</code></pre>
<p>输出结果：</p>
<pre><code class="language-txt">川普说话了！
</code></pre>
<h3 id="super详解"><a class="header" href="#super详解">Super详解</a></h3>
<p>super注意点：</p>
<ul>
<li>super调用父类的构造方法，必须在构造方法的第一个</li>
<li>super必须只能出现在子类的方法或构造方法中</li>
<li>super和this不能同时调用构造方法</li>
</ul>
<p>super VS this：</p>
<ul>
<li>代表对象不同：this代表本身调用者这个对象，super代表父类对象的应用</li>
<li>使用前提不同：this没有继承也可以调用，super只有在继承条件下调用</li>
<li>构造方法不同：this()是本类的构造，而super()是父类的构造</li>
</ul>
<pre><code class="language-java">package oop;

public class Person {
    protected String name = &quot;kuangshen&quot;;
}
</code></pre>
<pre><code class="language-java">package oop;

public class Student extends Person {
    private  String name = &quot;RM&quot;;

    public void test(String name){
        System.out.println(name);//传入的参数如孔夫子
        System.out.println(this.name);//RM，Student类
        System.out.println(super.name);//kuangshen，父类Person
    }

}
</code></pre>
<pre><code class="language-java">package oop;

import oop.Student;

//一个项目应该只存在一个main方法
public class Application {
    public static void main(String[] args) {

        Student student = new Student();

        student.test(&quot;孔夫子&quot;);

    }
}
</code></pre>
<p>输出结果</p>
<pre><code class="language-txt">孔夫子
RM
kuangshen
</code></pre>
<pre><code class="language-java">package oop;

public class Person {
    protected String name = &quot;kuangshen&quot;;

    public void print(){
        System.out.println(&quot;Person&quot;);
    }
}
</code></pre>
<pre><code class="language-java">package oop;

public class Student extends Person {
    private  String name = &quot;RM&quot;;

    public void print(){
        System.out.println(&quot;Student&quot;);
    }

    public void test(){
        print();//Student
        this.print();//Student
        super.print();//Person
    }

}
</code></pre>
<pre><code class="language-java">package oop;

import oop.Student;

//一个项目应该只存在一个main方法
public class Application {
    public static void main(String[] args) {

        Student student = new Student();

        student.test();

    }
}
</code></pre>
<p>输出结果</p>
<pre><code class="language-txt">Student
Student
Person
</code></pre>
<pre><code class="language-java">package oop;

public class Person {

    public Person() {
        System.out.println(&quot;Person无参执行了！&quot;);
    }

    protected String name = &quot;kuangshen&quot;;

    public void print(){
        System.out.println(&quot;Person&quot;);
    }
}
</code></pre>
<pre><code class="language-java">package oop;

public class Student extends Person {

    public Student() {
        //这里存在隐藏代码super();，调用了父类的无参构造
        //super();//Call to 'super()' must be first statement in constructor body
        System.out.println(&quot;Student无参执行了！&quot;);
    }

    private  String name = &quot;RM&quot;;

    public void print(){
        System.out.println(&quot;Student&quot;);
    }

    public void test(){
        print();//Student
        this.print();//Student
        super.print();//Person
    }

}
</code></pre>
<pre><code class="language-java">package oop;

import oop.Student;

//一个项目应该只存在一个main方法
public class Application {
    public static void main(String[] args) {

        Student student = new Student();
    }
}
</code></pre>
<p>输出结果：</p>
<pre><code class="language-txt">Person无参执行了！
Student无参执行了！
</code></pre>
<h3 id="方法重写"><a class="header" href="#方法重写">方法重写</a></h3>
<p>快捷键ctrl+O</p>
<p>重写都是方法的重写，与属性无关。</p>
<p>重写：需要有继承关系，子类重写父类的<code>非静态</code>方法体，执行子类自己的方法！</p>
<ul>
<li>方法名必须相同</li>
<li>参数列表必须相同</li>
<li>修饰符：范围可以扩大，但不能缩小public&gt;protected&gt;default&gt;private</li>
<li>抛出的异常范围可以被缩小，但不能扩大：ClassNotFoundException - &gt; Exception（大）</li>
</ul>
<p>重写原因：父类的方法不一定满足子类的要求</p>
<p>静态方法</p>
<pre><code class="language-java">package oop;

public class B {
    public  static void test(){
        System.out.println(&quot;B=&gt;test&quot;);
    }
}
</code></pre>
<pre><code class="language-java">package oop;

public class A extends B{
    public static void test() {
        System.out.println(&quot;A=&gt;test&quot;);
    }
}
</code></pre>
<pre><code class="language-java">package oop;

public class Application {
    public static void main(String[] args) {

        //静态方法的调用只和左边即定义的数据类型有关
        A a = new A();
        a.test();//A

        //父类的引用指向了子类
        B b = new A();
        b.test();//B
    }
}
</code></pre>
<pre><code class="language-txt">A=&gt;test
B=&gt;test
</code></pre>
<p>非静态方法：重写Override</p>
<pre><code class="language-java">package oop;

public class B {
    public  void test(){
        System.out.println(&quot;B=&gt;test&quot;);
    }
}
</code></pre>
<pre><code class="language-java">package oop;

public class A extends B{
    @Override//重写@代表有功能的注释
    public void test() {
        //super.test();
        System.out.println(&quot;A=&gt;test&quot;);

    }
}
</code></pre>
<pre><code class="language-java">package oop;

public class Application {
    public static void main(String[] args) {

        A a = new A();
        a.test();//A

        B b = new A();
        b.test();//重写：需要有继承关系，子类重写父类的方法体，执行子类自己的方法！
    }
}
</code></pre>
<p>输出结果</p>
<pre><code class="language-txt">A=&gt;test
A=&gt;test//重写：需要有继承关系，子类重写父类的方法体，执行子类自己的方法！
</code></pre>
<p>静态属于类，含static、final、private的不能重写；非静态属于对象，可以重写（有static看左边，没有static看右边）</p>
<h2 id="多态"><a class="header" href="#多态">多态</a></h2>
<p>含义：同一个方法可以根据发送对象的不同而采用不同的行为方式</p>
<p>一个对象的实际类型是确定的，但能指向对象的引用类型可以不确定，父类的调用指向子类</p>
<p>要点：</p>
<ul>
<li>多态是方法的多态，不是属性的多态</li>
<li>父类和子类必须有联系</li>
<li>存在继承关系，方法需要重写（重写：需要有继承关系，子类重写父类、子类相同的方法的方法体，执行子类自己的方法，否则还执行父类的方法！），父类引用指向字类对象（如Father f1 = new Son();）</li>
</ul>
<p>父类类型的引用可以调用父类中定义的所有属性和方法，而对于子类中定义而父类中没有的方法，父类的引用是不能调用的。</p>
<p>同时，父类中的一个方法只有在在父类中定义而在子类中没有重写的情况下，才可以被父类类型的引用调用父类的方法。</p>
<p>对于父类中定义的方法，如果子类中重写了该方法，那么父类类型的引用将会调用子类中的这个方法，这就是动态连接。</p>
<pre><code class="language-java">//一个对象的实际类型是确定的
//但指向的引用类型可以不确定，父类的调用指向子类
Student s1 = new Student();
Person s2 = new Student();
Object s3 = new Student();
</code></pre>
<pre><code class="language-java">package oop;

public class Person {

    public void run(){
        System.out.println(&quot;Run&quot;);
    }
}
</code></pre>
<pre><code class="language-java">package oop;

public class Student extends Person {

    @Override
    public void run() {
        System.out.println(&quot;Son&quot;);
    }
    public void eat(){
        System.out.println(&quot;Eat&quot;);
    }
}
</code></pre>
<pre><code class="language-java">package oop;

public class Application {
    public static void main(String[] args) {

        //一个对象的实际类型是确定的，但能指向对象的引用类型可以不确定，父类的引用可以指向子类
        //子类Student能调用的方法都是自己的或是继承自父类Person的
        Student s1 = new Student();
        //Person是父类，可以指向子类，但不能调用子类独有的方法
        Person s2 = new Student();
        Object s3 = new Student();

        s1.run();//son原因：子类重写父类的方法体，执行子类自己的方法！
        s2.run();//son原因：子类重写父类的方法体，执行子类自己的方法！

        //对象能执行哪些方法，主要看对象左边类型，和右边的关系不大
        s1.eat();//s2.eat()报错
        }
}
</code></pre>
<p>输出结果：</p>
<pre><code class="language-txt">Son
Son
Eat
</code></pre>
<h3 id="instanceof和类型转换"><a class="header" href="#instanceof和类型转换">Instanceof和类型转换</a></h3>
<pre><code class="language-java">package oop;

public class Person {

    public void run(){
        System.out.println(&quot;Run&quot;);
    }
}
</code></pre>
<pre><code class="language-java">package oop;

public class Student extends Person {

    @Override
    public void run() {
        System.out.println(&quot;Son&quot;);
    }
    public void eat(){
        System.out.println(&quot;Eat&quot;);
    }
}
</code></pre>
<pre><code class="language-java">package oop;


public class Teacher extends Person{
    public static void main(String[] args) {

    }
}
</code></pre>
<pre><code class="language-java">package oop;

public class Application {
    public static void main(String[] args) {

        //Object&gt;Person&gt;Student
        //Object&gt;Person&gt;Teacher
        //Object&gt;String
        Object object = new Student();

        System.out.println(object instanceof Student);//true
        System.out.println(object instanceof Person);//true
        System.out.println(object instanceof Object);//true
        System.out.println(object instanceof Teacher);//false
        System.out.println(object instanceof String);//false

        System.out.println(&quot;=====================&quot;);

        Person person = new Student();

        System.out.println(person instanceof Student);//true
        System.out.println(person instanceof Person);//true
        System.out.println(person instanceof Object);//true
        System.out.println(person instanceof Teacher);//false
        //System.out.println(person instanceof String);//编译报错

        System.out.println(&quot;=====================&quot;);


        Student student = new Student();

        System.out.println(student instanceof Student);//true
        System.out.println(student instanceof Person);//true
        System.out.println(student instanceof Object);//true
        //System.out.println(student instanceof Teacher);//编译报错
        //System.out.println(student instanceof String);//编译报错

        }
}
</code></pre>
<h4 id="类型转换-1"><a class="header" href="#类型转换-1">类型转换</a></h4>
<p>要点：</p>
<ul>
<li>父类引用可以指向子类的对象</li>
<li>把子类转换为父类，向上转换</li>
<li>把父类转换为子类，向下转换：需强制</li>
<li>好处：方便调用方法，减少重复代码</li>
</ul>
<pre><code class="language-java">package oop;

public class Person {

    public void run(){
        System.out.println(&quot;run&quot;);
    }
}
</code></pre>
<pre><code class="language-java">package oop;

public class Student extends Person {

    public void go() {
        System.out.println(&quot;go&quot;);
    }
}
</code></pre>
<pre><code class="language-java">package oop;

public class Application {
    public static void main(String[] args) {

        //类型之间相互转化：父类（高类型）---&gt;子类（低类型）
        //高 ---&gt;低
        Person object = new Student();
        //object.go();//编译报错

        //student将这个对象转换为Student类型後才可以使用Student类型的方法
        Student student = (Student)object;
        student.go();
        //子类转换为父类，可能丢失一些固有的方法
        Student student1 = new Student();
        student1.go();
        Person person = student1;
        //person.go();//编译报错


        }
}
</code></pre>
<h1 id="static关键字"><a class="header" href="#static关键字">Static关键字</a></h1>
<pre><code class="language-java">package oop;

public class Student  {

    private static  int age;//静态变量或称为类变量，可以被所有实例共享
    private double score;//非静态变量
    
    public void go() {
        
        System.out.println(&quot;go&quot;);
    }

    public static void main(String[] args) {
        Student s1 = new Student();

        //类
        System.out.println(Student.age);
        //System.out.println(Student.score);//编译报错
        //对象
        System.out.println(s1.age);
        System.out.println(s1.score);
    }
}
</code></pre>
<pre><code class="language-java">package oop;

public class Student  {

    private static  int age;//静态变量或称为类变量，可以被所有实例共享
    private double score;//非静态变量
    
    public void run(){
        
    }

    public static void go() {

        System.out.println(&quot;go&quot;);
    }

    public static void main(String[] args) {
        go();
        //run();//Non-static method 'run()' cannot be referenced from a static context
    }
}
</code></pre>
<p><strong>静态方法只能调用静态方法，而非静态方法既可以调用非静态方法，也可以调用静态方法</strong></p>
<pre><code class="language-java">package oop;

public class Person {

    {
        System.out.println(&quot;匿名代码块&quot;);
    }
    
    static{
        System.out.println(&quot;静态代码块&quot;);
    }
    public Person(){
        System.out.println(&quot;构造方法&quot;);
    }

    public static void main(String[] args) {
        Person person = new Person();

    }
}
</code></pre>
<p>输出结果：</p>
<pre><code class="language-txt">静态代码块
匿名代码块
构造方法
</code></pre>
<pre><code class="language-java">package oop;

public class Person {

    {
        System.out.println(&quot;匿名代码块&quot;);//可以用来赋初值
    }
    static{
        System.out.println(&quot;静态代码块&quot;);//和类一起加载，第一个执行，且只执行一次
    }
    public Person(){
        System.out.println(&quot;构造方法&quot;);
    }

    public static void main(String[] args) {
        Person person1 = new Person();
        System.out.println(&quot;=====================&quot;);
        Person person2 = new Person();

    }
}
</code></pre>
<pre><code class="language-txt">静态代码块
匿名代码块
构造方法
=====================
匿名代码块
构造方法
</code></pre>
<h3 id="静态导入包"><a class="header" href="#静态导入包">静态导入包</a></h3>
<pre><code class="language-java">package method;

public class Calculator {
    public static void main(String[] args) {

        System.out.println(Math.random());
    }
}
</code></pre>
<pre><code class="language-java">package method;

import static  java.lang.Math.random;

public class Calculator {
    public static void main(String[] args) {

        System.out.println(random());
    }
}
</code></pre>
<h1 id="抽象类"><a class="header" href="#抽象类">抽象类</a></h1>
<p>Action.java</p>
<pre><code class="language-java">package oop;

//abstract 抽象类：类 extends只能单继承， 但接口可以多继承
public abstract class Action {
    //abstract，抽象方法，只有方法名字，没有方法的实现！
    public abstract void doSomething();

    //特点1：不能new抽象类，只能靠子类去实现它：约束！
    //特点2：抽象类中可以写普通的方法
    //特点3：抽象方法必须在抽象类中
    //抽象的抽象：约束～
    public static void main(String[] args) {
        System.out.println(&quot;有构造器吗？&quot;);
    }
}
</code></pre>
<p>Action.class</p>
<pre><code class="language-java">//
// Source code recreated from a .class file by IntelliJ IDEA
// (powered by FernFlower decompiler)
//

package oop;

public abstract class Action {
    public Action() {
    }

    public abstract void doSomething();

    public static void main(String[] args) {
        System.out.println(&quot;有构造器吗？&quot;);
    }
}
</code></pre>
<h1 id="接口"><a class="header" href="#接口">接口</a></h1>
<p>声明类的关键字是class，声明接口的关键字是interface</p>
<p>对比：</p>
<ul>
<li>普通类：只有具体实现</li>
<li>抽象类：具体实现和规范（抽象方法）都有</li>
<li>接口：只有规范，自己无法写方法</li>
</ul>
<p>接口就是规范。作用：</p>
<ul>
<li>约束</li>
<li>定义一些方法，让不同的人实现</li>
<li>public abstract 方法</li>
<li>public static final 变量=&gt;常量</li>
<li>接口不能被实例化，接口中没有构造方法</li>
<li>implements可以实现多个接口</li>
<li>必须重写接口中的方法</li>
</ul>
<pre><code class="language-java">package oop;

public interface UserService {

    //接口中所有定义都是抽象的，接口都要有实现类

    public abstract void add(String name);
    //编译报错Interface abstract methods cannot have body
    //Modifier 'public' is redundant for interface methods
    //Modifier 'abstract' is redundant for interface methods
    void delete(String name);
    void update(String name);
    void query(String name);


    public static final int age = 99;
    //Modifier 'public' is redundant for interface fields
    //Modifier 'static' is redundant for interface fields
    //Modifier 'final' is redundant for interface fields
}
</code></pre>
<pre><code class="language-java">package oop;

public interface TimeService {
    void timer();
}

</code></pre>
<pre><code class="language-java">package oop;

//抽象类：单继承
//类可以是实现接口，implements 接口
//实现了接口的类就需要重写接口中方法
//利用接口实现多继承
public class UserServiceImpl implements UserService,TimeService{
    @Override
    public void add(String name) {

    }

    @Override
    public void delete(String name) {

    }

    @Override
    public void update(String name) {

    }

    @Override
    public void query(String name) {

    }

    @Override
    public void timer() {

    }
}

</code></pre>
<h1 id="n种内部类"><a class="header" href="#n种内部类">N种内部类</a></h1>
<p>内部类就是在一个类的内部再定义一个类，比如A类中定义一个B类，则B类相对A类来说就是内部类，而A类相对B类来说就是外部类。</p>
<p>分类：</p>
<ul>
<li>成员内部类</li>
<li>静态内部类</li>
<li>局部内部类</li>
<li>匿名内部类</li>
</ul>
<h2 id="特殊内部类"><a class="header" href="#特殊内部类">特殊内部类</a></h2>
<p>双类</p>
<pre><code class="language-java">package oop;

public class Outer {

    }
}
//一个java类中可以有多个class类，但是只能有一个public class
class A{

    public static void main(String[] args) {
        
    }
}
</code></pre>
<h2 id="成员内部类"><a class="header" href="#成员内部类">成员内部类</a></h2>
<p>类中类，通过外部类调用内部类</p>
<pre><code class="language-java">package oop;

public class Outer {
    private int id;
    public void out(){
        System.out.println(&quot;这是外部类的方法&quot;);
    }
    public class Inner{
        public void in(){
            System.out.println(&quot;这是内部类的方法&quot;);
        }
    }
}
</code></pre>
<pre><code class="language-java">package oop;

public class Application{
    public static void main(String[] args) {
        Outer outer = new Outer();
        //通过这个外部类来实例化内部类
        Outer.Inner inner = outer.new Inner();
        inner.in();
    }
}
</code></pre>
<p>输出结果：</p>
<pre><code class="language-txt">这是内部类的方法
</code></pre>
<p>获得外部类的属性</p>
<pre><code class="language-java">package oop;

public class Outer {
    private int id = 10;
    public void out(){
        System.out.println(&quot;这是外部类的方法&quot;);
    }
    public class Inner{
        public void in(){
            System.out.println(&quot;这是内部类的方法&quot;);
        }
        //获得外部类的私有属性
        public void getID(){
            System.out.println(id);
        }
    }
    
}
</code></pre>
<pre><code class="language-java">package oop;

public class Application{
    public static void main(String[] args) {
        Outer outer = new Outer();
        //通过这个外部类来实例化内部类
        Outer.Inner inner = outer.new Inner();
        inner.getID();
    }
}
</code></pre>
<p>输出结果：10</p>
<h2 id="静态内部类"><a class="header" href="#静态内部类">静态内部类</a></h2>
<p>静态内部类无法调用外部非静态类属性</p>
<pre><code class="language-java">package oop;

public class Outer {
    private  int id = 10;
    public void out(){
        System.out.println(&quot;这是外部类的方法&quot;);
    }
    public static class Inner{
        public void in(){
            System.out.println(&quot;这是内部类的方法&quot;);
        }
        //获得外部类的私有属性
        public void getID(){
            System.out.println(id);//Non-static field 'id' cannot be referenced from a static context
        }
    }

}
</code></pre>
<pre><code class="language-java">package oop;

public class Outer {
    private static int id = 10;
    public void out(){
        System.out.println(&quot;这是外部类的方法&quot;);
    }
    public static class Inner{
        public void in(){
            System.out.println(&quot;这是内部类的方法&quot;);
        }
        //获得外部类的私有属性
        public void getID(){
            System.out.println(id);
        }
    }

}
</code></pre>
<h2 id="局部内部类"><a class="header" href="#局部内部类">局部内部类</a></h2>
<p>类中方法中类</p>
<pre><code class="language-java">package oop;

public class Outer {
    
    //局部内部类
    public void method(){
        class Inner{
            public void in(){
                
            }
        }

    }
}
</code></pre>
<h2 id="匿名内部类"><a class="header" href="#匿名内部类">匿名内部类</a></h2>
<pre><code class="language-java">package oop;

public class Test {
    public static void main(String[] args) {
        //没有名字初始化类
        new Apple().eat();
    }
    
}

class Apple{
    public void eat(){
        System.out.println(&quot;1&quot;);
    }
}

</code></pre>
<pre><code class="language-java">package oop;

public class Test {
    public static void main(String[] args) {
        //没有名字初始化类
        new Apple().eat();
    }
    UserService1 userservice1 = new UserService1(){
        @Override
        public void hello() {

        }
    } ;
}

class Apple{
    public void eat(){
        System.out.println(&quot;1&quot;);
    }
}
interface UserService1{
    void hello();
}
</code></pre>
<h1 id="java多态和抽象类"><a class="header" href="#java多态和抽象类">java多态和抽象类</a></h1>
<p>1.(填空题) （程序改错题）GC1.java文件中的程序有4个错误，请修改错误使程序能够正确运行，在错误行的末尾添加注释//******。
该文件中定义了一个接口Area，其中包含一个计算面积的方法CalculateArea(), MyCircle和MyRectangle类分别实现了这个接口，在GC1的main方法中创建了相应的对象并输出面积。</p>
<p>程序正确运行结果如下图所示：</p>
<p><img src="https://p.ananas.chaoxing.com/star3/origin/7b9c9e09d2953c9b3743f94c8f32cb7f.png" alt="r" /></p>
<pre><code class="language-java">public class GC1 {
	public static void main(String[] args) {
		MyCircle c = new MyCircle(2.0);
		System.out.println(&quot;圆面积:&quot; + c.CalculateArea());
		MyRectangle r = new MyRectangle(2.0, 3.0);
		System.out.println(&quot;矩形面积:&quot; + r.CalculateArea());//*******
	}
}

interface Area {
	public double CalculateArea();//错误写法public double CalculateArea(){};不知为何
}

class MyCircle implements Area {//******
	double r;

	public MyCircle(double r) {
		this.r = r;
	}

	public double CalculateArea() {
		return Math.PI * r * r;
	}
}

class MyRectangle implements Area {
	double width, height;

	public MyRectangle(double w, double h) {
		width = w;
		height = h;
	}

	public double CalculateArea() {
		return width * height;//******
	}
}
</code></pre>
<h3 id="包之间的互相调用ide可行但terminal不行不知原因"><a class="header" href="#包之间的互相调用ide可行但terminal不行不知原因">包之间的互相调用（ide可行但terminal不行，不知原因）</a></h3>
<p>2.（程序填空题）某同学编写的应用程序中包含两个类Person和Employee，分别属于两个包Firstpackage和Secondpackage。Employee继承Person类。创建两个包来组织源程序代码，包结构截图如下。请将下面的程序补充完整，依次粘贴缺失的代码。</p>
<p>Person.java</p>
<pre><code class="language-java">package Firstpackage;

public class Person {

 public String name;

 public Person(String name){

 this.name=name;

 }
	
public  void printInfo() {

 System.out.println(&quot;姓名：&quot;+this.name);

 } 

}
</code></pre>
<p>EmployeeManagement.java</p>
<pre><code class="language-java">package Secondpackage;

import Firstpackage.Person;



class EmployeeManagement {

 public static void main(String[] args) {

 Employee e=new Employee(&quot;Jack&quot;,6134.78);

 e.printInfo();

 }



}



class Employee extends Person{

 double salary;

 Employee(String name,double salary){

 super(name);

 this.salary=salary;

 }

 

public void printInfo() {

 System.out.println(&quot;姓名：&quot;+this.name+&quot; 工资：&quot;+this.salary);

 }

}
</code></pre>
<p>3.（程序填空题）下列程序中定义了抽象类Person和它的两个子类Worker和Student，分别创建Worker和Person的对象，显示两个对象的描述信息，程序的运行结果如下图所示。 </p>
<p><img src="https://p.ananas.chaoxing.com/star3/origin/07fd49c2e7f5f0ff7cfe9a51ab6c0c7e.png" alt="img" /></p>
<pre><code class="language-java">public class PersonManagement {

public static void main(String[] args) {

Person[] people=new Person[2];

people[0]= new Worker(&quot;老张&quot;,30000.0);

people[1]=new Student(&quot;小王&quot;,&quot;计算机&quot;);

for(int i=0;i&lt;people.length;i++) {

Person p=people[i];

System.out.println(p.getName()+&quot;,&quot;+p.getDescription());

}

}

}





abstract class Person{

private String name;

public Person(String n) {

name=n;

}


public  abstract String getDescription(); //抽象方法getDescription


public String getName() {

return name;

}

}

class Worker extends Person{

private double salary;

public Worker(String n, double s) {

super(n); //调用父类的构造方法给name赋值

salary=s;

}


public String getDescription() {

return &quot;工人，年薪是 &quot;+salary+&quot;元&quot;;

}

}



class Student extends Person{

private String major;

public Student(String n,String m) {

super(n);//不知到为什么这么写，为什么不写成name=super(n);

major=m;

}


public String getDescription() {

return &quot;学生，专业是&quot;+major;

}

}
</code></pre>
<p>4.（编程题）志愿者信息系统管理参与某大型博览会的志愿者的评分情况，并根据评分情况颁发相应的志愿者荣誉证书。每名志愿者的评分情况和线上、线下两部分工作时长有关。Volunteer类定义了四个成员变量（见程序中的注解），评价总分的计算方法如下：       线上工作时长*0.8+线下工作时长。总分20分（含）以上者获得“优秀志愿者”称号。各方法的功能见程序的注解。程序的某次运行结果如下图所示。</p>
<p><img src="https://p.ananas.chaoxing.com/star3/origin/857a1dd0164c5f4532cb1b41e76df40d.png" alt="r" /></p>
<pre><code class="language-java">import java.util.*;

class Volunteer

{

        private String name;    //志愿者姓名

        private int offlineHours;    //线下工作时长

        private int onlineHours;     //线上工作时长

        private double score;   //总分

        public Volunteer(String name,int offline,int online){//姓名，线下工作时长，线上工作时长

                 this.name=name;

                 this.onlineHours=online;         

                 this.offlineHours=offline;

                 this.score=0;//总分初始为0

        }

        public void calScore() {//没有返回值

          //在此处定义方法体（填入第1空）
          this.score =this.offlineHours+this.onlineHours*0.8;

          //计算线上与线下服务的综合得分（线上工作时长计分系数是0.8，线下工作时长计分系数是1.0），即评分=线上工作时长×0.8+线下工作时长,并写入成员变量score。

                

        }

        public void addScore(){//加上应急工作时长后的得分，应急工作时长随机产生，为0~9的整数，应急工作时长积分系数是1.2

         //在此处定义方法体（填入第2空）
		this.score+= 1.2*(int)(Math.random()*9);
                

        }

       

        public String toString() { //获取对象的相关信息

         //在此处定义方法体（填入第3空）

                return this.name+&quot;\t线上工作时长：&quot;+this.onlineHours+&quot;\t线下工作时长&quot;+this.offlineHours+&quot;总评分：&quot;+this.score;

        }

 

        public void Comare(Volunteer v1) {

                 if (this.score&gt;v1.score){

                         System.out.println(this.name+&quot;的评分较高&quot;);

                 }

                 else if (this.score&lt;v1.score) {

                         System.out.println(this.name+&quot;的评分较高&quot;);

                 }

                 else {

                         System.out.println(this.name+&quot;和&quot;+v1.name+&quot;的评分相同&quot;);

                 }

        }

       

        public void isExcellentVolunteer() {

         //在此处定义方法体（填入第4空）
		if(this.score&gt;=20){
		
			System.out.println(this.name+&quot;获得优秀志愿者称号&quot;);
		}else{
			
			System.out.println(this.name+&quot;暂未入选优秀志愿者称号&quot;);
			
		}
 

        }

}

 

public class BC2 {

 

        public static void main(String[] args) {

                 Volunteer v1=new Volunteer(&quot;小白鹭1号&quot;,10,15);

                 v1.calScore();

                 v1.addScore();

                 System.out.println(v1.toString());

                 v1.isExcellentVolunteer();

                 Volunteer v2=new Volunteer(&quot;小白鹭6号&quot;,5,5);

                 v2.calScore();

                 v2.addScore();

                 System.out.println(v2.toString());

                 v2.isExcellentVolunteer();

                 v1.Comare(v2);

        }

}
</code></pre>
<p>5.（程序填空题）星爸爸咖啡馆有一个订单管理应用程序，其中包含Order类，输出信息如图所示。将Order类补充完整，将完整代码依次填入相应的空中。</p>
<p><img src="https://p.ananas.chaoxing.com/star3/origin/3fc26dd1708b72b68fe6bb8d3bcd39d8.png" alt="r" /></p>
<pre><code class="language-java">public class TK2 {

 public static void main(String[] args) {

 Order o1, o2;

 o1 = new Order(2, 2);

 o2 = new Order(2, 1);

 o1.addCoffees(1);

 o2.addCakes(3);

 o1.addCoffees(1);

 o1.setIsPaid(true);

 o2.setIsPaid(false);

 System.out.println(o1.toString());

 System.out.println(o2.toString());

 }

}



class Order {

 private int numCoffees;

 private int numCakes; 

 private boolean isPaid;



 public Order(int nCoff, int nCakes) {

 numCoffees = nCoff;//传变量的方法，为什么这么传呢？？？

 numCakes = nCakes;

 }



 public void addCoffees(int numToAdd) {

numCoffees+=numToAdd;

 }



 public void addCakes(int numToAdd) {

 numCakes += numToAdd;

 }



 public void setIsPaid(boolean paid) {

isPaid=paid;//这点不会知道补啥

 }



 public int getTotal() {

 return numCoffees * 3 + numCakes * 4;

 }



 public String toString() {//这个通常有什么用呢？，好像是个函数

 String orderInfo = &quot;New Order: \n&quot;;

 orderInfo += numCoffees + &quot; Coffees $&quot; + numCoffees * 3 + &quot;\n&quot;;

 orderInfo += numCakes + &quot; Cakes $&quot; + numCakes * 4 + &quot;\n&quot;;

 orderInfo += &quot; Total $&quot; + getTotal() + &quot; &quot;;

 if (isPaid)

 orderInfo += &quot; has been paid \n&quot;;

 else

 orderInfo += &quot; not paid \n&quot;;
 return orderInfo;


 }

}
</code></pre>
<p>6.（编程题）声明抽象类Shape，有抽象成员方法area()和girth()。声明类Rectangle为Shape的子类，有两个成员变量width和height分别表示矩形的宽和高，实现继承自Shape的两个抽象方法，分别计算矩形的面积和周长。请编写Shape和Rectangle这两个类。周长计算公式：周长=2x(宽+高)。面积计算公式：面积=宽x高。</p>
<pre><code class="language-java">public class BC1 {

public static void main(String[] args) {

Rectangle r=new Rectangle(3.0,5.0);

System.out.println(&quot;周长是&quot;+r.girth());

}

}

abstract class Shape{
	
	abstract double area();
	abstract double girth();//抽象方法不能有主体,不能有{}
		
	}
	
class Rectangle extends Shape{
	
	double width;
	double height;
	
	//用构造方法传值
	Rectangle(double width, double height){
		
		this.width=width;
		this.height=height;
	}
	
	double area(){
		
		return width*height;
	}
	double girth(){//如果添加形式参数double width, double height会报错错误: Rectangle不是抽象的, 并且未覆盖Shape中的抽象方法girth()
		
		return 2*(width+height);
	}
	
}	

</code></pre>
<p>7.（程序填空题）以下是为新冠肺炎疫苗接种开发的一段程序，其中定义了一个抽象类Vaccine，包含成员变量和抽象成员方法vaccinate()；另外分别定义了Vaccine类的子类InactivatedVaccine和AdenovirusVectorVaccine，在主程序中生成对象并使用成员方法，程序正常运行时的输出界面如下图所示，请将程序补充完整。</p>
<p><img src="https://p.ananas.chaoxing.com/star3/origin/93e2321a638944fd76c8c7e09251cc58.png" alt="r" /></p>
<pre><code class="language-java">abstract class Vaccine{

    String manufacturer; //生产厂商

    int n=1; //接种次数

    abstract void vaccinate(); //定义vaccinate()成员方法
	//不能添加public，否则报错“正在尝试分配更低的访问权限; 以前为public”


}

 

class InactivatedVaccine extends Vaccine{//灭活疫苗

    public InactivatedVaccine(String name, int n) {//构造方法

        manufacturer=name;

        this.n=n;

    }

   

    public InactivatedVaccine(String name) {//构造方法

        this(name,2);

    }

 

    void vaccinate() {

        System.out.println(&quot;该灭活疫苗的生产厂商是&quot;+manufacturer+&quot;，接种剂次：&quot;+n);

    }

}

 

class AdenovirusVectorVaccine extends Vaccine{//腺病毒载体疫苗

    public AdenovirusVectorVaccine(String name) {//构造方法

        manufacturer=name;

    }

 

    void vaccinate() {

        System.out.println(&quot;该腺病毒载体疫苗的生产厂商是&quot;+manufacturer+&quot;，只需接种1剂。&quot;);

    }

}

 

public class TK2 {

    public static void main(String[] args) {

        InactivatedVaccine v1=new InactivatedVaccine(&quot;北京生物&quot;,2);

        v1.vaccinate();

        InactivatedVaccine v2=new InactivatedVaccine(&quot;科兴&quot;,2);

        v2.vaccinate();

        AdenovirusVectorVaccine v3=new AdenovirusVectorVaccine(&quot;康希诺&quot;);

        v3.vaccinate();

    }

}
</code></pre>
<h2 id="类的应用实例"><a class="header" href="#类的应用实例">类的应用实例</a></h2>
<p>1.（程序填空题）根据已知的程序段和已知的输出结果，将下列程序补充完整。请分别在第一、二、三个空中填写缺失的代码，在第四个空粘贴运行结果截图。输出结果：</p>
<p>Name: John Age: 2 ID: 445</p>
<p>Name: Fred Age: 4 ID: 447</p>
<p>Name: Elma Age: 6 ID: 449</p>
<p>完整代码：</p>
<pre><code class="language-java">public class UsePerson {

 public static void main(String[] args) {

 Person p1, p2, p3;

 //请将下面缺失的一行代码填入第一个空

Person.setID(444);
// 用setID方法给nextID赋初值，根据输出的p1的nextID分析出初值是多少。



 p1 = new Person(&quot;John&quot;); // p1赋初值

 p1.changeAge(2); // p1调用changeAge方法

 System.out.println(p1.toString()); // 输出p1的信息



 //请将下面缺失的三行代码填入第二个空
 p2 = new Person(&quot;Fred&quot;); // p1赋初值

 p2.changeAge(2); // p1调用changeAge方法

 System.out.println(p2.toString()); // 输出p1的信息



 //请将下面缺失的三行代码填入第三个空
 p3 = new Person(&quot;Elma&quot;); // p1赋初值

 p3.changeAge(2); // p1调用changeAge方法

 System.out.println(p3.toString()); // 输出p1的信息


 }

}



class Person {

 private static int age; // 注意age是static变量

 private String name;

 private static int nextID; // 注意nextID是static变量

 private int id;



 public Person(String s) {

 name = s;

 id = nextID;

 nextID++;

 }



 public void changeAge(int i) {

 age += i;

 id = nextID;

  nextID++;//第一个john的nextID没调用这块？？？？？？暂时还不知道原因

 }



 public static void setID(int i) {

 nextID = i;

 }



 public String toString() {

 return &quot;Name: &quot; + name + &quot; Age: &quot; + age + &quot; ID: &quot; + id;

 }

}
</code></pre>
<p>2.（程序填空题）程序中定义了一个类BikeSharing（共享单车），成员变量的说明详见程序中的注释，成员方法getDisPerday用于计算日均行驶里程（日均行驶里程=行驶里程/投放天数）；定义了BikeSharing类的子类Haluo，成员方法getDailyFee用于计算产生的骑行费用(骑行费用=骑行单价*行驶里程)。在TC2的main方法中创建了Haluo单车对象，调用成员方法输出它的日均骑行里程和日均骑行费用。程序正确运行结果如下图所示，请将程序补充完整。</p>
<p><img src="https://p.ananas.chaoxing.com/star3/origin/1159f70554e473724deb633c58ab6c9b.png" alt="img" /></p>
<pre><code class="language-java">class BikeSharing{

    String id;        //单车的序列号

    double distance;  //行驶里程(公里)

    int days;         //投放天数

    BikeSharing(String id,double dis,int d){

             this.id= id; //给成员变量id赋值

             distance=dis;     

             days=d;

    }

    public double getDisPerday() { //计算日均骑行里程

       return  distance/days;

    }

}

class Haluo extends BikeSharing{           

    double price;                  //每公里骑行单价

    Haluo(String id,double dis,int d){               

          super(id,dis,d);       

    }

public void setPrice(double price){ 

       this.price=price;

    }

    public double getDailyFee() {  //计算日均骑行费用

       return price*getDisPerday();       

    }

}

public class TC2 {

    public static void main(String[] args) {

       Haluo h=new Haluo(&quot;20210001&quot;,2251.2,402);    

       System.out.println(&quot;平均每天行驶里程:&quot;+ h.getDisPerday() +&quot;公里&quot;);

       h.setPrice(1.8);

       System.out.println(&quot;平均每天骑行费用:&quot;+h.getDailyFee()+&quot;元&quot;);

    }

}
</code></pre>
<p>super关键字用来访问父类内容，而this关键字用来访问本类内容</p>
<h4 id="注super的三种用法"><a class="header" href="#注super的三种用法">注：super的三种用法</a></h4>
<p>1.在子类的成员方法中访问父类的成员变量num如super.num</p>
<p>2.在子类的成员方法中访问父类的成员方法method如super.method();</p>
<p>3.在子类的构造方法中，访问父类的构造方法如super();</p>
<h4 id="注this的三种用法"><a class="header" href="#注this的三种用法">注：this的三种用法</a></h4>
<p>1.在本类的成员方法中访问本类的成员变量</p>
<p>2.在本类的成员方法中访问本类的另一个成员方法</p>
<p>3.在本类的构造方法中访问本类的另一个构造方法</p>
<ul>
<li>this(...)调用也必须是构造方法的第一个语句，唯一一个</li>
<li>super和this两种构造调用不能同时使用</li>
</ul>
<h4 id="三种变量的区别"><a class="header" href="#三种变量的区别">三种变量的区别</a></h4>
<pre><code class="language-java">class Father{
	int num = 30;
	
}



public class Son extends Father{
	
	int num = 20;
	
	public  Son(){
		this(123);//本类的无参构造调用本类的有参构造
		//this(n:123));错误写法报错需要)
		//this(n:1, m:2);这是错误用法call to this() must be first statement in constructor body
	}
	public Son(int n){
		
	}
	
	public Son(int n, int m){
		
	}
	
	public void showNum(){
		int num = 10;
		System.out.println(num);//局部变量
		System.out.println(this.num);//本类中的成员变量
		System.out.println(super.num);//父类中的成员变量
		
	}
	
	public void methodA(){
		System.out.println(&quot;AAA&quot;);
	}
	
	public void methodB(){
		this.methodA();//methodA();
		System.out.println(&quot;BBB&quot;);
	}
	
	
	
	
	public static void main(String[] args) {

       Son son=new Son();    

      son.showNum()
  //System.out.println(son.showNum());错误: 此处不允许使用 '空' 类型
     
      son.methodB();

    }
	
}

</code></pre>
<p>输出结果：</p>
<pre><code class="language-txt">10
20
30
AAA
BBB

</code></pre>
<p>3.(填空题, 20分)（编程题）根据鸢尾花的花瓣长度和宽度来判断它的类别。Iris类的成员变量和成员方法的说明见程序中的注释。已知两朵鸢尾花，第一朵花瓣长1.6cm，花瓣宽0.6cm，类别为&quot;山鸢尾&quot;，第二朵花瓣长5.8cm，花瓣宽3.1cm，类别为&quot;变色鸢尾&quot;；现要判断一朵新的鸢尾花类别，其方法如下：若它距离第一朵鸢尾花更近，则它的类别为&quot;山鸢尾&quot;，如果它距离第二朵鸢尾花更近，其类别就是&quot;变色鸢尾&quot;（如果距离相等，类别设置为&quot;山鸢尾&quot;）。两朵鸢尾花之间的距离计算公式如下：</p>
<p><img src="https://p.ananas.chaoxing.com/star3/origin/6912459a56fd6a8718e674cf97cc4cbd.png" alt="r" /></p>
<p>其中：plen1，pwid1分别为其中一朵鸢尾花的花瓣长度和花瓣宽度，plen2，pwid2为另一朵鸢尾花的花瓣长度和花瓣宽度。程序的运行结果如下图所示：</p>
<p><img src="https://p.ananas.chaoxing.com/star3/origin/bbf40b814edfc712fa791bc75e791638.png" alt="r" /></p>
<p>请将下面的代码补充完整。将缺少的代码依次填入每个空。（缺少的代码可能不止一行）</p>
<p>完整代码：</p>
<pre><code class="language-java">class Iris{

               private  double plen;  //花瓣长度

               private  double pwid;   //花瓣宽度

               private  String target;//鸢尾花的种类     

   

               public Iris(double plen,double pwid,String  target) {

                   this.plen=plen;
	           this.pwid=pwid;
		   this.target=target;

               }

               public Iris(double pl,double pw) {

                               this.plen=pl;

                               this.pwid=pw;

               }   

               public void setTarget(String t) {  //设置鸢尾花的类别

                             target=t;

               }

               public String  toString() {          //生成并返回对象的相关信息

                              String s=&quot;花瓣长：&quot;+plen+&quot; 花瓣宽：&quot;+pwid+&quot; &quot;+&quot; 类别是：&quot;+target;
                               return s; 

               }

               public double distance(Iris another) {//计算2朵鸢尾花之间的距离                                             

                 double distance=Math.sqrt(Math.pow((plen-another.plen),2)+Math.pow((pwid-another.pwid),2));
				   
                 return distance; 

               }

}

public class TC2 {

               static Iris iris1=new Iris(1.6,0.6,&quot;山鸢尾&quot;);

               static Iris iris2=new Iris(5.8,3.1,&quot;变色鸢尾&quot;);

              

               public  static String classify(Iris irisnew) {//判断irisnew的类别

                    if(irisnew.distance(iris1&lt;=irisnew.distance(iris2)){
								   return &quot;山鸢尾&quot;;
				    }else{
								   return  &quot;变色鸢尾&quot;;
							   }

               }

               public static void main(String args[]) {

                               Iris testSample1=new Iris(2.2,1.5);

                               testSample1.setTarget(classify(testSample1));

                               System.out.println(testSample1.toString());

                              

                               Iris testSample2=new Iris(6.0,2.9);

                               testSample2.setTarget(classify(testSample2));     

                               System.out.println(testSample2.toString());

               }

}
</code></pre>
<p>生成并返回对象的信息：</p>
<pre><code class="language-java">//类中
public String  toString() {          //生成并返回对象的相关信息

                              String s=&quot;花瓣长：&quot;+plen+&quot; 花瓣宽：&quot;+pwid+&quot; &quot;+&quot; 类别是：&quot;+target;
                               return s; 

               }
//主方法中
System.out.println(testSample2.toString());
</code></pre>
<p>4.(填空题, 15分)（程序改错题）下列程序完成学生成绩管理功能。请修改程序中出现的三处错误。Student类中定义了学生的姓名（name）、测验分数（testMark）和考试分数（examMark）。程序产生的正确输出如下图所示：</p>
<p><img src="https://p.ananas.chaoxing.com/star3/origin/b5cf899d7e95dd1e7d020c0438675187.png" alt="r" /></p>
<p>请在第一、二、三个空中填写错误代码的行号、修改后的代码、错误原因。格式：第n行，改为...(正确代码)，错误原因。</p>
<p>请在第四个空中上传修改后的源程序文件。</p>
<p>完整代码：</p>
<pre><code class="language-java">public class TestStudent {

 public static void main(String[] args) {

 // TODO 自动生成的方法存根

 Student student1;

 Student student2;

 student1 = new Student(&quot;张楠&quot;, 70, 85);

 student2 = new Student(&quot;李浩&quot;, 80, 90);

 student1.displayInfo();

 student2.displayInfo();

 student2.setExamMark(40);

 student2.compareTo(student1);

 }

}



class Student {

 private String name;

 private int testMark;

 private int examMark;



 Student(String theName) {

 name = theName;

 }



 Student(String theName, int test, int exam) {

 name = theName;

 testMark = test;

 examMark = exam;

 }



 public void setExamMark(int exam) {

 examMark = exam;

 System.out.println(name + &quot;\'s exam mark changed to &quot; + examMark);

 }



 public int getTestMark() {

 return testMark;

 }



 public void displayInfo() {

     System.out.println(name + &quot; got &quot; + testMark + &quot; in the test and &quot; + examMark + &quot; in the exam&quot;);

   }



 public void compareTo(Student other) { //方法的形参必须指定数据类型，根据方法体中使用other的可知，other是一个Student类型对象。

     if (examMark &gt; other.examMark) 

       System.out.println(name + &quot; did better than &quot; + other.name);

     else

       System.out.println(name + &quot; did worse than &quot; + other.name);

   }

 }
</code></pre>
<p>5.(填空题, 15分)（编程题）创建Melon类，包含初始值为0的静态变量totalNum、私有实例变量weight。编写Melon类的内容，完成以下功能： </p>
<p>每当创建一个新的Melon对象，totalNum增加1。</p>
<p>为Melon类编写实例方法void reduce(){}，每次调用reduce方法，totalNum的值减少1。为私有实例变量weight声明一对访问器方法，分别是int getWeight(){ }和void setWeight(int w){ }，实现对私有实例变量weight的读取和修改，编写这两个方法的方法体。</p>
<p>测试Melon的功能。创建公共类TestMelon，包含main方法，在main方法中完成下面的功能测试。依次创建四个Melon对象m1、m2、m3、m4后，输出totalNum的值。依次调用m1和m2的reduce方法后，输出totalNum的值。</p>
<p>调用m3的访问器方法设置私有成员变量weight的值为10，然后获取weight的值并输出。 要求将Melon类和公共类TestMelon放在同一个源程序文件TestMelon.java中。</p>
<p>请将编写好的源程序截图粘贴到第1个空，源代码文件TestMelon.java以附件形式上传到第2个空，将运行结果截图粘贴第3个空中。</p>
<p>完整代码：</p>
<pre><code class="language-java">public class TestMelon{
	
	public static void main(String[] args) {
		Melon m1 = new Melon();
		Melon m2 = new Melon();
		Melon m3 = new Melon();
		Melon m4 = new Melon();
		
		System.out.println(Melon.totalNum);//不能写totalNum
		
		m1.reduce();//错误写法reduce(m1);
		m2.reduce();
		
		System.out.println(Melon.totalNum);
		
		m3.setWeight(10);
		
		System.out.println(m3.getWeight());
	}
	
}
class Melon{

	static int  totalNum;
	private int weight;
	//每当创建一个新的Melon对象，totalNum增加1。
	Melon(){
		totalNum++;
		}
	//为Melon类编写实例方法void reduce(){}，每次调用reduce方法，totalNum的值减少1。
	void reduce(){
		totalNum--;
	}
	
	void setWeight(int w){ 
		weight=w;
	}
	
	int getWeight(){
		return weight;
	}

}
</code></pre>
<p>6.(填空题, 15分)（编程题）学校图书馆需要设计一个图书信息系统来管理藏书。假设一个简单的图书信息系统需要完成书籍、输出书籍信息、比较书籍的功能。请创建两个类Book和TestBook完成上述功能，输出结果如下：</p>
<p><img src="https://p.ananas.chaoxing.com/star3/origin/8fc1043509126b67819ec4c2d93962fb.png" alt="img" /> </p>
<p>编程要求：创建两个类Book和TestBook，其中TestBook是主类。</p>
<p>Book的属性有书名、作者（假设只有一位作者）、出版年份，行为有打印图书信息、比较图书信息。</p>
<p>在Book类中声明实例变量记录各个属性信息，成员变量的名称分别是name、author、publishYear。</p>
<p>在Book类声明两个实例方法，一个实例方法的功能是打印图书信息；另一个实例方法的功能是比较两本图书，如果书名、作者和出版年份都一样，这两本书是同一本书。</p>
<p>第一个实例方法的方法头是 void display(){ //请添加方法体 }</p>
<p>第二个实例方法的方法头是boolean compareBook(Book another){ //请添加方法体 }</p>
<p>在Book类中用静态变量copyCounter记录书的数目。 </p>
<p>TestBook类中包含main方法，用于创建图书。</p>
<p>完整代码：</p>
<p>Book.java</p>
<pre><code class="language-java">public class Book{
	
	static int copyCounter=0;
	
	String name ;
	String author;
	int publishYear;
	
	Book(String n,String a, int y){//必须要有构造方法
	
		name=n;
		author=a;
		publishYear=y;
		
		copyCounter++;
	}
	
	void display(){
		System.out.print(&quot;《&quot;+name+&quot;》，&quot;);
		System.out.print(&quot;作者：&quot;+author+&quot;，&quot;);
		System.out.print(&quot;出版年份：&quot;+publishYear+'\n');
	}
	
	boolean compareBook(Book another){
		if(name.equals(another.name)&amp;&amp;author.equals(another.author)&amp;&amp;(publishYear==another.publishYear)){
		
			return true;
		}else{
		
			return false;
		}
	}
}
//可以简写为return name.equals(another.name)&amp;&amp;author.equals(another.author)&amp;&amp;(publishYear==another.publishYear
//字符串比较用equals()
</code></pre>
<p>BookTest.java</p>
<pre><code class="language-java">public class TestBook{
	
	public static void main(String[] args) {
		Book book1 = new Book(&quot;红楼梦&quot;,&quot;曹雪芹&quot;,1791);
		book1.display();
		Book book2 = new Book(&quot;边城&quot;,&quot;沈从文&quot;,1934);
		book2.display();
		
		String str = book1.compareBook(book2)?&quot;&quot;:&quot;不&quot;;
		
		System.out.println(&quot;这两本书&quot;+str+&quot;是同一本书&quot;);
		
		System.out.println(&quot;一共有&quot;+Book.copyCounter+&quot;本书&quot;);
	}
	
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="数据库理论"><a class="header" href="#数据库理论">数据库理论</a></h1>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
