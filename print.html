<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Java语言程序设计</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="前言.html">前言</a></li><li class="spacer"></li><li class="chapter-item expanded "><a href="Google编码风格.html"><strong aria-hidden="true">1.</strong> Google编码风格</a></li><li class="chapter-item expanded "><a href="数据类型理论.html"><strong aria-hidden="true">2.</strong> 数据类型</a></li><li class="chapter-item expanded "><a href="运算符.html"><strong aria-hidden="true">3.</strong> 运算符</a></li><li class="chapter-item expanded "><a href="程序流程控制.html"><strong aria-hidden="true">4.</strong> 程序流程控制</a></li><li class="chapter-item expanded "><a href="数组.html"><strong aria-hidden="true">5.</strong> 数组</a></li><li class="chapter-item expanded "><a href="异常处理理论.html"><strong aria-hidden="true">6.</strong> 异常处理</a></li><li class="chapter-item expanded "><a href="函数理论.html"><strong aria-hidden="true">7.</strong> 函数</a></li><li class="chapter-item expanded "><a href="文件理论.html"><strong aria-hidden="true">8.</strong> 文件</a></li><li class="chapter-item expanded "><a href="面向对象理论.html"><strong aria-hidden="true">9.</strong> 面向对象</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Java语言程序设计</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="window10安装jdk21并配置eclipse"><a class="header" href="#window10安装jdk21并配置eclipse">Window10安装jdk21并配置Eclipse</a></h1>
<ul>
<li><a href="%E5%89%8D%E8%A8%80.html#jdk%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE">JDK环境配置</a></li>
<li><a href="%E5%89%8D%E8%A8%80.html#%E7%94%A8eclipse%E5%86%99hello-world">用eclipse写hello world</a></li>
</ul>
<p><a href="https://blog.csdn.net/weixin_50455331/article/details/126083021">JDK的环境配置（超详细教程）</a></p>
<p><a href="https://blog.csdn.net/weixin_50455331/article/details/126324741">eclipse下载与安装（汉化教程）超详细</a></p>
<p><a href="https://blog.csdn.net/qq_46110497/article/details/124607392">eclipse工具栏图标太小了，这样修改</a></p>
<p><a href="https://cloud.tencent.com/developer/article/1795246">Eclipse 小技巧之设置 Java 代码自动提示和补全设置</a></p>
<h2 id="jdk环境配置"><a class="header" href="#jdk环境配置">JDK环境配置</a></h2>
<p>JDK环境配置是JDK安装过程中最为重要的内容，大多数初学者安装JDK最大的问题就是出在环境配置上面，所以这里我以windows 10为例，分享一下JDK环境配置的过程。</p>
<p>（PS：以下环境配置的标点符号是在英文状态下的）</p>
<p>1.点击 我的电脑 ——&gt; 右键 ——&gt; 选择属性 ，跳出如下图所示（windows 10系统），点击“高级系统设置”。或者 控制面板——&gt;系统和安全——&gt;系统   也可以找到“高级系统设置”。</p>
<p>2.跳出如下图所示内容，点击“系统环境变量”，</p>
<p>3.点击环境变量后，跳出如下图所示对话框，第一步点击 “新建”，随后跳出 “新建系统变量” 对话框，一般来说系统变量中是没有JAVA_HOME的，所以我们在弹出的“新建系统变量”对话框中的“变量名”填入 ：JAVA_HOME ，“变量值 ”填入 ：C:\Program Files\Java\jdk-12.0.1（安装Java时jdk 所在的文件夹，   默认安装都是在C盘的）。如果已经存在JAVA_HOME的，那么就在它的变量值的最后面加上分号（即；），然后再将 jdk 的路径添加在这个分号的后面。</p>
<p>注意：JAVA_HOME的变量值一定要进入到 jdk 所在的目录，然后再复制这个路径放进去。</p>
<p>4.新建变量名：CLASSPATH，变量值：.;%JAVA_HOME%\lib\dt.jar;%JAVA_HOME%\lib\tools.jar （注意前面的  .;  也要放进去）如下图：</p>
<p>注意：如果已经存在CLASSPATH，则在它的最前面或者最后面添加变量值，如果在最前面添加，应该先添加一个分号（即；），然后再在分号前面添加 .;%JAVA_HOME%\lib\dt.jar;%JAVA_HOME%\lib\tools.jar （ .; 也要放进去）；如果在最后面添加，应该先添加一个分号（即；），然后再在分号后面添加  .;%JAVA_HOME%\lib\dt.jar;%JAVA_HOME%\lib\tools.jar （ .; 也要放进去）。</p>
<p>5.打开Path，点击新建按钮，添加变量值：%JAVA_HOME%\bin;%JAVA_HOME%\jre\bin（注意：从分号分开作为两行）。</p>
<p>注意：在window 10系统中，配置JDK环境变量时，如果不将 Path 的 变量值：%JAVA_HOME%\bin;%JAVA_HOME%\jre\bin 进行如下图这样配置，不分开两行，则会出错。但是如果你的系统是window 7的话，则可以不分开。</p>
<p>6.记得点击两次确定，如下图：</p>
<p>三. 验证JDK环境是否配置成功。</p>
<p>1.按住Window+R ，输入cmd，如下图：</p>
<p>2.回车，在cmd命令行分别输入java和javac（可以不区分大小写） ，出现如下图所示的画面而不是“javac不是内部变量……”即表示安装成功。</p>
<h2 id="用eclipse写hello-world"><a class="header" href="#用eclipse写hello-world">用eclipse写hello world</a></h2>
<p>1.新建一个Java project（Java项目）文件</p>
<p>选择File→new→java project</p>
<p>如果找不到java project ,可以先找到project…</p>
<p>然后在里面找到java project</p>
<p><img src="https://img-blog.csdnimg.cn/f492027ea5f9408fbfcab94d12c3cc31.png#pic_center" alt="a" /></p>
<p>2.在Project name（项目名称）里填入 Helloworld，然后点击finish （完成）会生成一个项目</p>
<p><img src="https://img-blog.csdnimg.cn/03ce6d3995b64b78b93d5332fc584cb0.png#pic_center" alt="a" /></p>
<p><img src="https://img-blog.csdnimg.cn/4237772d1a6e484f81e0e3e6fb7702a1.png#pic_center" alt="a" /></p>
<p>3.创建完项目后，右键Helloworld→new→Package（包），然后点击Finish会在Helloworld文件下生成一个包</p>
<p><img src="https://img-blog.csdnimg.cn/c9299c03023a450ea3c445c0035d5a1b.png#pic_center" alt="a" /></p>
<p><img src="https://img-blog.csdnimg.cn/f87db52076f34b58825d098d63893c4c.png#pic_center" alt="a" /></p>
<p>4.右键hello包（新生成的包）hello→new→Class (类)，新建一个类</p>
<p><img src="https://img-blog.csdnimg.cn/40b5a0cd4a5b47b085179d77f378b744.png#pic_center" alt="a" /></p>
<p>5.在生成的代码中的第七行填上下面这句代码：注意缩进</p>
<p><code>System.out.println("hello world")</code></p>
<p><img src="https://img-blog.csdnimg.cn/a32ea550651e4a9c96477f9d5a7d1bbe.png#pic_center" alt="a" /></p>
<p>6.点击运行之后会弹出一个新的窗口，点击OK</p>
<p><img src="https://img-blog.csdnimg.cn/0d3e4c3241ed4491aed820b13861da2d.png#pic_center" alt="a" /></p>
<p>底部控制台出现hello world 则表示运行成功</p>
<p><img src="https://img-blog.csdnimg.cn/7ef0afd6553445bca289ace49dbd0ed5.png#pic_center" alt="a" /></p>
<p>如果运行没有出任何问题的话，那么恭喜你，eclipse已经配置成功了。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="google编码风格"><a class="header" href="#google编码风格">Google编码风格</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="数据类型"><a class="header" href="#数据类型">数据类型</a></h1>
<ul>
<li><a href="%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%90%86%E8%AE%BA.html#%E5%86%85%E7%BD%AE%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B">内置数据类型</a>
<ul>
<li><a href="%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%90%86%E8%AE%BA.html#%E6%95%B0%E5%80%BC%E7%B1%BB%E5%9E%8B%E5%8F%96%E5%80%BC%E8%8C%83%E5%9B%B4">数值类型取值范围</a></li>
<li><a href="%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%90%86%E8%AE%BA.html#%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2">进制转换</a></li>
<li><a href="%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%90%86%E8%AE%BA.html#%E7%B1%BB%E5%9E%8B%E9%BB%98%E8%AE%A4%E5%80%BC">类型默认值</a></li>
</ul>
</li>
<li><a href="%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%90%86%E8%AE%BA.html#%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B">引用类型</a></li>
<li><a href="%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%90%86%E8%AE%BA.html#%E5%B8%B8%E9%87%8F">常量</a></li>
<li><a href="%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%90%86%E8%AE%BA.html#%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2">类型转换</a>
<ul>
<li><a href="%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%90%86%E8%AE%BA.html#%E8%87%AA%E5%8A%A8%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2">自动类型转换</a></li>
<li><a href="%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%90%86%E8%AE%BA.html#%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2">强制类型转换</a></li>
<li><a href="%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%90%86%E8%AE%BA.html#%E9%9A%90%E5%90%AB%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2">隐含强制类型转换</a></li>
</ul>
</li>
</ul>
<p>变量就是申请内存来存储值。也就是说，当创建变量的时候，需要在内存中申请空间。</p>
<p>内存管理系统根据变量的类型为变量分配存储空间，分配的空间只能用来储存该类型数据。</p>
<p>因此，通过定义不同类型的变量，可以在内存中储存整数、小数或者字符。</p>
<p>Java 有两大数据类型:</p>
<ul>
<li>内置数据类型</li>
<li>引用数据类型</li>
</ul>
<h2 id="内置数据类型"><a class="header" href="#内置数据类型">内置数据类型</a></h2>
<p>Java语言提供了八种基本类型。六种数字类型（四个整数型，两个浮点型），一种字符类型，还有一种布尔型。</p>
<p>其中long型数据的"L"理论上不分大小写，但是若写成"l"容易与数字"1"混淆，不容易分辩。所以最好大写。</p>
<p><strong>浮点数比较不能用<code>==</code>！！！例如8.1/3和2.7。</strong></p>
<p>浮点数定义时可以省略一部分内容，但不能省略小数点。</p>
<pre><code class="language-java">public class helloworld {
 
	public static void main(String[] args) {
		// TODO Auto-generated method stub
		float f1 = .0001f;
		float f2 = 1.0e-1f;
		double d = 1.;
		System.out.println(f1);
		System.out.println(f2);
		System.out.println(d);
	}
}
</code></pre>
<p>输出结果：</p>
<pre><code>1.0E-4
0.1
1.0
</code></pre>
<p><strong>字符型数据占16位</strong>。</p>
<pre><code class="language-java">public class helloworld {
 
	public static void main(String[] args) {
		// TODO Auto-generated method stub
		char c = 'b' + 1;
		System.out.println(c); //c
		System.out.println((int)c); //99
		System.out.println((char)38889); //韩
	}
}
</code></pre>
<p>在Java中不能使用0表示false，也不能使用非0的整数表示true。</p>
<h3 id="数值类型取值范围"><a class="header" href="#数值类型取值范围">数值类型取值范围</a></h3>
<p>float数据类型精度7位，double数据类型精度11位。</p>
<p>对于数值类型的基本类型的取值范围，我们无需强制去记忆，因为它们的值都已经以常量的形式定义在对应的包装类中了。请看下面的例子：</p>
<pre><code class="language-java">public class PrimitiveTypeTest {  
    public static void main(String[] args) {  
        // byte  
        System.out.println("基本类型：byte 二进制位数：" + Byte.SIZE);  
        System.out.println("包装类：java.lang.Byte");  
        System.out.println("最小值：Byte.MIN_VALUE=" + Byte.MIN_VALUE);  
        System.out.println("最大值：Byte.MAX_VALUE=" + Byte.MAX_VALUE);  
        System.out.println();  
  
        // short  
        System.out.println("基本类型：short 二进制位数：" + Short.SIZE);  
        System.out.println("包装类：java.lang.Short");  
        System.out.println("最小值：Short.MIN_VALUE=" + Short.MIN_VALUE);  
        System.out.println("最大值：Short.MAX_VALUE=" + Short.MAX_VALUE);  
        System.out.println();  
  
        // int  
        System.out.println("基本类型：int 二进制位数：" + Integer.SIZE);  
        System.out.println("包装类：java.lang.Integer");  
        System.out.println("最小值：Integer.MIN_VALUE=" + Integer.MIN_VALUE);  
        System.out.println("最大值：Integer.MAX_VALUE=" + Integer.MAX_VALUE);  
        System.out.println();  
  
        // long  
        System.out.println("基本类型：long 二进制位数：" + Long.SIZE);  
        System.out.println("包装类：java.lang.Long");  
        System.out.println("最小值：Long.MIN_VALUE=" + Long.MIN_VALUE);  
        System.out.println("最大值：Long.MAX_VALUE=" + Long.MAX_VALUE);  
        System.out.println();  
  
        // float  
        System.out.println("基本类型：float 二进制位数：" + Float.SIZE);  
        System.out.println("包装类：java.lang.Float");  
        System.out.println("最小值：Float.MIN_VALUE=" + Float.MIN_VALUE);  
        System.out.println("最大值：Float.MAX_VALUE=" + Float.MAX_VALUE);  
        System.out.println();  
  
        // double  
        System.out.println("基本类型：double 二进制位数：" + Double.SIZE);  
        System.out.println("包装类：java.lang.Double");  
        System.out.println("最小值：Double.MIN_VALUE=" + Double.MIN_VALUE);  
        System.out.println("最大值：Double.MAX_VALUE=" + Double.MAX_VALUE);  
        System.out.println();  
  
        // char  
        System.out.println("基本类型：char 二进制位数：" + Character.SIZE);  
        System.out.println("包装类：java.lang.Character");  
        // 以数值形式而不是字符形式将Character.MIN_VALUE输出到控制台  
        System.out.println("最小值：Character.MIN_VALUE="  
                + (int) Character.MIN_VALUE);  
        // 以数值形式而不是字符形式将Character.MAX_VALUE输出到控制台  
        System.out.println("最大值：Character.MAX_VALUE="  
                + (int) Character.MAX_VALUE);  
    }  
}
</code></pre>
<p>编译以上代码输出结果如下所示：</p>
<pre><code>基本类型：byte 二进制位数：8
包装类：java.lang.Byte
最小值：Byte.MIN_VALUE=-128
最大值：Byte.MAX_VALUE=127

基本类型：short 二进制位数：16
包装类：java.lang.Short
最小值：Short.MIN_VALUE=-32768
最大值：Short.MAX_VALUE=32767

基本类型：int 二进制位数：32
包装类：java.lang.Integer
最小值：Integer.MIN_VALUE=-2147483648
最大值：Integer.MAX_VALUE=2147483647

基本类型：long 二进制位数：64
包装类：java.lang.Long
最小值：Long.MIN_VALUE=-9223372036854775808
最大值：Long.MAX_VALUE=9223372036854775807

基本类型：float 二进制位数：32
包装类：java.lang.Float
最小值：Float.MIN_VALUE=1.4E-45
最大值：Float.MAX_VALUE=3.4028235E38

基本类型：double 二进制位数：64
包装类：java.lang.Double
最小值：Double.MIN_VALUE=4.9E-324
最大值：Double.MAX_VALUE=1.7976931348623157E308

基本类型：char 二进制位数：16
包装类：java.lang.Character
最小值：Character.MIN_VALUE=0
最大值：Character.MAX_VALUE=65535
</code></pre>
<p>float和double的最小值和最大值都是以科学记数法的形式输出的，结尾的"E+数字"表示E之前的数字要乘以10的多少次方。比如3.14E3就是3.14 × 10^3 =3140，3.14E-3 就是 3.14x10^{-3} =0.00314。</p>
<p>实际上，JAVA中还存在另外一种基本类型 void，它也有对应的包装类 java.lang.Void，不过我们无法直接对它们进行操作。</p>
<h3 id="进制转换"><a class="header" href="#进制转换">进制转换</a></h3>
<pre><code class="language-java">public class helloworld {
 
	public static void main(String[] args) {
		// TODO Auto-generated method stub
		int num1 = 0b1010;
		int num2 = 01010;
		int num3 = 1010;
		int num4 = 0x1010;
		char c = '漢';
		
		System.out.println("num1 = " + num1);
		System.out.println("num2 = " + num2);
		System.out.println("num3 = " + num3);
		System.out.println("num4 = " + num4);
		System.out.println("漢的utf-8编码为： " + (int)c);
	}
}
</code></pre>
<p>输出结果如下：</p>
<pre><code>num1 = 10
num2 = 520
num3 = 1010
num4 = 4112
漢的utf-8编码为： 28450
</code></pre>
<h3 id="类型默认值"><a class="header" href="#类型默认值">类型默认值</a></h3>
<p>下表列出了 Java 各个类型的默认值：</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left"><strong>数据类型</strong></th><th style="text-align: left"><strong>默认值</strong></th></tr></thead><tbody>
<tr><td style="text-align: left">byte</td><td style="text-align: left">0</td></tr>
<tr><td style="text-align: left">short</td><td style="text-align: left">0</td></tr>
<tr><td style="text-align: left">int</td><td style="text-align: left">0</td></tr>
<tr><td style="text-align: left">long</td><td style="text-align: left">0L</td></tr>
<tr><td style="text-align: left">float</td><td style="text-align: left">0.0f</td></tr>
<tr><td style="text-align: left">double</td><td style="text-align: left">0.0d</td></tr>
<tr><td style="text-align: left">char</td><td style="text-align: left">'u0000'</td></tr>
<tr><td style="text-align: left">String (or any object)</td><td style="text-align: left">null</td></tr>
<tr><td style="text-align: left">boolean</td><td style="text-align: left">false</td></tr>
<tr><td style="text-align: left">测试示例：</td><td style="text-align: left"></td></tr>
</tbody></table>
</div>
<pre><code class="language-java">public class Test {
    static boolean bool;
    static byte by;
    static char ch;
    static double d;
    static float f;
    static int i;
    static long l;
    static short sh;
    static String str;
 
    public static void main(String[] args) {
        System.out.println("Bool :" + bool);
        System.out.println("Byte :" + by);
        System.out.println("Character:" + ch);
        System.out.println("Double :" + d);
        System.out.println("Float :" + f);
        System.out.println("Integer :" + i);
        System.out.println("Long :" + l);
        System.out.println("Short :" + sh);
        System.out.println("String :" + str);
    }
}
</code></pre>
<p>实例输出结果：</p>
<pre><code>Bool     :false
Byte     :0
Character:
Double   :0.0
Float    :0.0
Integer  :0
Long     :0
Short    :0
String   :null
</code></pre>
<h2 id="引用类型"><a class="header" href="#引用类型">引用类型</a></h2>
<p>引用类型主要包括类（class）、接口（interface）和数组。</p>
<ul>
<li>在Java中，引用类型的变量非常类似于C/C++的指针。引用类型指向一个对象，指向对象的变量是引用变量。这些变量在声明时被指定为一个特定的类型，比如 Employee、Puppy 等。变量一旦声明后，类型就不能被改变了。</li>
<li>对象、数组都是引用数据类型。</li>
<li>所有引用类型的默认值都是null。</li>
<li>一个引用变量可以用来引用任何与之兼容的类型。</li>
<li>例子：Site site = new Site("Runoob")。</li>
</ul>
<h2 id="常量"><a class="header" href="#常量">常量</a></h2>
<p>常量在程序运行时是不能被修改的。</p>
<p>在 Java 中使用 final 关键字来修饰常量，声明方式和变量类似：</p>
<pre><code class="language-java">final double PI = 3.1415927;
</code></pre>
<p>常量名虽然也可以用小写，但为了便于识别，通常使用大写字母表示常量。</p>
<p>字面量可以赋给任何内置类型的变量。例如：</p>
<pre><code class="language-java">byte a = 68;
char a = 'A'
</code></pre>
<p>byte、int、long和short都可以用十进制、16进制以及8进制的方式来表示。</p>
<p>当使用字面量的时候，前缀 0 表示 8 进制，而前缀 0x 代表 16 进制, 例如：</p>
<pre><code class="language-java">int decimal = 100;
int octal = 0144;
int hexa =  0x64;
</code></pre>
<p>和其他语言一样，Java的字符串常量也是包含在两个引号之间的字符序列。下面是字符串型字面量的例子：</p>
<pre><code class="language-java">"Hello World"
"two\nlines"
"\"This is in quotes\""
</code></pre>
<p>字符串常量和字符变量都可以包含任何 Unicode 字符。例如：</p>
<pre><code class="language-java">char a = '\u0001';
String a = "\u0001";
</code></pre>
<p>Java语言支持一些特殊的转义字符序列。</p>
<div class="table-wrapper"><table><thead><tr><th>符号</th><th>字符含义</th></tr></thead><tbody>
<tr><td>\n</td><td>换行 (0x0a)</td></tr>
<tr><td>\r</td><td>回车 (0x0d)</td></tr>
<tr><td>\f</td><td>换页符(0x0c)</td></tr>
<tr><td>\b</td><td>退格 (0x08)</td></tr>
<tr><td>\0</td><td>空字符 (0x0)</td></tr>
<tr><td>\s</td><td>空格 (0x20)</td></tr>
<tr><td>\t</td><td>制表符</td></tr>
<tr><td>"</td><td>双引号</td></tr>
<tr><td>'</td><td>单引号</td></tr>
<tr><td>|反斜杠</td><td></td></tr>
<tr><td>\ddd</td><td>八进制字符 (ddd)</td></tr>
<tr><td>\uxxxx</td><td>16进制Unicode字符 (xxxx)</td></tr>
</tbody></table>
</div>
<h2 id="类型转换"><a class="header" href="#类型转换">类型转换</a></h2>
<h3 id="自动类型转换"><a class="header" href="#自动类型转换">自动类型转换</a></h3>
<p><strong>整型、实型（常量）、字符型数据可以混合运算。运算中，不同类型的数据先转化为同一类型（容量最大的那种类型），然后进行运算。</strong></p>
<p>转换从低级到高级顺序：</p>
<pre><code>低  ------------------------------------&gt;  高

byte,short,char—&gt; int —&gt; long—&gt; float —&gt; double 

</code></pre>
<p>（byte、short）和char之间赋值时不会发生自动类型转换，例如<code>byte b = 97;char c = b;</code>这种写法会报错。（byte、short）和char之间可以通过转换为int类型然后运算，例如<code>byte b = 97;short s = 10;short s2 = s + b;</code>也会报错。byte类型数据和byte类型数据之间运算结果也是int类型数据，例如<code>byte b1 = 97;byte b2 = 1;byte b = b1 + b2;</code>也会报错。</p>
<p><strong>自动类型转换必须满足转换前的数据类型的位数要低于转换后的数据类型，例如: short数据类型的位数为16位，就可以自动转换位数为32的int类型，同样float数据类型的位数为32，可以自动转换为64位的double类型。</strong></p>
<pre><code class="language-java">public class helloworld {
 
	public static void main(String[] args) {
		// TODO Auto-generated method stub
		char c1='a';//定义一个char类型
        int i1 = c1;//char自动类型转换为int
        System.out.println("char自动类型转换为int后的值等于"+i1);
        char c2 = 'A';//定义一个char类型
        int i2 = c2+1;//char 类型和 int 类型计算
        System.out.println("char类型和int计算后的值等于"+i2);
	}

}
</code></pre>
<p>运行结果为：</p>
<pre><code>char自动类型转换为int后的值等于97
char类型和int计算后的值等于66
</code></pre>
<p>数据类型转换必须满足如下规则：</p>
<p>1.不能对boolean类型进行类型转换。</p>
<p>2.不能把对象类型转换成不相关类的对象。</p>
<p>3.<strong>在把容量大的类型转换为容量小的类型时必须使用强制类型转换。</strong></p>
<p>4.转换过程中可能导致溢出或损失精度，例如：</p>
<pre><code class="language-java">public class helloworld {
 
	public static void main(String[] args) {
		// TODO Auto-generated method stub
		int i =128;   
		byte b = (byte)i;

		System.out.println(b);//输出-128
	}

}
</code></pre>
<p>因为 byte 类型是 8 位，最大值为127，所以当 int 强制转换为 byte 类型时，值 128 时候就会导致溢出。</p>
<p>5.<strong>浮点数到整数的转换是通过舍弃小数得到，而不是四舍五入，也可以视为向零舍去</strong>，例如：</p>
<pre><code class="language-java">public class helloworld {
 
	public static void main(String[] args) {
		// TODO Auto-generated method stub
		System.out.println((int)23.7 == 23);//true
		System.out.println((int)-45.89f == -45);//true
	}

}
</code></pre>
<h3 id="强制类型转换"><a class="header" href="#强制类型转换">强制类型转换</a></h3>
<p>定义语句<code>int n1 = 9L;</code>会报错，定义语句<code>float f = 1.1;</code>也会报错。</p>
<ul>
<li>
<ol>
<li>条件是转换的数据类型必须是兼容的。</li>
</ol>
</li>
<li>
<ol start="2">
<li>格式：(type)value中 type是要强制类型转换后的数据类型</li>
</ol>
</li>
<li>3.强制转换符号只对最近的操作数有效，可以用小括号指定强制类型转换范围</li>
<li>4.char类型可以保存int类型常量值，但不能保存int类型变量值（此时需要强制类型转换）</li>
<li>5.byte、short、char类型数据参与运算时当作int类型处理</li>
</ul>
<p>基本数据类型和String类型的转换：</p>
<ul>
<li>基本数据类型转String类型：加“”即可</li>
<li>String类型转基本数据类型：根据基本数据类型的包装类调用parserXX方法即可，要获取特定字符可以使用字符串变量的charAt()方法</li>
</ul>
<pre><code class="language-java">public class helloworld {
 
	public static void main(String[] args) {
		// TODO Auto-generated method stub
		int num1 = 10;
		String s1 = num1 + "";
		System.out.println(s1);
		
		String s2 = "123";
		int num2 = Integer.parseInt(s2);
		System.out.println(num2);
		double num3 = Double.parseDouble(s2);
		System.out.println(num3);
		char c = s2.charAt(1);
		System.out.println(c);
	}
}
</code></pre>
<p>输出结果如下：</p>
<pre><code>10
123
123.0
2
</code></pre>
<h3 id="隐含强制类型转换"><a class="header" href="#隐含强制类型转换">隐含强制类型转换</a></h3>
<ul>
<li>1.整数的默认类型是 int。</li>
<li>2.小数默认是 double 类型浮点型，在定义 float 类型时必须在数字后面跟上 F 或者 f。</li>
</ul>
<p>涉及+号的数值类型转换，从左向右运算。如果+号左右两边都是数值类型则做加法运算；如果左右有一部分是字符串则作字符串拼接。</p>
<pre><code class="language-java">public class helloworld {
 
	public static void main(String[] args) {
		// TODO Auto-generated method stub
		System.out.println(100 + 98);
		System.out.println("100" + 98);
		System.out.println(100 + 98 + "hello");
		System.out.println("hello" + 100 + 98);
	}
}
</code></pre>
<pre><code>198
10098
198hello
hello10098
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="java运算符"><a class="header" href="#java运算符">Java运算符</a></h1>
<ul>
<li><a href="%E8%BF%90%E7%AE%97%E7%AC%A6.html#%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97%E7%AC%A6">算术运算符</a></li>
<li><a href="%E8%BF%90%E7%AE%97%E7%AC%A6.html#%E5%85%B3%E7%B3%BB%E8%BF%90%E7%AE%97%E7%AC%A6">关系运算符</a></li>
<li><a href="%E8%BF%90%E7%AE%97%E7%AC%A6.html#instanceof-%E8%BF%90%E7%AE%97%E7%AC%A6">instanceof 运算符</a></li>
<li><a href="%E8%BF%90%E7%AE%97%E7%AC%A6.html#%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6">位运算符</a></li>
<li><a href="%E8%BF%90%E7%AE%97%E7%AC%A6.html#%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6">逻辑运算符</a></li>
<li><a href="%E8%BF%90%E7%AE%97%E7%AC%A6.html#%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6">赋值运算符</a></li>
<li><a href="%E8%BF%90%E7%AE%97%E7%AC%A6.html#%E6%9D%A1%E4%BB%B6%E8%BF%90%E7%AE%97%E7%AC%A6">条件运算符（?:）</a></li>
<li><a href="%E8%BF%90%E7%AE%97%E7%AC%A6.html#java%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7">Java运算符优先级</a></li>
</ul>
<p>计算机的最基本用途之一就是执行数学运算，作为一门计算机语言，Java也提供了一套丰富的运算符来操纵变量。我们可以把运算符分成以下几组：</p>
<ul>
<li>算术运算符</li>
<li>关系运算符</li>
<li>位运算符</li>
<li>逻辑运算符</li>
<li>赋值运算符</li>
<li>其他运算符</li>
</ul>
<h2 id="算术运算符"><a class="header" href="#算术运算符">算术运算符</a></h2>
<p>算术运算符用在数学表达式中，它们的作用和在数学中的作用一样。下表列出了所有的算术运算符。</p>
<p>表格中的实例假设整数变量A的值为10，变量B的值为20：</p>
<div class="table-wrapper"><table><thead><tr><th>操作符</th><th>描述</th><th>例子</th></tr></thead><tbody>
<tr><td>+</td><td>加法 - 相加运算符两侧的值</td><td>A + B 等于 30</td></tr>
<tr><td>-</td><td>减法 - 左操作数减去右操作数</td><td>A – B 等于 -10</td></tr>
<tr><td>*</td><td>乘法 - 相乘操作符两侧的值</td><td>A * B等于200</td></tr>
<tr><td>/</td><td>除法 - 左操作数除以右操作数</td><td>B / A等于2</td></tr>
<tr><td>％</td><td>取余 - 左操作数除以右操作数的余数</td><td>B%A等于0</td></tr>
<tr><td>++</td><td>自增: 操作数的值增加1</td><td>B++ 或 ++B 等于 21（区别详见下文）</td></tr>
<tr><td>--</td><td>自减: 操作数的值减少1</td><td>B-- 或 --B 等于 19（区别详见下文）</td></tr>
</tbody></table>
</div>
<pre><code class="language-java">public class helloworld {
 
	public static void main(String[] args) {
		// TODO Auto-generated method stub
		int a = 10;
	    int b = 20;
	    int c = 25;
	    System.out.println("a + b = " + (a + b) );
	    System.out.println("a - b = " + (a - b) );
	    System.out.println("a * b = " + (a * b) );
	    System.out.println("b / a = " + (b / a) );
	    System.out.println("b % a = " + (b % a) );
	    System.out.println("c % a = " + (c % a) );
	    System.out.println("a++   = " +  (a++) );
	    System.out.println("a--   = " +  (a--) );
	    // 查看  d++ 与 ++d 的不同
	    int d = 25;
	    System.out.println("d++   = " +  (d++) );
	    d = 25;
	    System.out.println("++d   = " +  (++d) );
	}
}
</code></pre>
<pre><code>a + b = 30
a - b = -10
a * b = 200
b / a = 2
b % a = 0
c % a = 5
a++   = 10
a--   = 11
d++   = 25
++d   = 26
</code></pre>
<p><strong>自增自减运算符</strong></p>
<p><strong>1、自增（++）自减（--）运算符</strong>是一种特殊的算术运算符，在算术运算符中需要两个操作数来进行运算，而自增自减运算符是一个操作数。</p>
<p>2、前缀自增自减法(++a,--a): 先进行自增或者自减运算，再进行表达式运算。</p>
<p>3、后缀自增自减法(a++,a--): 先进行表达式运算，再进行自增或者自减运算。</p>
<p>典例：</p>
<pre><code class="language-java">public class helloworld {
 
	public static void main(String[] args) {
		// TODO Auto-generated method stub
		int i = 10;
		i = i++;
		System.out.println(i);
		i = 10;
		i = ++i;
		System.out.println(i);
	}
}
</code></pre>
<p>输出结果如下：</p>
<pre><code>10
11
</code></pre>
<p>原因解释：</p>
<p>对于<code>i = i++;</code>这种自增运算需要一个临时变量temp，即（1）temp = i;（2）i = i + 1;（3）i = temp;第（1）步中的i是表达式右边的i，第（3）步中的i是表达式左边的i。</p>
<p>对于<code>i = ++i;</code>这种自增运算需要一个临时变量temp，即（1）i = i + 1;（2）temp = i;（3）i = temp;第（1）步中的i是表达式右边的i，第（3）步中的i是表达式左边的i。</p>
<h2 id="关系运算符"><a class="header" href="#关系运算符">关系运算符</a></h2>
<p>下表为Java支持的关系运算符</p>
<p>表格中的实例整数变量A的值为10，变量B的值为20：</p>
<div class="table-wrapper"><table><thead><tr><th>运算符</th><th>描述</th><th>例子</th></tr></thead><tbody>
<tr><td>==</td><td>检查如果两个操作数的值是否相等，如果相等则条件为真。</td><td>（A == B）为假。</td></tr>
<tr><td>!=</td><td>检查如果两个操作数的值是否相等，如果值不相等则条件为真。</td><td>(A != B) 为真。</td></tr>
<tr><td>&gt;</td><td>检查左操作数的值是否大于右操作数的值，如果是那么条件为真。</td><td>（A&gt; B）为假。</td></tr>
<tr><td>&lt;</td><td>检查左操作数的值是否小于右操作数的值，如果是那么条件为真。</td><td>（A &lt;B）为真。</td></tr>
<tr><td>&gt;=</td><td>检查左操作数的值是否大于或等于右操作数的值，如果是那么条件为真。</td><td>（A&gt; = B）为假。</td></tr>
<tr><td>&lt;=</td><td>检查左操作数的值是否小于或等于右操作数的值，如果是那么条件为真。</td><td>（A &lt;= B）为真。</td></tr>
<tr><td>实例：</td><td></td><td></td></tr>
</tbody></table>
</div>
<pre><code class="language-java">public class helloworld {
 
	public static void main(String[] args) {
		// TODO Auto-generated method stub
		int a = 10;
	    int b = 20;
	    System.out.println("a == b = " + (a == b) );
	    System.out.println("a != b = " + (a != b) );
	    System.out.println("a &gt; b = " + (a &gt; b) );
	    System.out.println("a &lt; b = " + (a &lt; b) );
	    System.out.println("b &gt;= a = " + (b &gt;= a) );
	    System.out.println("b &lt;= a = " + (b &lt;= a) );
	}
}

</code></pre>
<p>输出结果如下：</p>
<pre><code>a == b = false
a != b = true
a &gt; b = false
a &lt; b = true
b &gt;= a = true
b &lt;= a = false
</code></pre>
<h2 id="instanceof-运算符"><a class="header" href="#instanceof-运算符">instanceof 运算符</a></h2>
<p>该运算符用于操作对象实例，检查该对象是否是一个特定类型（类类型或接口类型）。</p>
<p>instanceof运算符使用格式如下：</p>
<pre><code class="language-java">( Object reference variable ) instanceof  (class/interface type)
</code></pre>
<p>如果运算符左侧变量所指的对象，是操作符右侧类或接口(class/interface)的一个对象，那么结果为真。</p>
<p>下面是一个例子：</p>
<pre><code class="language-java">String name = "James";
boolean result = name instanceof String; // 由于 name 是 String 类型，所以返回真
</code></pre>
<p>如果被比较的对象兼容于右侧类型，该运算符仍然返回 true。</p>
<p>看下面的例子：</p>
<pre><code class="language-java">class Vehicle {}
 
public class Car extends Vehicle {
   public static void main(String[] args){
      Vehicle a = new Car();
      boolean result =  a instanceof Car;
      System.out.println(result);
   }
}
</code></pre>
<p>以上实例编译运行结果如下：</p>
<pre><code>true
</code></pre>
<h2 id="位运算符"><a class="header" href="#位运算符">位运算符</a></h2>
<p>Java定义了位运算符，应用于整数类型(int)，长整型(long)，短整型(short)，字符型(char)，和字节型(byte)等类型。</p>
<p>位运算符作用在所有的位上，并且按位运算。假设a = 60，b = 13;它们的二进制格式表示将如下：</p>
<pre><code class="language-java">A = 0011 1100
B = 0000 1101
-----------------
A&amp;B = 0000 1100
A | B = 0011 1101
A ^ B = 0011 0001
~A= 1100 0011
</code></pre>
<p>下表列出了位运算符的基本运算，假设整数变量 A 的值为 60 和变量 B 的值为 13：</p>
<div class="table-wrapper"><table><thead><tr><th>操作符</th><th>描述</th><th>例子</th></tr></thead><tbody>
<tr><td>＆</td><td>如果相对应位都是1，则结果为1，否则为0</td><td>（A＆B），得到12，即0000 1100</td></tr>
<tr><td>|</td><td>如果相对应位都是 0，则结果为 0，否则为 1</td><td>（A | B）得到61，即 0011 1101</td></tr>
<tr><td>^</td><td>如果相对应位值相同，则结果为0，否则为1</td><td>（A ^ B）得到49，即 0011 0001</td></tr>
<tr><td>〜</td><td>按位取反运算符翻转操作数的每一位，即0变成1，1变成0。</td><td>（〜A）得到-61，即1100 0011</td></tr>
<tr><td>&lt;&lt;</td><td>按位左移运算符。左操作数按位左移右操作数指定的位数。</td><td>A &lt;&lt; 2得到240，即 1111 0000</td></tr>
<tr><td>&gt;&gt;</td><td>按位右移运算符。左操作数按位右移右操作数指定的位数。</td><td>A &gt;&gt; 2得到15即 1111</td></tr>
<tr><td>&gt;&gt;&gt;</td><td>按位右移补零操作符。左操作数的值按右操作数指定的位数右移，移动得到的空位以零填充。</td><td>A&gt;&gt;&gt;2得到15即0000 1111</td></tr>
</tbody></table>
</div>
<p>实例：</p>
<pre><code class="language-java">public class helloworld {
 
	public static void main(String[] args) {
		// TODO Auto-generated method stub
		int a = 60; /* 60 = 0011 1100 */ 
	    int b = 13; /* 13 = 0000 1101 */
	    int c = 0;
	    c = a &amp; b;       /* 12 = 0000 1100 */
	    System.out.println("a &amp; b = " + c );
	 
	    c = a | b;       /* 61 = 0011 1101 */
	    System.out.println("a | b = " + c );
	 
	    c = a ^ b;       /* 49 = 0011 0001 */
	    System.out.println("a ^ b = " + c );
	 
	    c = ~a;          /*-61 = 1100 0011 */
	    System.out.println("~a = " + c );
	 
	    c = a &lt;&lt; 2;     /* 240 = 1111 0000 */
	    System.out.println("a &lt;&lt; 2 = " + c );
	 
	    c = a &gt;&gt; 2;     /* 15 = 1111 */
	    System.out.println("a &gt;&gt; 2  = " + c );
	  
	    c = a &gt;&gt;&gt; 2;     /* 15 = 0000 1111 */
	    System.out.println("a &gt;&gt;&gt; 2 = " + c );
	}
}
</code></pre>
<p>输出结果如下：</p>
<pre><code>a &amp; b = 12
a | b = 61
a ^ b = 49
~a = -61
a &lt;&lt; 2 = 240
a &gt;&gt; 2  = 15
a &gt;&gt;&gt; 2 = 15
</code></pre>
<h2 id="逻辑运算符"><a class="header" href="#逻辑运算符">逻辑运算符</a></h2>
<p>下表列出了逻辑运算符的基本运算，假设布尔变量A为真，变量B为假</p>
<div class="table-wrapper"><table><thead><tr><th>操作符</th><th>描述</th><th>例子</th></tr></thead><tbody>
<tr><td>&amp;&amp;</td><td>称为逻辑与运算符。当且仅当两个操作数都为真，条件才为真。</td><td>（A &amp;&amp; B）为假。</td></tr>
<tr><td>| |</td><td>称为逻辑或操作符。如果任何两个操作数任何一个为真，条件为真。</td><td>（A | | B）为真。</td></tr>
<tr><td>！</td><td>称为逻辑非运算符。用来反转操作数的逻辑状态。如果条件为true，则逻辑非运算符将得到false。</td><td>！（A &amp;&amp; B）为真。</td></tr>
<tr><td>下面的简单示例程序演示了逻辑运算符。</td><td></td><td></td></tr>
</tbody></table>
</div>
<pre><code class="language-java">public class helloworld {
 
	public static void main(String[] args) {
		// TODO Auto-generated method stub
		boolean a = true;
	    boolean b = false;
	    System.out.println("a &amp;&amp; b = " + (a&amp;&amp;b));
	    System.out.println("a || b = " + (a||b) );
	    System.out.println("!(a &amp;&amp; b) = " + !(a &amp;&amp; b));
	}
}

</code></pre>
<p>以上实例编译运行结果如下：</p>
<pre><code>a &amp;&amp; b = false
a || b = true
!(a &amp;&amp; b) = true
</code></pre>
<p><strong>短路逻辑运算符</strong></p>
<p>当使用与逻辑运算符时，在两个操作数都为true时，结果才为true，但是当得到第一个操作为false时，其结果就必定是false，这时候就不会再判断第二个操作了。</p>
<pre><code class="language-java">public class helloworld {
 
	public static void main(String[] args) {
		// TODO Auto-generated method stub
		int a = 5;//定义一个变量；
        boolean b = (a&lt;4)&amp;&amp;(a++&lt;10);
        System.out.println("使用短路逻辑运算符的结果为"+b);
        System.out.println("a的结果为"+a);
	}
}
</code></pre>
<pre><code>使用短路逻辑运算符的结果为false
a的结果为5
</code></pre>
<p><strong>解析：</strong> 该程序使用到了短路逻辑运算符(&amp;&amp;)，首先判断 a&lt;4 的结果为 false，则 b 的结果必定是 false，所以不再执行第二个操作 a++&lt;10 的判断，所以 a 的值为 5。</p>
<p>位运算符也可以用在逻辑比较中。如下面例子所示：</p>
<pre><code class="language-java">public class helloworld {
 
	public static void main(String[] args) {
		// TODO Auto-generated method stub
		int x = 5;
        int y = 5;
        if(x++ == 6 &amp; ++y == 6)//位运算 
        {
        	x = 11;
        }
        System.out.println("x = " + x + " y = " + y );//6,6
        x = 5;
        y = 5;
        if(x++ == 6 &amp;&amp; ++y == 6) //逻辑与，短路运算
        {
        	x = 11;
        }
        System.out.println("x = " + x + " y = " + y );//6,5
        x = 5;
        y = 5;
        if(x++ == 6 | ++y == 6)//位运算
        {
        	x = 11;
        }
        System.out.println("x = " + x + " y = " + y );//11,6
        
        x = 5;
        y = 5;
        if(x++ == 6 || ++y == 6)//逻辑或，短路运算
        {
        	x = 11;
        }
        System.out.println("x = " + x + " y = " + y );//11,5
	}
}
</code></pre>
<p>输出结果如下：</p>
<pre><code>x = 6 y = 6
x = 6 y = 5
x = 11 y = 6
x = 11 y = 6
</code></pre>
<h2 id="赋值运算符"><a class="header" href="#赋值运算符">赋值运算符</a></h2>
<p>下面是Java语言支持的赋值运算符：</p>
<div class="table-wrapper"><table><thead><tr><th>操作符</th><th>描述</th><th>例子</th></tr></thead><tbody>
<tr><td>=</td><td>简单的赋值运算符，将右操作数的值赋给左侧操作数</td><td>C = A + B将把A + B得到的值赋给C</td></tr>
<tr><td>+ =</td><td>加和赋值操作符，它把左操作数和右操作数相加赋值给左操作数</td><td>C + = A等价于C = C + A</td></tr>
<tr><td>- =</td><td>减和赋值操作符，它把左操作数和右操作数相减赋值给左操作数</td><td>C - = A等价于C = C - A</td></tr>
<tr><td>* =</td><td>乘和赋值操作符，它把左操作数和右操作数相乘赋值给左操作数</td><td>C * = A等价于C = C * A</td></tr>
<tr><td>/ =</td><td>除和赋值操作符，它把左操作数和右操作数相除赋值给左操作数</td><td>C / = A，C 与 A 同类型时等价于 C = C / A</td></tr>
<tr><td>（％）=</td><td>取模和赋值操作符，它把左操作数和右操作数取模后赋值给左操作数</td><td>C％= A等价于C = C％A</td></tr>
<tr><td>&lt;&lt; =</td><td>左移位赋值运算符</td><td>C &lt;&lt; = 2等价于C = C &lt;&lt; 2</td></tr>
<tr><td>&gt;&gt; =</td><td>右移位赋值运算符</td><td>C &gt;&gt; = 2等价于C = C &gt;&gt; 2</td></tr>
<tr><td>＆=</td><td>按位与赋值运算符</td><td>C＆= 2等价于C = C＆2</td></tr>
<tr><td>^ =</td><td>按位异或赋值操作符</td><td>C ^ = 2等价于C = C ^ 2</td></tr>
<tr><td>| =</td><td>按位或赋值操作符</td><td>C | = 2等价于C = C | 2</td></tr>
</tbody></table>
</div>
<p>下面的简单示例程序演示了赋值运算符。</p>
<pre><code class="language-java">public class helloworld {
 
	public static void main(String[] args) {
		// TODO Auto-generated method stub
		int a = 10;
        int b = 20;
        int c = 0;
        c = a + b;
        System.out.println("c = a + b = " + c );
        c += a ;
        System.out.println("c += a  = " + c );
        c -= a ;
        System.out.println("c -= a = " + c );
        c *= a ;
        System.out.println("c *= a = " + c );
        a = 10;
        c = 15;
        c /= a ;
        System.out.println("c /= a = " + c );
        a = 10;
        c = 15;
        c %= a ;
        System.out.println("c %= a  = " + c );
        c &lt;&lt;= 2 ;
        System.out.println("c &lt;&lt;= 2 = " + c );
        c &gt;&gt;= 2 ;
        System.out.println("c &gt;&gt;= 2 = " + c );
        c &gt;&gt;= 2 ;
        System.out.println("c &gt;&gt;= 2 = " + c );
        c &amp;= a ;
        System.out.println("c &amp;= a  = " + c );
        c ^= a ;
        System.out.println("c ^= a   = " + c );
        c |= a ;
        System.out.println("c |= a   = " + c );
	}
}
</code></pre>
<p>以上实例编译运行结果如下：</p>
<pre><code>c = a + b = 30
c += a  = 40
c -= a = 30
c *= a = 300
c /= a = 1
c %= a  = 5
c &lt;&lt;= 2 = 20
c &gt;&gt;= 2 = 5
c &gt;&gt;= 2 = 1
c &amp;= a  = 0
c ^= a   = 10
c |= a   = 10
</code></pre>
<h2 id="条件运算符"><a class="header" href="#条件运算符">条件运算符（?:）</a></h2>
<p>条件运算符也被称为三元运算符。该运算符有3个操作数，并且需要判断布尔表达式的值。该运算符的主要是决定哪个值应该赋值给变量。</p>
<pre><code class="language-java">variable x = (expression) ? value if true : value if false
</code></pre>
<p>实例</p>
<pre><code class="language-java">public class helloworld {
 
	public static void main(String[] args) {
		// TODO Auto-generated method stub
		int a , b;
	    a = 10;
	    // 如果 a 等于 1 成立，则设置 b 为 20，否则为 30
	    b = (a == 1) ? 20 : 30;
	    System.out.println( "Value of b is : " +  b );
	 
	    // 如果 a 等于 10 成立，则设置 b 为 20，否则为 30
	    b = (a == 10) ? 20 : 30;
	    System.out.println( "Value of b is : " + b );
	}
}
</code></pre>
<p>输出结果如下：</p>
<pre><code>Value of b is : 30
Value of b is : 20
</code></pre>
<h2 id="java运算符优先级"><a class="header" href="#java运算符优先级">Java运算符优先级</a></h2>
<p>当多个运算符出现在一个表达式中，谁先谁后呢？这就涉及到运算符的优先级别的问题。在一个多运算符的表达式中，运算符优先级不同会导致最后得出的结果差别甚大。</p>
<p>例如，（1+3）＋（3+2）*2，这个表达式如果按加号最优先计算，答案就是 18，如果按照乘号最优先，答案则是 14。</p>
<p>再如，x = 7 + 3 * 2;这里x得到13，而不是20，因为乘法运算符比加法运算符有较高的优先级，所以先计算3 * 2得到6，然后再加7。</p>
<p>下表中具有最高优先级的运算符在的表的最上面，最低优先级的在表的底部。</p>
<div class="table-wrapper"><table><thead><tr><th>类别</th><th>操作符</th><th>关联性</th></tr></thead><tbody>
<tr><td>后缀</td><td>() [] . (点操作符)</td><td>左到右</td></tr>
<tr><td>一元</td><td>expr++ expr--</td><td>从左到右</td></tr>
<tr><td>一元</td><td>++expr --expr + - ～ ！</td><td>从右到左</td></tr>
<tr><td>乘性</td><td>* /％</td><td>左到右</td></tr>
<tr><td>加性</td><td>+ -</td><td>左到右</td></tr>
<tr><td>移位</td><td>&gt;&gt; &gt;&gt;&gt;  &lt;&lt;</td><td>左到右</td></tr>
<tr><td>关系</td><td>&gt; &gt;= &lt; &lt;=</td><td>左到右</td></tr>
<tr><td>相等</td><td>==  !=</td><td>左到右</td></tr>
<tr><td>按位与</td><td>＆</td><td>左到右</td></tr>
<tr><td>按位异或</td><td>^</td><td>左到右</td></tr>
<tr><td>按位或</td><td>|</td><td>左到右</td></tr>
<tr><td>逻辑与</td><td>&amp;&amp;</td><td>左到右</td></tr>
<tr><td>逻辑或</td><td>| |</td><td>左到右</td></tr>
<tr><td>条件</td><td>？：</td><td>从右到左</td></tr>
<tr><td>赋值</td><td>= + = - = * = / =％= &gt;&gt; = &lt;&lt; =＆= ^ = | =</td><td>从右到左</td></tr>
<tr><td>逗号</td><td>，</td><td>左到右</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="程序流程控制"><a class="header" href="#程序流程控制">程序流程控制</a></h1>
<ul>
<li><a href="%E7%A8%8B%E5%BA%8F%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6.html#%E9%A1%BA%E5%BA%8F%E7%BB%93%E6%9E%84">顺序结构</a></li>
<li><a href="%E7%A8%8B%E5%BA%8F%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6.html#%E6%9D%A1%E4%BB%B6%E7%BB%93%E6%9E%84">条件结构</a>
<ul>
<li><a href="%E7%A8%8B%E5%BA%8F%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6.html#if%E8%AF%AD%E5%8F%A5">if语句</a></li>
<li><a href="%E7%A8%8B%E5%BA%8F%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6.html#ifelse%E8%AF%AD%E5%8F%A5">if...else语句</a></li>
<li><a href="%E7%A8%8B%E5%BA%8F%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6.html#ifelse-ifelse-%E8%AF%AD%E5%8F%A5">if...else if...else 语句</a></li>
<li><a href="%E7%A8%8B%E5%BA%8F%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6.html#%E5%B5%8C%E5%A5%97%E7%9A%84-ifelse-%E8%AF%AD%E5%8F%A5">嵌套的 if…else 语句</a></li>
<li><a href="%E7%A8%8B%E5%BA%8F%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6.html#switch%E5%88%86%E6%94%AF%E8%AF%AD%E5%8F%A5">Switch分支语句</a></li>
</ul>
</li>
<li><a href="%E7%A8%8B%E5%BA%8F%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6.html#%E5%BE%AA%E7%8E%AF%E7%BB%93%E6%9E%84---for-while-%E5%8F%8A-dowhile">循环结构 - for, while 及 do...while</a>
<ul>
<li><a href="%E7%A8%8B%E5%BA%8F%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6.html#while-%E5%BE%AA%E7%8E%AF">while 循环</a></li>
<li><a href="%E7%A8%8B%E5%BA%8F%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6.html#dowhile-%E5%BE%AA%E7%8E%AF">do…while 循环</a></li>
<li><a href="%E7%A8%8B%E5%BA%8F%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6.html#for%E5%BE%AA%E7%8E%AF">for循环</a></li>
<li><a href="%E7%A8%8B%E5%BA%8F%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6.html#java-%E5%A2%9E%E5%BC%BA-for-%E5%BE%AA%E7%8E%AF">Java 增强 for 循环</a></li>
<li><a href="%E7%A8%8B%E5%BA%8F%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6.html#%E5%A4%9A%E9%87%8D%E5%BE%AA%E7%8E%AF%E6%8E%A7%E5%88%B6">多重循环控制</a></li>
</ul>
</li>
<li><a href="%E7%A8%8B%E5%BA%8F%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6.html#break-%E5%85%B3%E9%94%AE%E5%AD%97">break 关键字</a>
<ul>
<li><a href="%E7%A8%8B%E5%BA%8F%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6.html#%E8%AF%AD%E6%B3%95">语法</a></li>
</ul>
</li>
<li><a href="%E7%A8%8B%E5%BA%8F%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6.html#continue-%E5%85%B3%E9%94%AE%E5%AD%97">continue 关键字</a>
<ul>
<li><a href="%E7%A8%8B%E5%BA%8F%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6.html#%E8%AF%AD%E6%B3%95-1">语法</a></li>
</ul>
</li>
<li><a href="%E7%A8%8B%E5%BA%8F%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6.html#return%E8%B7%B3%E8%BD%AC%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5">return跳转控制语句</a></li>
</ul>
<h2 id="顺序结构"><a class="header" href="#顺序结构">顺序结构</a></h2>
<p>逐条执行语句</p>
<h2 id="条件结构"><a class="header" href="#条件结构">条件结构</a></h2>
<p>Java 中的条件语句允许程序根据条件的不同执行不同的代码块。</p>
<p>一个 if 语句包含一个布尔表达式和一条或多条语句。</p>
<h3 id="if语句"><a class="header" href="#if语句">if语句</a></h3>
<p>if 语句的语法如下：</p>
<pre><code class="language-java">if(布尔表达式)
{
   //如果布尔表达式为true将执行的语句
}
</code></pre>
<p>如果布尔表达式的值为 true，则执行 if 语句中的代码块，否则执行 else 语句块后面的代码。</p>
<p>实例：</p>
<pre><code class="language-java">public class Test {
 
   public static void main(String args[]){
      int x = 10;
 
      if( x &lt; 20 ){
         System.out.print("这是 if 语句");
      }
   }
}
</code></pre>
<p>以上代码编译运行结果如下：</p>
<pre><code>这是 if 语句
</code></pre>
<h3 id="ifelse语句"><a class="header" href="#ifelse语句">if...else语句</a></h3>
<p>if 语句后面可以跟 else 语句，当 if 语句的布尔表达式值为 false 时，else 语句块会被执行。</p>
<p>if…else 的用法如下：</p>
<pre><code class="language-java">if(布尔表达式){
   //如果布尔表达式的值为true
}else{
   //如果布尔表达式的值为false
}
</code></pre>
<p>实例：</p>
<pre><code class="language-java">public class Test {
 
   public static void main(String args[]){
      int x = 30;
 
      if( x &lt; 20 ){
         System.out.print("这是 if 语句");
      }else{
         System.out.print("这是 else 语句");
      }
   }
}
</code></pre>
<p>以上代码编译运行结果如下：</p>
<pre><code>这是 else 语句
</code></pre>
<h3 id="ifelse-ifelse-语句"><a class="header" href="#ifelse-ifelse-语句">if...else if...else 语句</a></h3>
<p>if 语句后面可以跟 else if…else 语句，这种语句可以检测到多种可能的情况。</p>
<p>使用 if，else if，else 语句的时候，需要注意下面几点：</p>
<ul>
<li>if 语句至多有 1 个 else 语句，else 语句在所有的 else if 语句之后。</li>
<li>if 语句可以有若干个 else if 语句，它们必须在 else 语句之前。</li>
<li>一旦其中一个 else if 语句检测为 true，其他的 else if 以及 else 语句都将跳过执行。</li>
</ul>
<p>if...else 语法格式如下:</p>
<pre><code class="language-java">if(布尔表达式 1){
   //如果布尔表达式 1的值为true执行代码
}else if(布尔表达式 2){
   //如果布尔表达式 2的值为true执行代码
}else if(布尔表达式 3){
   //如果布尔表达式 3的值为true执行代码
}else {
   //如果以上布尔表达式都不为true执行代码
}
</code></pre>
<p>实例：</p>
<pre><code class="language-java">public class Test {
   public static void main(String args[]){
      int x = 30;
 
      if( x == 10 ){
         System.out.print("Value of X is 10");
      }else if( x == 20 ){
         System.out.print("Value of X is 20");
      }else if( x == 30 ){
         System.out.print("Value of X is 30");
      }else{
         System.out.print("这是 else 语句");
      }
   }
}
</code></pre>
<p>以上代码编译运行结果如下：</p>
<pre><code>Value of X is 30
</code></pre>
<p>如果条件表达式写成了赋值运算符，则会发生如下情况：</p>
<pre><code class="language-java">public class helloworld {
 
	public static void main(String[] args) {
		// TODO Auto-generated method stub
		int k;
		boolean b = true;
		if(b=false)
			System.out.println(k=1);
		else if(b){
			System.out.println(k=2);
		}
		else if(!b){
			System.out.println(k=3);
		}
		else {
			System.out.println(k=4);
		}
	}
}
</code></pre>
<p>输出结果为3</p>
<p>原因解释：<code>b=false</code>使得b变为false，第一个和第二个分支的条件表达式结果均为假。</p>
<h3 id="嵌套的-ifelse-语句"><a class="header" href="#嵌套的-ifelse-语句">嵌套的 if…else 语句</a></h3>
<p>使用嵌套的 if…else 语句是合法的。也就是说你可以在另一个 if 或者 else if 语句中使用 if 或者 else if 语句。</p>
<p>嵌套的 if…else 语法格式如下：</p>
<pre><code class="language-java">if(布尔表达式 1){
   ////如果布尔表达式 1的值为true执行代码
   if(布尔表达式 2){
      ////如果布尔表达式 2的值为true执行代码
   }
}
</code></pre>
<p>你可以像 if 语句一样嵌套 else if...else。</p>
<p>实例：</p>
<pre><code class="language-java">import java.util.Scanner;

public class helloworld {
 
	public static void main(String[] args) {
		// TODO Auto-generated method stub
		
		Scanner scanner = new Scanner(System.in);
		System.out.println("Please input your score:");
		double score = scanner.nextDouble();
		if(score &gt;= 8.0){
			System.out.println("Please input your gender:");
			char gender = scanner.next().charAt(0); 
			if(gender == '男'){
				System.out.println("Succeed to join men's group!");
			}
			else if(gender == '女'){
				System.out.println("Succeed to join women's group!");
			}
			else {
				System.out.println("You inputed the wrong gender!");
			}
		}
		else {
			System.out.println("You are fired!");
		}
		scanner.close();
	}
}
</code></pre>
<p>以上代码编译运行结果如下：</p>
<pre><code>Please input your score:
9
Please input your gender:
0
You inputed the wrong gender!
</code></pre>
<h3 id="switch分支语句"><a class="header" href="#switch分支语句">Switch分支语句</a></h3>
<p>switch case 语句判断一个变量与一系列值中某个值是否相等，每个值称为一个分支。</p>
<p>switch case 语句语法格式如下：</p>
<pre><code class="language-java">switch(expression){
    case value :
       //语句
       break; //可选
    case value :
       //语句
       break; //可选
    //你可以有任意数量的case语句
    default : //可选
       //语句
}
</code></pre>
<p><img src="https://www.runoob.com/wp-content/uploads/2018/09/java-switch-case-flow-diagram.jpeg" alt="a" /></p>
<p>switch case 语句有如下规则：</p>
<ul>
<li>switch 语句中的变量类型可以是： byte、short、int 或者 char。从 Java SE 7 开始，switch 支持字符串 String 类型了，同时 case 标签必须为字符串常量或字面量。也可以是由enum类型，但不能是double或float类型。</li>
<li>switch 语句可以拥有多个 case 语句。每个 case 后面跟一个要比较的值和冒号。</li>
<li><strong>case 语句中的值的数据类型必须与变量的数据类型相同，而且只能是常量或者字面常量</strong>。</li>
<li>当变量的值与 case 语句的值相等时，那么 case 语句之后的语句开始执行，直到 break 语句出现才会跳出 switch 语句。</li>
<li>当遇到 break 语句时，switch 语句终止。程序跳转到 switch 语句后面的语句执行。case 语句不必须要包含 break 语句。如果没有 break 语句出现，程序会继续执行下一条 case 语句，直到出现 break 语句。</li>
<li>switch 语句可以包含一个 default 分支，该分支一般是 switch 语句的最后一个分支（可以在任何位置，但建议在最后一个）。default 在没有 case 语句的值和变量值相等的时候执行。default 分支不需要 break 语句。</li>
</ul>
<p><strong>switch case 执行时，一定会先进行匹配，匹配成功返回当前 case 的值，再根据是否有 break，判断是否继续输出，或是跳出判断。</strong></p>
<pre><code class="language-java">package struct;

public class SwitchDemo1 {

    public static void main(String[] args) {
        char grade = 'C';

        switch(grade){
            case 'A':
                System.out.println("优秀");
                break;
            case 'B':
                System.out.println("良好");
                break;
            case 'C':
                System.out.println("及格");
                break;
            case 'D':
                System.out.println("再接再厉");
                break;
            case 'E':
                System.out.println("挂科");
                break;
            default:
                System.out.println("未知等级");

                //存在case穿透现象，每写一个case就要添加一个break语句

        }
    }
}
</code></pre>
<p>输出结果：</p>
<pre><code>良好
你的等级是 C
</code></pre>
<p>如果 case 语句块中没有 break 语句时，JVM 并不会顺序输出每一个 case 对应的返回值，而是继续匹配，匹配不成功则返回默认 case。</p>
<p>Test.java实例：</p>
<pre><code class="language-java">public class Test {
   public static void main(String args[]){
      int i = 5;
      switch(i){
         case 0:
            System.out.println("0");
         case 1:
            System.out.println("1");
         case 2:
            System.out.println("2");
         default:
            System.out.println("default");
      }
   }
}
</code></pre>
<p>以上代码编译运行结果如下：</p>
<pre><code>default
</code></pre>
<p>如果 case 语句块中没有 break 语句时，匹配成功后，从当前 case 开始，后续所有 case 的值都会输出。</p>
<p>Test.java 文件代码：</p>
<pre><code class="language-java">public class Test {
   public static void main(String args[]){
      int i = 1;
      switch(i){
         case 0:
            System.out.println("0");
         case 1:
            System.out.println("1");
         case 2:
            System.out.println("2");
         default:
            System.out.println("default");
      }
   }
}
</code></pre>
<p>以上代码编译运行结果如下：</p>
<pre><code>1
2
default
</code></pre>
<p>如果当前匹配成功的 case 语句块没有 break 语句，则从当前 case 开始，后续所有 case 的值都会输出，如果后续的 case 语句块有 break 语句则会跳出判断。</p>
<p>Test.java 文件代码：</p>
<pre><code class="language-java">public class Test {
   public static void main(String args[]){
      int i = 1;
      switch(i){
         case 0:
            System.out.println("0");
         case 1:
            System.out.println("1");
         case 2:
            System.out.println("2");
         case 3:
            System.out.println("3"); break;
         default:
            System.out.println("default");
      }
   }
}
</code></pre>
<p>以上代码编译运行结果如下：</p>
<pre><code class="language-txt">1
2
3
</code></pre>
<p>使用字符串类型数据的switch语句实例：</p>
<pre><code class="language-java">package struct;

public class SwitchDemo2 {
    public static void main(String[] args) {
        String name= "狂神";

        switch (name){
            case "包子":
                System.out.println("包子");
            case "狂神":
                System.out.println("狂神");
                break;
            default:
                System.out.println("输错了");

        }
    }
}
</code></pre>
<h2 id="循环结构---for-while-及-dowhile"><a class="header" href="#循环结构---for-while-及-dowhile">循环结构 - for, while 及 do...while</a></h2>
<p>顺序结构的程序语句只能被执行一次。</p>
<p>如果您想要同样的操作执行多次，就需要使用循环结构。</p>
<p>Java中有三种主要的循环结构：</p>
<ul>
<li><strong>while</strong> 循环</li>
<li><strong>do…while</strong> 循环</li>
<li><strong>for</strong> 循环</li>
</ul>
<p>在 Java5 中引入了一种主要用于数组的增强型 for 循环。</p>
<h3 id="while-循环"><a class="header" href="#while-循环">while 循环</a></h3>
<p>while是最基本的循环，它的结构为：</p>
<pre><code class="language-java">while( 布尔表达式 ) {
  //循环内容
}
</code></pre>
<p>只要布尔表达式为 true，循环就会一直执行下去。</p>
<p>实例Test.java 文件代码：</p>
<pre><code class="language-java">public class Test {
   public static void main(String[] args) {
      int x = 10;
      while( x &lt; 20 ) {
         System.out.print("value of x : " + x );
         x++;
         System.out.print("\n");
      }
   }
}
</code></pre>
<p>以上实例编译运行结果如下：</p>
<pre><code>value of x : 10
value of x : 11
value of x : 12
value of x : 13
value of x : 14
value of x : 15
value of x : 16
value of x : 17
value of x : 18
value of x : 19
</code></pre>
<h3 id="dowhile-循环"><a class="header" href="#dowhile-循环">do…while 循环</a></h3>
<p>对于 while 语句而言，如果不满足条件，则不能进入循环。但有时候我们需要即使不满足条件，也至少执行一次。</p>
<p>do…while 循环和 while 循环相似，不同的是，<strong>do…while 循环至少会执行一次</strong>。</p>
<pre><code class="language-java">do {
       //代码语句
}while(布尔表达式);
</code></pre>
<p><strong>注意：</strong> 布尔表达式在循环体的后面，所以语句块在检测布尔表达式之前已经执行了。 如果布尔表达式的值为 true，则语句块一直执行，直到布尔表达式的值为 false。</p>
<p>实例Test.java 文件代码：</p>
<pre><code class="language-java">public class Test {
   public static void main(String[] args){
      int x = 10;
 
      do{
         System.out.print("value of x : " + x );
         x++;
         System.out.print("\n");
      }while( x &lt; 20 );
   }
}
</code></pre>
<p>以上实例编译运行结果如下：</p>
<pre><code>value of x : 10
value of x : 11
value of x : 12
value of x : 13
value of x : 14
value of x : 15
value of x : 16
value of x : 17
value of x : 18
value of x : 19
</code></pre>
<h3 id="for循环"><a class="header" href="#for循环">for循环</a></h3>
<p>虽然所有循环结构都可以用 while 或者 do...while表示，但 Java 提供了另一种语句 —— for 循环，使一些循环结构变得更加简单。</p>
<p>for循环执行的次数是在执行前就确定的。语法格式如下：</p>
<pre><code class="language-java">for(初始化; 布尔表达式; 更新) {
    //代码语句
}
</code></pre>
<p>关于 for 循环有以下几点说明：</p>
<ul>
<li>最先执行初始化步骤。可以声明一种类型，但可初始化一个或多个循环控制变量，也可以是空语句。</li>
<li>然后，<strong>检测布尔表达式的值，该表达式的值只能是true或false</strong>。如果为 true，循环体被执行。如果为false，循环终止，开始执行循环体后面的语句。</li>
<li>执行一次循环后，更新循环控制变量。</li>
<li>再次检测布尔表达式。循环执行上面的过程。</li>
</ul>
<p>实例代码：</p>
<pre><code class="language-java">public class helloworld {
 
	public static void main(String[] args) {
		// TODO Auto-generated method stub
		
		for(int x = 10, y = 0; x &lt; 15; x = x+1, y++) {
	         System.out.println("value of x : " + x );
	         System.out.println("value of y : " + y );
	      }
	}
}
</code></pre>
<p>以上实例编译运行结果如下：</p>
<pre><code>value of x : 10
value of y : 0
value of x : 11
value of y : 1
value of x : 12
value of y : 2
value of x : 13
value of y : 3
value of x : 14
value of y : 4
</code></pre>
<p>下面这种写法为死循环：</p>
<pre><code class="language-java">for(;;)
{
	System.out.println("香水有毒！");
}
</code></pre>
<h3 id="java-增强-for-循环"><a class="header" href="#java-增强-for-循环">Java 增强 for 循环</a></h3>
<p>Java5 引入了一种主要用于数组的增强型 for 循环。</p>
<p>Java 增强 for 循环语法格式如下:</p>
<pre><code class="language-java">for(声明语句 : 表达式)
{
   //代码句子
}
</code></pre>
<p><strong>声明语句：</strong> 声明新的局部变量，该变量的类型必须和数组元素的类型匹配。其作用域限定在循环语句块，其值与此时数组元素的值相等。</p>
<p><strong>表达式：</strong> 表达式是要访问的数组名，或者是返回值为数组的方法。</p>
<p>实例：</p>
<pre><code class="language-java">public class helloworld {
 
	public static void main(String[] args) {
		// TODO Auto-generated method stub
		
		int [] numbers = {10, 20, 30, 40, 50};
		 
	    for(int x : numbers ){
	       System.out.print( x );
	       System.out.print(",");
	    }
	    System.out.print("\n");
	    String [] names ={"James", "Larry", "Tom", "Lacy"};
	    for( String name : names ) {
	       System.out.print( name );
	       System.out.print(",");
	    }
	}
}
</code></pre>
<p>以上实例编译运行结果如下：</p>
<pre><code>10,20,30,40,50,
James,Larry,Tom,Lacy,
</code></pre>
<h3 id="多重循环控制"><a class="header" href="#多重循环控制">多重循环控制</a></h3>
<p>练习：打印九九乘法表</p>
<pre><code class="language-java">package struct;

public class ForDemo2 {
    public static void main(String[] args) {
        for (int i = 1; i &lt; 10; i++) {
            for(int j =1; j&lt;=i;j++){
                System.out.print(""+j+'*'+i+'='+(i*j)+"\t");
            }
            System.out.println();
        }
    }
}
</code></pre>
<p>输出结果：</p>
<pre><code class="language-txt">1*1=1	
1*2=2	2*2=4	
1*3=3	2*3=6	3*3=9	
1*4=4	2*4=8	3*4=12	4*4=16	
1*5=5	2*5=10	3*5=15	4*5=20	5*5=25	
1*6=6	2*6=12	3*6=18	4*6=24	5*6=30	6*6=36	
1*7=7	2*7=14	3*7=21	4*7=28	5*7=35	6*7=42	7*7=49	
1*8=8	2*8=16	3*8=24	4*8=32	5*8=40	6*8=48	7*8=56	8*8=64	
1*9=9	2*9=18	3*9=27	4*9=36	5*9=45	6*9=54	7*9=63	8*9=72	9*9=81	
</code></pre>
<p>练习：输出三角形</p>
<pre><code class="language-java">public class helloworld {
 
	public static void main(String[] args) {
		// TODO Auto-generated method stub
		int n = 5;
		for(int i = 1; i &lt;= n; i++){  //i代表层数
			
			for(int j = 0; j &lt; n - i; j++){
				
				System.out.print(' ');
				
			}
			for(int j = 0; j &lt; 2 * i - 1; j++){ //每行打印2*i-1个*
							
				System.out.print('*');
					
			}
			System.out.print('\n');
		}
	}
}
</code></pre>
<p>输出结果：</p>
<pre><code class="language-txt">     *
    ***
   *****
  *******
 *********
</code></pre>
<p>练习：打印空心三角形</p>
<p>自己实现版本：</p>
<pre><code class="language-java">public class helloworld {
 
	public static void main(String[] args) {
		// TODO Auto-generated method stub
		int n = 5;
		for(int j = n; j &gt;= 2; j--){
			
			for(int i = 1; i &lt;= 2 * n; i++){
				
				if(i == j || i + j == 2 * n){
					System.out.print('*');
				}
				else {
					System.out.print(' ');
				}
			}
			System.out.print('\n');
		}
		for(int i = 0; i &lt; 2 * n - 1; i++) {
			System.out.print('*');
		}
	}
}
</code></pre>
<p>课堂版本：</p>
<pre><code class="language-java">public class helloworld {
 
	public static void main(String[] args) {
		// TODO Auto-generated method stub
		int n = 5;
		for(int i = 1; i &lt;= n; i++){  //i代表层数
			
			for(int j = 0; j &lt; n - i; j++){
				
				System.out.print(' ');
				
			}
			for(int j = 1; j &lt;= 2 * i - 1; j++){
							
				if(j == 1 || j == 2 * i - 1 || i == n) {
					System.out.print('*');
				}
				else {
					System.out.print(' ');
				}
					
			}
			System.out.print('\n');
		}
	}
}
</code></pre>
<p>输出结果：</p>
<pre><code>    *     
   * *    
  *   *   
 *     *  
*********
</code></pre>
<hr />
<h2 id="break-关键字"><a class="header" href="#break-关键字">break 关键字</a></h2>
<p>break 主要用在循环语句或者 switch 语句中，用来跳出整个语句块。</p>
<p>break 跳出最里层的循环，并且继续执行该循环下面的语句。</p>
<p><strong>break语句出现在多层嵌套的语句块中时，可以通过标签指定要终止的是哪一层语句块。但在开发中尽量不要使用标签，无标签时默认跳出最近的循环体。</strong></p>
<h3 id="语法"><a class="header" href="#语法">语法</a></h3>
<p>break 的用法很简单，就是循环结构中的一条语句：</p>
<pre><code>break;
</code></pre>
<p>实例Test.java 文件代码：</p>
<pre><code class="language-java">public class Test {
   public static void main(String[] args) {
      int [] numbers = {10, 20, 30, 40, 50};
 
      for(int x : numbers ) {
         // x 等于 30 时跳出循环
         if( x == 30 ) {
            break;
         }
         System.out.print( x );
         System.out.print("\n");
      }
   }
}
</code></pre>
<p>以上实例编译运行结果如下：</p>
<pre><code>10
20
</code></pre>
<p>使用标签的的循环体程序：</p>
<pre><code class="language-java">public class helloworld {
 
	public static void main(String[] args) {
		// TODO Auto-generated method stub
		int n = 10;
		label2222221:
		for(int i = 1; i &lt;= n; i++){  //i代表层数
			
			for(int j = 0; j &lt; n - i; j++){
				
				System.out.print(' ');
				
			}
			for(int j = 1; j &lt;= 2 * i - 1; j++){
							
				if(j == 1 || j == 2 * i - 1 || i == n) {
					System.out.print('*');
				}
				else {
					System.out.print(' ');
					break label2222221;
				}
					
			}
			System.out.print('\n');
		}
	}
}
</code></pre>
<hr />
<h2 id="continue-关键字"><a class="header" href="#continue-关键字">continue 关键字</a></h2>
<p>continue 适用于任何循环控制结构中。作用是让程序立刻跳转到下一次循环的迭代。</p>
<p>在 for 循环中，continue 语句使程序立即跳转到更新语句。</p>
<p>在 while 或者 do…while 循环中，程序立即跳转到布尔表达式的判断语句。</p>
<p><strong>continue语句出现在多层嵌套的语句块中时，可以通过标签指定要终止的是哪一层语句块。但在开发中尽量不要使用标签，无标签时默认再次进入最近的循环体。</strong></p>
<h3 id="语法-1"><a class="header" href="#语法-1">语法</a></h3>
<p>continue 就是循环体中一条简单的语句：</p>
<pre><code>continue;
</code></pre>
<p>实例Test.java 文件代码：</p>
<pre><code class="language-java">public class Test {
   public static void main(String[] args) {
      int [] numbers = {10, 20, 30, 40, 50};
 
      for(int x : numbers ) {
         if( x == 30 ) {
        continue;
         }
         System.out.print( x );
         System.out.print("\n");
      }
   }
}
</code></pre>
<p>以上实例编译运行结果如下：</p>
<pre><code>10
20
40
50
</code></pre>
<h2 id="return跳转控制语句"><a class="header" href="#return跳转控制语句">return跳转控制语句</a></h2>
<p>return能中止普通方法的执行，也能通过main方法终止程序的执行。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="数组"><a class="header" href="#数组">数组</a></h1>
<p>数组对于每一门编程语言来说都是重要的数据结构之一，当然不同语言对数组的实现及处理也不尽相同。</p>
<p>Java 语言中提供的数组是用来存储固定大小的同类型元素。</p>
<p>你可以声明一个数组变量，如 <code>numbers[100]</code> 来代替直接声明 100 个独立变量 number0，number1，....，number99。</p>
<p>本教程将为大家介绍 Java 数组的声明、创建和初始化，并给出其对应的代码。</p>
<hr />
<ul>
<li><a href="%E6%95%B0%E7%BB%84.html#%E5%A3%B0%E6%98%8E%E6%95%B0%E7%BB%84%E5%8F%98%E9%87%8F">声明数组变量</a></li>
<li><a href="%E6%95%B0%E7%BB%84.html#%E5%88%9B%E5%BB%BA%E6%95%B0%E7%BB%84">创建数组</a></li>
<li><a href="%E6%95%B0%E7%BB%84.html#%E5%A4%84%E7%90%86%E6%95%B0%E7%BB%84">处理数组</a></li>
<li><a href="%E6%95%B0%E7%BB%84.html#for-each-%E5%BE%AA%E7%8E%AF">For-Each 循环</a></li>
<li><a href="%E6%95%B0%E7%BB%84.html#%E6%95%B0%E7%BB%84%E4%BD%9C%E4%B8%BA%E5%87%BD%E6%95%B0%E7%9A%84%E5%8F%82%E6%95%B0">数组作为函数的参数</a></li>
<li><a href="%E6%95%B0%E7%BB%84.html#%E6%95%B0%E7%BB%84%E4%BD%9C%E4%B8%BA%E5%87%BD%E6%95%B0%E7%9A%84%E8%BF%94%E5%9B%9E%E5%80%BC">数组作为函数的返回值</a></li>
<li><a href="%E6%95%B0%E7%BB%84.html#%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84">多维数组</a>
<ul>
<li><a href="%E6%95%B0%E7%BB%84.html#%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E5%8A%A8%E6%80%81%E5%88%9D%E5%A7%8B%E5%8C%96%E4%BB%A5%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%BA%E4%BE%8B">多维数组的动态初始化（以二维数组为例）</a></li>
<li><a href="%E6%95%B0%E7%BB%84.html#%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E5%BC%95%E7%94%A8%E4%BB%A5%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%BA%E4%BE%8B">多维数组的引用（以二维数组为例）</a></li>
</ul>
</li>
<li><a href="%E6%95%B0%E7%BB%84.html#arrays-%E7%B1%BB">Arrays 类</a></li>
</ul>
<h2 id="声明数组变量"><a class="header" href="#声明数组变量">声明数组变量</a></h2>
<p>首先必须声明数组变量，才能在程序中使用数组。下面是声明数组变量的语法：</p>
<pre><code class="language-java">dataType[] arrayRefVar;   // 首选的方法
 
或
 
dataType arrayRefVar[];  // 效果相同，但不是首选方法
</code></pre>
<p><strong>注意:</strong> 建议使用 <strong>dataType[] arrayRefVar</strong> 的声明风格声明数组变量。 dataType arrayRefVar[] 风格是来自 C/C++ 语言 ，在Java中采用是为了让 C/C++ 程序员能够快速理解java语言。</p>
<p>下面是这两种语法的代码示例：</p>
<pre><code class="language-java">double[] myList;         // 首选的方法
 
或
 
double myList[];         //  效果相同，但不是首选方法
</code></pre>
<hr />
<h2 id="创建数组"><a class="header" href="#创建数组">创建数组</a></h2>
<p>Java语言使用new操作符来创建数组，语法如下：</p>
<pre><code class="language-java">arrayRefVar = new dataType[arraySize];
</code></pre>
<p>上面的语法语句做了两件事：</p>
<ul>
<li>一、使用 <code>dataType[arraySize]</code> 创建了一个数组。</li>
<li>二、把新创建的数组的引用赋值给变量 arrayRefVar。</li>
</ul>
<p>数组变量的声明，和创建数组可以用一条语句完成，如下所示：</p>
<pre><code class="language-java">dataType[] arrayRefVar = new dataType[arraySize];
</code></pre>
<p>另外，你还可以使用如下的方式创建数组。</p>
<pre><code class="language-java">dataType[] arrayRefVar = {value0, value1, ..., valuek};
</code></pre>
<p><strong>数组中的元素可以是任何数据类型，包括基本类型和引用类型，但是不能混用。</strong></p>
<p>数组创建后如果没有赋值，有默认值：</p>
<p>int 0，short 0，byte 0，long 0，float 0.0， double 0.0，char <code>\u0000</code>，
boolean false， String null</p>
<p>数组的元素是通过索引访问的。数组索引从 0 开始，所以索引值从 0 到 arrayRefVar.length-1。</p>
<p>下面的语句首先声明了一个数组变量 myList，接着创建了一个包含 10 个 double 类型元素的数组，并且把它的引用赋值给 myList 变量。</p>
<pre><code class="language-java">public class TestArray {
   public static void main(String[] args) {
      // 数组大小
      int size = 10;
      // 定义数组
      double[] myList = new double[size];
      myList[0] = 5.6;
      myList[1] = 4.5;
      myList[2] = 3.3;
      myList[3] = 13.2;
      myList[4] = 4.0;
      myList[5] = 34.33;
      myList[6] = 34.0;
      myList[7] = 45.45;
      myList[8] = 99.993;
      myList[9] = 11123;
      // 计算所有元素的总和
      double total = 0;
      for (int i = 0; i &lt; size; i++) {
         total += myList[i];
      }
      System.out.println("总和为： " + total);
   }
}
</code></pre>
<p>以上实例输出结果为：</p>
<pre><code>总和为： 11367.373
</code></pre>
<p>下面的图片描绘了数组 myList。这里 myList 数组里有 10 个 double 元素，它的下标从 0 到 9。</p>
<p><img src="https://www.runoob.com/wp-content/uploads/2013/12/12-130Q0221Q5602.jpg" alt="java数组结构说明" /></p>
<hr />
<h2 id="处理数组"><a class="header" href="#处理数组">处理数组</a></h2>
<p><strong>数组赋值机制：数组在默认情况下是引用传递（地址传递）而不是值传递，赋的值是地址</strong></p>
<pre><code class="language-java">public class helloworld {
 
	public static void main(String[] args) {
		// TODO Auto-generated method stub
		int[] arr1 = {1,2,3,4};
		int[] arr2 = arr1;
		arr1[2] = 6;
		for(int i = 0; i &lt; arr2.length; i++) {
			System.out.println(arr2[i]);
		}
	}
}

</code></pre>
<p>输出结果如下：</p>
<pre><code>1
2
6
4
</code></pre>
<p>数组的元素类型和数组的大小都是确定的，所以当处理数组元素时候，我们通常使用基本循环或者 For-Each 循环。</p>
<p>该实例完整地展示了如何创建、初始化和操纵数组：</p>
<pre><code class="language-java">public class TestArray {
   public static void main(String[] args) {
      double[] myList = {1.9, 2.9, 3.4, 3.5};
 
      // 打印所有数组元素
      for (int i = 0; i &lt; myList.length; i++) {
         System.out.println(myList[i] + " ");
      }
      // 计算所有元素的总和
      double total = 0;
      for (int i = 0; i &lt; myList.length; i++) {
         total += myList[i];
      }
      System.out.println("Total is " + total);
      // 查找最大元素
      double max = myList[0];
      for (int i = 1; i &lt; myList.length; i++) {
         if (myList[i] &gt; max) max = myList[i];
      }
      System.out.println("Max is " + max);
   }
}
</code></pre>
<p>以上实例编译运行结果如下：</p>
<pre><code>1.9
2.9
3.4
3.5
Total is 11.7
Max is 3.5
</code></pre>
<hr />
<h2 id="for-each-循环"><a class="header" href="#for-each-循环">For-Each 循环</a></h2>
<p>JDK 1.5 引进了一种新的循环类型，被称为 For-Each 循环或者加强型循环，它能在不使用下标的情况下遍历数组。</p>
<p>语法格式如下：</p>
<pre><code class="language-java">for(type element: array)
{
    System.out.println(element);
}
</code></pre>
<p>该实例用来显示数组 myList 中的所有元素：</p>
<pre><code class="language-java">public class TestArray {
   public static void main(String[] args) {
      double[] myList = {1.9, 2.9, 3.4, 3.5};
 
      // 打印所有数组元素
      for (double element: myList) {
         System.out.println(element);
      }
   }
}
</code></pre>
<p>以上实例编译运行结果如下：</p>
<pre><code>1.9
2.9
3.4
3.5
</code></pre>
<hr />
<h2 id="数组作为函数的参数"><a class="header" href="#数组作为函数的参数">数组作为函数的参数</a></h2>
<p>数组可以作为参数传递给方法。</p>
<p>例如，下面的例子就是一个打印 int 数组中元素的方法:</p>
<pre><code class="language-java">public static void printArray(int[] array) {
  for (int i = 0; i &lt; array.length; i++) {
    System.out.print(array[i] + " ");
  }
}
</code></pre>
<p>下面例子调用 printArray 方法打印出 3，1，2，6，4 和 2：</p>
<pre><code class="language-java">printArray(new int[]{3, 1, 2, 6, 4, 2});
</code></pre>
<hr />
<h2 id="数组作为函数的返回值"><a class="header" href="#数组作为函数的返回值">数组作为函数的返回值</a></h2>
<pre><code class="language-java">public static int[] reverse(int[] list) {
  int[] result = new int[list.length];
 
  for (int i = 0, j = result.length - 1; i &lt; list.length; i++, j--) {
    result[j] = list[i];
  }
  return result;
}
</code></pre>
<p>以上实例中 result 数组作为函数的返回值。</p>
<hr />
<h2 id="多维数组"><a class="header" href="#多维数组">多维数组</a></h2>
<p>多维数组可以看成是数组的数组，比如二维数组就是一个特殊的一维数组，其每一个元素都是一个一维数组，例如：</p>
<pre><code class="language-java">String[][] str = new String[3][4];
</code></pre>
<p>二维数组的声明形式有如下三种：<code>int[][] y;</code>、<code>int[] y[];</code>、<code>int y[][];</code></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost03/img/202401151546762.png" alt="" /></p>
<p>这种赋值方式<code>String[] strs = new String[]{"a", "b", "c"};</code>也是允许的。</p>
<h3 id="多维数组的动态初始化以二维数组为例"><a class="header" href="#多维数组的动态初始化以二维数组为例">多维数组的动态初始化（以二维数组为例）</a></h3>
<ol>
<li>直接为每一维分配空间，格式如下：</li>
</ol>
<pre><code class="language-java">type[][] typeName = new type[typeLength1][typeLength2];
</code></pre>
<p>type 可以为基本数据类型和复合数据类型，typeLength1 和 typeLength2 必须为正整数，typeLength1 为行数，typeLength2 为列数。</p>
<p>例如：</p>
<pre><code class="language-java">int[][] a = new int[2][3];
</code></pre>
<p>解析：</p>
<p>二维数组 a 可以看成一个两行三列的数组。</p>
<ol start="2">
<li>从最高维开始，分别为每一维分配空间，例如：</li>
</ol>
<pre><code class="language-java">String[][] s = new String[2][];
s[0] = new String[2];
s[1] = new String[3];
s[0][0] = new String("Good");
s[0][1] = new String("Luck");
s[1][0] = new String("to");
s[1][1] = new String("you");
s[1][2] = new String("!");
</code></pre>
<p>解析：</p>
<p><strong><code>s[0]=new String[2]** 和 **s[1]=new String[3]</code></strong> 是为最高维分配引用空间，也就是为最高维限制其能保存数据的最长的长度，然后再为其每个数组元素单独分配空间 <strong>s0=new String("Good")</strong> 等操作。</p>
<p>实例：</p>
<pre><code class="language-java">public class helloworld {
 
	public static void main(String[] args) {
		// TODO Auto-generated method stub
		int[][] a = new int[2][3];
		int k = 1;
		for(int i = 0; i &lt; a.length; i++) {
			for(int j = 0; j &lt; a[i].length; j += 2) {
				a[i][j] = k++;
			}
		}
		for(int i = 0; i &lt; a.length; i++) {
			for(int j = 0; j &lt; a[i].length; j++) {
				System.out.print(a[i][j] + " ");
			}
			System.out.print('\n');
		}
		int[][] b = {{1}, {1,2,3}};
		for(int i = 0; i &lt; b.length; i++) {
			for(int j = 0; j &lt; b[i].length; j++) {
				System.out.print(b[i][j] + " ");
			}
			System.out.println();
		}
		int n = 10;
		int[][] c = new int[n][];
		for(int i = 0; i &lt; c.length; i++) {
			c[i] = new int[i + 1];
			for(int j = 0; j &lt; c[i].length; j++) {
				if(j == 0 || j == c[i].length - 1) {
					c[i][j] = 1;
				}else {
					c[i][j] = c[i - 1][j - 1] + c[i - 1][j];
				}
			}
		}
		for(int i = 0; i &lt; c.length; i++) {
			for(int j = 0; j &lt; c[i].length; j++) {
				System.out.print(c[i][j] + "\t");
			}
			System.out.println();
		}
	}
	
}
</code></pre>
<p>输出结果如下：</p>
<pre><code>1 0 2 
3 0 4 
1 
1 2 3 
1	
1	1	
1	2	1	
1	3	3	1	
1	4	6	4	1	
1	5	10	10	5	1	
1	6	15	20	15	6	1	
1	7	21	35	35	21	7	1	
1	8	28	56	70	56	28	8	1	
1	9	36	84	126	126	84	36	9	1
</code></pre>
<p>注意：二维数组中可以省略部分元素</p>
<h3 id="多维数组的引用以二维数组为例"><a class="header" href="#多维数组的引用以二维数组为例">多维数组的引用（以二维数组为例）</a></h3>
<p>对二维数组中的每个元素，引用方式为 <strong><code>arrayName[index1][index2]</code></strong>，例如：</p>
<pre><code class="language-java">num[1][0];
</code></pre>
<hr />
<h2 id="arrays-类"><a class="header" href="#arrays-类">Arrays 类</a></h2>
<p>java.util.Arrays 类能方便地操作数组，它提供的所有方法都是静态的。</p>
<p>具有以下功能：</p>
<ul>
<li>给数组赋值：通过 fill 方法。</li>
<li>对数组排序：通过 sort 方法,按升序。</li>
<li>比较数组：通过 equals 方法比较数组中元素值是否相等。</li>
<li>查找数组元素：通过 binarySearch 方法能对排序好的数组进行二分查找法操作。</li>
</ul>
<p>具体说明请查看下表：</p>
<div class="table-wrapper"><table><thead><tr><th>序号</th><th>方法和说明</th></tr></thead><tbody>
<tr><td>1</td><td><strong>public static int binarySearch(Object[] a, Object key)</strong>  <br>用二分查找算法在给定数组中搜索给定值的对象(Byte,Int,double等)。数组在调用前必须排序好的。如果查找值包含在数组中，则返回搜索键的索引；否则返回 (-(<em>插入点</em>) - 1)。</td></tr>
<tr><td>2</td><td><strong>public static boolean equals(long[] a, long[] a2)</strong>  <br>如果两个指定的 long 型数组彼此_相等_，则返回 true。如果两个数组包含相同数量的元素，并且两个数组中的所有相应元素对都是相等的，则认为这两个数组是相等的。换句话说，如果两个数组以相同顺序包含相同的元素，则两个数组是相等的。同样的方法适用于所有的其他基本数据类型（Byte，short，Int等）。</td></tr>
<tr><td>3</td><td><strong>public static void fill(int[] a, int val)</strong>  <br>将指定的 int 值分配给指定 int 型数组指定范围中的每个元素。同样的方法适用于所有的其他基本数据类型（Byte，short，Int等）。</td></tr>
<tr><td>4</td><td><strong>public static void sort(Object[] a)</strong>  <br>对指定对象数组根据其元素的自然顺序进行升序排列。同样的方法适用于所有的其他基本数据类型（Byte，short，Int等）。</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="异常处理"><a class="header" href="#异常处理">异常处理</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="函数理论"><a class="header" href="#函数理论">函数理论</a></h1>
<ul>
<li><a href="%E5%87%BD%E6%95%B0%E7%90%86%E8%AE%BA.html#%E6%96%B9%E6%B3%95%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E8%B0%83%E7%94%A8">方法的定义和调用</a>
<ul>
<li><a href="%E5%87%BD%E6%95%B0%E7%90%86%E8%AE%BA.html#%E6%96%B9%E6%B3%95%E7%9A%84%E4%BC%98%E7%82%B9">方法的优点</a></li>
<li><a href="%E5%87%BD%E6%95%B0%E7%90%86%E8%AE%BA.html#%E6%96%B9%E6%B3%95%E7%9A%84%E5%91%BD%E5%90%8D%E8%A7%84%E5%88%99">方法的命名规则</a></li>
<li><a href="%E5%87%BD%E6%95%B0%E7%90%86%E8%AE%BA.html#%E6%96%B9%E6%B3%95%E7%9A%84%E5%AE%9A%E4%B9%89">方法的定义</a>
<ul>
<li><a href="%E5%87%BD%E6%95%B0%E7%90%86%E8%AE%BA.html#%E5%AE%9E%E4%BE%8B">实例</a></li>
</ul>
</li>
<li><a href="%E5%87%BD%E6%95%B0%E7%90%86%E8%AE%BA.html#%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8">方法调用</a>
<ul>
<li><a href="%E5%87%BD%E6%95%B0%E7%90%86%E8%AE%BA.html#%E5%AE%9E%E4%BE%8B-1">实例</a></li>
</ul>
</li>
<li><a href="%E5%87%BD%E6%95%B0%E7%90%86%E8%AE%BA.html#void-%E5%85%B3%E9%94%AE%E5%AD%97">void 关键字</a>
<ul>
<li><a href="%E5%87%BD%E6%95%B0%E7%90%86%E8%AE%BA.html#%E7%A4%BA%E4%BE%8B">示例</a></li>
</ul>
</li>
<li><a href="%E5%87%BD%E6%95%B0%E7%90%86%E8%AE%BA.html#%E9%80%9A%E8%BF%87%E5%80%BC%E4%BC%A0%E9%80%92%E5%8F%82%E6%95%B0">通过值传递参数</a>
<ul>
<li><a href="%E5%87%BD%E6%95%B0%E7%90%86%E8%AE%BA.html#%E7%A4%BA%E4%BE%8B-1">示例</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="%E5%87%BD%E6%95%B0%E7%90%86%E8%AE%BA.html#%E6%96%B9%E6%B3%95%E9%87%8D%E8%BD%BD">方法重载</a></li>
<li><a href="%E5%87%BD%E6%95%B0%E7%90%86%E8%AE%BA.html#%E5%8F%98%E9%87%8F%E4%BD%9C%E7%94%A8%E5%9F%9F">变量作用域</a></li>
<li><a href="%E5%87%BD%E6%95%B0%E7%90%86%E8%AE%BA.html#%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%BC%A0%E5%8F%82">命令行传参</a>
<ul>
<li><a href="%E5%87%BD%E6%95%B0%E7%90%86%E8%AE%BA.html#%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95">构造方法</a>
<ul>
<li><a href="%E5%87%BD%E6%95%B0%E7%90%86%E8%AE%BA.html#%E5%AE%9E%E4%BE%8B-2">实例</a></li>
<li><a href="%E5%87%BD%E6%95%B0%E7%90%86%E8%AE%BA.html#%E5%AE%9E%E4%BE%8B-3">实例</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="%E5%87%BD%E6%95%B0%E7%90%86%E8%AE%BA.html#%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0">可变参数</a>
<ul>
<li><a href="%E5%87%BD%E6%95%B0%E7%90%86%E8%AE%BA.html#%E5%AE%9E%E4%BE%8B-4">实例</a></li>
</ul>
</li>
<li><a href="%E5%87%BD%E6%95%B0%E7%90%86%E8%AE%BA.html#%E9%80%92%E5%BD%92">递归</a>
<ul>
<li><a href="%E5%87%BD%E6%95%B0%E7%90%86%E8%AE%BA.html#finalize-%E6%96%B9%E6%B3%95">finalize() 方法</a>
<ul>
<li><a href="%E5%87%BD%E6%95%B0%E7%90%86%E8%AE%BA.html#%E5%AE%9E%E4%BE%8B-5">实例</a></li>
<li><a href="%E5%87%BD%E6%95%B0%E7%90%86%E8%AE%BA.html#stringbuilder%E7%B1%BB">StringBuilder类</a></li>
<li><a href="%E5%87%BD%E6%95%B0%E7%90%86%E8%AE%BA.html#%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E6%97%A0%E6%B3%95%E8%B0%83%E7%94%A8%E8%87%AA%E5%B7%B1%E5%AE%9A%E4%B9%89%E7%9A%84%E9%9D%9E%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95">静态方法无法调用自己定义的非静态方法</a></li>
<li><a href="%E5%87%BD%E6%95%B0%E7%90%86%E8%AE%BA.html#%E9%80%92%E5%BD%92%E5%AE%9E%E8%B7%B5">递归实践</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="方法的定义和调用"><a class="header" href="#方法的定义和调用">方法的定义和调用</a></h1>
<p>Java方法是语句的集合，它们在一起执行一个功能。</p>
<ul>
<li>方法是解决一类问题的步骤的有序组合</li>
<li>方法包含于类或对象中</li>
<li>方法在程序中被创建，在其他地方被引用</li>
</ul>
<h3 id="方法的优点"><a class="header" href="#方法的优点">方法的优点</a></h3>
<ul>
<li>
<ol>
<li>使程序变得更简短而清晰。</li>
</ol>
</li>
<li>
<ol start="2">
<li>有利于程序维护。</li>
</ol>
</li>
<li>
<ol start="3">
<li>可以提高程序开发的效率。</li>
</ol>
</li>
<li>
<ol start="4">
<li>提高了代码的重用性。</li>
</ol>
</li>
</ul>
<h3 id="方法的命名规则"><a class="header" href="#方法的命名规则">方法的命名规则</a></h3>
<p>1.方法的名字的第一个单词应以小写字母作为开头，后面的单词则用大写字母开头写，不使用连接符。例如：<strong>addPerson</strong>。</p>
<p>2.下划线可能出现在 JUnit 测试方法名称中用以分隔名称的逻辑组件。一个典型的模式是：<strong>test<MethodUnderTest>_<state></strong>，例如 <strong>testPop_emptyStack</strong>。</p>
<h2 id="方法的定义"><a class="header" href="#方法的定义">方法的定义</a></h2>
<p>一般情况下，定义一个方法包含以下语法：</p>
<pre><code class="language-java">修饰符 返回值类型 方法名(参数类型 参数名){
    ...
    方法体
    ...
    return 返回值;
}
</code></pre>
<p>方法包含一个方法头和一个方法体。下面是一个方法的所有部分：</p>
<ul>
<li>**修饰符：**修饰符，这是可选的，告诉编译器如何调用该方法。定义了该方法的访问类型。</li>
<li><strong>返回值类型 ：<strong>方法可能会返回值。returnValueType 是方法返回值的数据类型。有些方法执行所需的操作，但没有返回值。在这种情况下，returnValueType 是关键字</strong>void</strong>。</li>
<li>**方法名：**是方法的实际名称。方法名和参数表共同构成方法签名。</li>
<li>**参数类型：**参数像是一个占位符。当方法被调用时，传递值给参数。这个值被称为实参或变量。参数列表是指方法的参数类型、顺序和参数的个数。参数是可选的，方法可以不包含任何参数。</li>
<li>**方法体：**方法体包含具体的语句，定义该方法的功能。</li>
</ul>
<p><img src="https://www.runoob.com/wp-content/uploads/2013/12/D53C92B3-9643-4871-8A72-33D491299653.jpg" alt="img" /></p>
<p>如：</p>
<pre><code class="language-java">public static int age(int birthday){...}
</code></pre>
<p>参数可以有多个：</p>
<pre><code class="language-java">static float interest(float principal, int year){...}
</code></pre>
<p><strong>注意：</strong> 在一些其它语言中方法指过程和函数。一个返回非void类型返回值的方法称为函数；一个返回void类型返回值的方法叫做过程。</p>
<h3 id="实例"><a class="header" href="#实例">实例</a></h3>
<p>下面的方法包含 2 个参数 num1 和 num2，它返回这两个参数的最大值。</p>
<pre><code class="language-java">/** 返回两个整型变量数据的较大值 */
public static int max(int num1, int num2) {
   int result;
   if (num1 &gt; num2)
      result = num1;
   else
      result = num2;
 
   return result; 
}
</code></pre>
<p>更简略的写法（三元运算符）：</p>
<pre><code class="language-java">public static int max(int num1, int num2) {
  return num1 &gt; num2 ? num1 : num2;
}
</code></pre>
<p>练习：加法函数</p>
<pre><code class="language-java">package method;

public class Demo1 {
    public static void main(String[] args) {
        //实参，实际调用
        int sum = add(1,2);
        System.out.println(sum);
    }
    //形参，用来定义作用
    public static int add(int a, int b){
        return a+b;
    }
}

</code></pre>
<p>return 0;可以终止函数执行</p>
<h2 id="方法调用"><a class="header" href="#方法调用">方法调用</a></h2>
<p>Java 支持两种调用方法的方式，根据方法是否返回值来选择。</p>
<p>当程序调用一个方法时，程序的控制权交给了被调用的方法。当被调用方法的返回语句执行或者到达方法体闭括号时候交还控制权给程序。</p>
<p>当方法返回一个值的时候，方法调用通常被当做一个值。例如：</p>
<pre><code class="language-java">int larger = max(30, 40);
</code></pre>
<p>如果方法返回值是void，方法调用一定是一条语句。例如，方法println返回void。下面的调用是个语句：</p>
<pre><code class="language-java">System.out.println("欢迎访问菜鸟教程！");
</code></pre>
<h3 id="实例-1"><a class="header" href="#实例-1">实例</a></h3>
<p>下面的例子演示了如何定义一个方法，以及如何调用它。TestMax.java 文件代码：</p>
<pre><code class="language-java">public class TestMax {
   /** 主方法 */
   public static void main(String[] args) {
      int i = 5;
      int j = 2;
      int k = max(i, j);
      System.out.println( i + " 和 " + j + " 比较，最大值是：" + k);
   }
 
   /** 返回两个整数变量较大的值 */
   public static int max(int num1, int num2) {
      int result;
      if (num1 &gt; num2)
         result = num1;
      else
         result = num2;
 
      return result; 
   }
}
</code></pre>
<p>以上实例编译运行结果如下：</p>
<pre><code>5 和 2 比较，最大值是：5
</code></pre>
<p>这个程序包含 main 方法和 max 方法。main 方法是被 JVM 调用的，除此之外，main 方法和其它方法没什么区别。</p>
<p>main 方法的头部是不变的，如例子所示，带修饰符 public 和 static,返回 void 类型值，方法名字是 main,此外带个一个 String[] 类型参数。String[] 表明参数是字符串数组。</p>
<h2 id="void-关键字"><a class="header" href="#void-关键字">void 关键字</a></h2>
<p>本节说明如何声明和调用一个 void 方法。</p>
<p>下面的例子声明了一个名为 printGrade 的方法，并且调用它来打印给定的分数。</p>
<h3 id="示例"><a class="header" href="#示例">示例</a></h3>
<p>TestVoidMethod.java 文件代码：</p>
<pre><code class="language-java">public class TestVoidMethod {
  public static void main(String[] args) {
    printGrade(78.5);
  }
 
  public static void printGrade(double score) {
    if (score &gt;= 90.0) {
       System.out.println('A');
    }
    else if (score &gt;= 80.0) {
       System.out.println('B');
    }
    else if (score &gt;= 70.0) {
       System.out.println('C');
    }
    else if (score &gt;= 60.0) {
       System.out.println('D');
    }
    else {
       System.out.println('F');
    }
  }
}
</code></pre>
<p>以上实例编译运行结果如下：</p>
<pre><code>C
</code></pre>
<p>这里printGrade方法是一个void类型方法，它不返回值。</p>
<p>一个void方法的调用一定是一个语句。 所以，它被在main方法第三行以语句形式调用。就像任何以分号结束的语句一样。</p>
<h2 id="通过值传递参数"><a class="header" href="#通过值传递参数">通过值传递参数</a></h2>
<p>调用一个方法时候需要提供参数，你必须按照参数列表指定的顺序提供。</p>
<p>例如，下面的方法连续n次打印一个消息：</p>
<p>TestVoidMethod.java 文件代码：</p>
<pre><code class="language-java">public static void nPrintln(String message, int n) {
  for (int i = 0; i &lt; n; i++) {
    System.out.println(message);
  }
}
</code></pre>
<h3 id="示例-1"><a class="header" href="#示例-1">示例</a></h3>
<p>下面的例子演示按值传递的效果。</p>
<p>该程序创建一个方法，该方法用于交换两个变量。</p>
<p>TestPassByValue.java 文件代码：</p>
<pre><code class="language-java">public class TestPassByValue {
  public static void main(String[] args) {
    int num1 = 1;
    int num2 = 2;
 
    System.out.println("交换前 num1 的值为：" +
                        num1 + " ，num2 的值为：" + num2);
 
    // 调用swap方法
    swap(num1, num2);
    System.out.println("交换后 num1 的值为：" +
                       num1 + " ，num2 的值为：" + num2);
  }
  /** 交换两个变量的方法 */
  public static void swap(int n1, int n2) {
    System.out.println("\t进入 swap 方法");
    System.out.println("\t\t交换前 n1 的值为：" + n1
                         + "，n2 的值：" + n2);
    // 交换 n1 与 n2的值
    int temp = n1;
    n1 = n2;
    n2 = temp;
 
    System.out.println("\t\t交换后 n1 的值为 " + n1
                         + "，n2 的值：" + n2);
  }
}
</code></pre>
<p>以上实例编译运行结果如下：</p>
<pre><code>交换前 num1 的值为：1 ，num2 的值为：2
    进入 swap 方法
        交换前 n1 的值为：1，n2 的值：2
        交换后 n1 的值为 2，n2 的值：1
交换后 num1 的值为：1 ，num2 的值为：2
</code></pre>
<p>传递两个参数调用swap方法。有趣的是，方法被调用后，实参的值并没有改变。</p>
<h1 id="方法重载"><a class="header" href="#方法重载">方法重载</a></h1>
<p>方法重载：同一个类中方法名字相同，而形式参数不同</p>
<p>原理：编译器逐个匹配</p>
<p>原则：</p>
<ul>
<li>方法名必须相同</li>
<li>参数列表必须不同，如个数不同，类型不同，参数排列顺序不同等</li>
<li>方法的返回类型可以相同也可以不同</li>
<li>仅仅返回类型不同不足以成为方法重载</li>
</ul>
<p>上面使用的max方法仅仅适用于int型数据。但如果你想得到两个浮点类型数据的最大值呢？</p>
<p>解决方法是创建另一个有相同名字但参数不同的方法，如下面代码所示：</p>
<pre><code class="language-java">public static double max(double num1, double num2) {  if (num1 &gt; num2)    return num1;  else    return num2; }
</code></pre>
<p>如果你调用max方法时传递的是int型参数，则 int型参数的max方法就会被调用；</p>
<p>如果传递的是double型参数，则double类型的max方法体会被调用，这叫做方法重载；</p>
<p>就是说一个类的两个方法拥有相同的名字，但是有不同的参数列表。</p>
<p>Java编译器根据方法签名判断哪个方法应该被调用。</p>
<p>方法重载可以让程序更清晰易读。执行密切相关任务的方法应该使用相同的名字。</p>
<p>重载的方法必须拥有不同的参数列表。你不能仅仅依据修饰符或者返回类型的不同来重载方法。</p>
<h1 id="变量作用域"><a class="header" href="#变量作用域">变量作用域</a></h1>
<p>变量的范围是程序中该变量可以被引用的部分。</p>
<p>方法内定义的变量被称为局部变量。</p>
<p>局部变量的作用范围从声明开始，直到包含它的块结束。</p>
<p>局部变量必须声明才可以使用。</p>
<p>方法的参数范围涵盖整个方法。参数实际上是一个局部变量。</p>
<p>for循环的初始化部分声明的变量，其作用范围在整个循环。</p>
<p>但循环体内声明的变量其适用范围是从它声明到循环体结束。它包含如下所示的变量声明：</p>
<p><img src="https://www.runoob.com/wp-content/uploads/2013/12/12-130Q1221013F0.jpg" alt="img" /></p>
<p>你可以在一个方法里，不同的非嵌套块中多次声明一个具有相同的名称局部变量，但你不能在嵌套块内两次声明局部变量。</p>
<h1 id="命令行传参"><a class="header" href="#命令行传参">命令行传参</a></h1>
<p>程序运行时再传参如Demo2.java</p>
<pre><code class="language-java">package method;

public class Demo2 {
    public static void main(String[] args) {
        //args.length数组长度
        for (int i = 0; i &lt; args.length; i++) {
            System.out.println("args["+i+"]: "+args[i]);
        }
    }
}
</code></pre>
<p>执行命令行</p>
<pre><code class="language-shell">javac Demo2.java

java method.Demo2 this is RM
</code></pre>
<p>输出结果：</p>
<pre><code class="language-txt">args[0命令行]: this
args[1]: is
args[2]: RM
</code></pre>
<h2 id="构造方法"><a class="header" href="#构造方法">构造方法</a></h2>
<p>当一个对象被创建时候，构造方法用来初始化该对象。构造方法和它所在类的名字相同，但构造方法没有返回值。</p>
<p>通常会使用构造方法给一个类的实例变量赋初值，或者执行其它必要的步骤来创建一个完整的对象。</p>
<p>不管你是否自定义构造方法，所有的类都有构造方法，因为 Java 自动提供了一个默认构造方法，默认构造方法的访问修饰符和类的访问修饰符相同(类为 public，构造函数也为 public；类改为 protected，构造函数也改为 protected)。</p>
<p>一旦你定义了自己的构造方法，默认构造方法就会失效。</p>
<h3 id="实例-2"><a class="header" href="#实例-2">实例</a></h3>
<p>下面是一个使用构造方法的例子：</p>
<pre><code class="language-java">// 一个简单的构造函数
class MyClass {
  int x;
 
  // 以下是构造函数
  MyClass() {
    x = 10;
  }
}
</code></pre>
<p>你可以像下面这样调用构造方法来初始化一个对象：</p>
<p>ConsDemo.java 文件代码：</p>
<pre><code class="language-java">public class ConsDemo {
   public static void main(String args[]) {
      MyClass t1 = new MyClass();
      MyClass t2 = new MyClass();
      System.out.println(t1.x + " " + t2.x);
   }
}
</code></pre>
<p>大多时候需要一个有参数的构造方法。</p>
<h3 id="实例-3"><a class="header" href="#实例-3">实例</a></h3>
<p>下面是一个使用构造方法的例子：</p>
<pre><code class="language-java">// 一个简单的构造函数
class MyClass {
  int x;
 
  // 以下是构造函数
  MyClass(int i ) {
    x = i;
  }
}
</code></pre>
<p>你可以像下面这样调用构造方法来初始化一个对象：</p>
<p>ConsDemo.java 文件代码：</p>
<pre><code class="language-java">public class ConsDemo {
  public static void main(String args[]) {
    MyClass t1 = new MyClass( 10 );
    MyClass t2 = new MyClass( 20 );
    System.out.println(t1.x + " " + t2.x);
  }
}
</code></pre>
<p>运行结果如下：</p>
<pre><code>10 20
</code></pre>
<h1 id="可变参数"><a class="header" href="#可变参数">可变参数</a></h1>
<p>JDK 1.5 开始，Java支持传递同类型的可变参数给一个方法。</p>
<p>方法的可变参数的声明如下所示：</p>
<p><code>typeName... parameterName</code></p>
<p>在方法声明中，在指定参数类型后加一个省略号(...) 。</p>
<p>一个方法中只能指定一个可变参数，它必须是方法的最后一个参数。任何普通的参数必须在它之前声明。</p>
<h3 id="实例-4"><a class="header" href="#实例-4">实例</a></h3>
<p>Demo3.java</p>
<pre><code class="language-java">package method;

public class Demo3 {
    public static void main(String[] args) {
        Demo3 demo3 = new Demo3();
        demo3.test(1,2,3,4,5);
    }
    public void test(int... i){
        System.out.println(i[0]);
    }
}
</code></pre>
<p>输出结果为1</p>
<p>VarargsDemo.java 文件代码：</p>
<pre><code class="language-java">public class VarargsDemo {
    public static void main(String args[]) {
        // 调用可变参数的方法
        printMax(34, 3, 3, 2, 56.5);
        printMax(new double[]{1, 2, 3});
    }
 
    public static void printMax( double... numbers) {
        if (numbers.length == 0) {
            System.out.println("No argument passed");
            return;
        }
 
        double result = numbers[0];
 
        for (int i = 1; i &lt;  numbers.length; i++){
            if (numbers[i] &gt;  result) {
                result = numbers[i];
            }
        }
        System.out.println("The max value is " + result);
    }
}
</code></pre>
<p>以上实例编译运行结果如下：</p>
<pre><code>The max value is 56.5
The max value is 3.0
</code></pre>
<h1 id="递归"><a class="header" href="#递归">递归</a></h1>
<p>必须有终止条件！！！</p>
<pre><code class="language-java">package method;

public class Demo4 {
    public static void main(String[] args) {
        Demo4 demo4 = new Demo4();

        int num = 5;
        int result = demo4.factorial(num);
        System.out.println(result);
    }
    public int factorial(int i){
        if(i==0){
            return 1;
        }else {
            return factorial(i-1)*i;
        }

    }
}
</code></pre>
<p>输出结果120</p>
<h2 id="finalize-方法"><a class="header" href="#finalize-方法">finalize() 方法</a></h2>
<p>Java 允许定义这样的方法，它在对象被垃圾收集器析构(回收)之前调用，这个方法叫做 finalize( )，它用来清除回收对象。</p>
<p>例如，你可以使用 finalize() 来确保一个对象打开的文件被关闭了。</p>
<p>在 finalize() 方法里，你必须指定在对象销毁时候要执行的操作。</p>
<p>finalize() 一般格式是：</p>
<pre><code class="language-java">protected void finalize()
{
   // 在这里终结代码
}
</code></pre>
<p>关键字 protected 是一个限定符，它确保 finalize() 方法不会被该类以外的代码调用。</p>
<p>当然，Java 的内存回收可以由 JVM 来自动完成。如果你手动使用，则可以使用上面的方法。</p>
<h3 id="实例-5"><a class="header" href="#实例-5">实例</a></h3>
<p>FinalizationDemo.java 文件代码：</p>
<pre><code class="language-java">public class FinalizationDemo {  
  public static void main(String[] args) {  
    Cake c1 = new Cake(1);  
    Cake c2 = new Cake(2);  
    Cake c3 = new Cake(3);  
      
    c2 = c3 = null;  
    System.gc(); //调用Java垃圾收集器
  }  
}  
 
class Cake extends Object {  
  private int id;  
  public Cake(int id) {  
    this.id = id;  
    System.out.println("Cake Object " + id + "is created");  
  }  
    
  protected void finalize() throws java.lang.Throwable {  
    super.finalize();  
    System.out.println("Cake Object " + id + "is disposed");  
  }  
}
</code></pre>
<p>运行以上代码，输出结果如下：</p>
<pre><code>$ javac FinalizationDemo.java 
$ java FinalizationDemo
Cake Object 1is created
Cake Object 2is created
Cake Object 3is created
Cake Object 3is disposed
Cake Object 2is disposed
</code></pre>
<h3 id="stringbuilder类"><a class="header" href="#stringbuilder类">StringBuilder类</a></h3>
<p>1.借助StringBuilder类中的方法屏蔽手机号中间四位数字，如输入手机号”13796105569”,输出示例如下：</p>
<p><img src="https://i.imgtg.com/2022/11/10/tWwai.png" alt="t1.png" /></p>
<p>代码:</p>
<pre><code class="language-java">import java.util.Scanner;
public class Quiz {
public static void main(String[] args) {

	System.out.println("请输入手机号");

    Scanner input=new Scanner(System.in);

    String str=input.nextLine(); //获取键盘输入的字符串
	
	StringBuilder sb = new StringBuilder(str);
	
	sb.replace(3,7,"****");//从0计数，左取，右不取

    System.out.println(sb);
}

}
</code></pre>
<h3 id="静态方法无法调用自己定义的非静态方法"><a class="header" href="#静态方法无法调用自己定义的非静态方法">静态方法无法调用自己定义的非静态方法</a></h3>
<pre><code class="language-java">public class DoSum{

            public static void main(String[] args) {

                   int a = 23;

                   int b = 52;

                  int c = sum(a, b);//省略static的话调用报错 error: non-static method sum(int,int) cannot be referenced from a static context即静态方法无法调用自己定义的非静态方法

//解决方法之一是改变非静态方法为静态方法，在sum方法中的int前加static
                System.out.println("The sum is: " + c);
          }

           public static int sum(int a, int b) {

                  return a + b;

           }

  }
</code></pre>
<h3 id="递归实践"><a class="header" href="#递归实践">递归实践</a></h3>
<p>1.（编程题）分别使用递归方式计算斐波那契数列的前n项。如果计算前24项并输出，每行输出6个数字，程序的运行效果如下。
<img src="https://i.imgtg.com/2022/11/10/tbMNX.png" alt="t2.png" />
请完成计算该数列的前30项的功能并输出</p>
<pre><code class="language-java">public class BC1 {

 public static void main(String[] args) {

 System.out.println("使用递归方法计算斐波那契数列");

 int[] r1 = func(30);//计算斐波那契数列的前30项

 display(r1,6);//输出数组r1，每行输出6个元素

 }

 

 static int[] func(int n) {// 递归方法获取斐波那契数列的前n项

 int[] nums = new int[n];

 for (int i = 0; i &lt; n; i++) {

 nums[i] = f(i + 1);

 }

 return nums;

 }



 static int f(int k) { // 用递归方式求斐波那契数列第k项的值

 if(k==1||k==2){
	return 1; 
 }else{
	 return f(k-1)+f(k-2);
 }

 }





 static void display(int[] values,int m) {// 输出一个数组中的所有元素，每行输出m个元素

for(int j=1;j&lt;=values.length;j++){
	System.out.print(values[j-1]+"\t");
	if(j%6==0){
		System.out.println();
	}
}

 }

}

</code></pre>
<p>2.以下程序完成奇数的累加和功能，计算1到不大于n的所有奇数的和。请将sum方法补充完整，要求使用递归方式实现累加和。</p>
<pre><code class="language-java">public class RecursiveMethods {

	public static void main(String[] args) {

		System.out.println(sum(6)); 

	}

	

	static int sum(int n) {//使用递归方法求解从1开始到不大于n的所有奇数的累加和

		if(n&lt;=0) {

			System.out.println("不合法的n");

			return 0;

		}
		
		if(n==1){
		return 1;	
		}
		else if(n&gt;1&amp;&amp;n%2==1){
			
			return n+sum(n-2);
		}
		else{
		return sum(n-1);	
		}
	//if....else语句不完整报错：Missing return statement	
	
	}

}

</code></pre>
<p>3.（编程题）编程实现二分查找法，在一个从大到小排列的有序数组中查找指定的元素。实现以下步骤：（1）假设数组长度是30，数组中的元素是1到100之间的整数，数组中的元素随机生成。（2）将数组中的元素从大到小排序。 （3）要查找的目标数值是45，若找到该数值，返回下标（如果有多个目标数值，任意返回一个对应的下标即可）；否则返回-1。程序的某两次输出结果示意图如下：</p>
<p><img src="https://i.imgtg.com/2022/11/10/tbOEt.png" alt="t3.png" /></p>
<p><img src="https://i.imgtg.com/2022/11/10/tbaIx.png" alt="t4.png" /></p>
<pre><code class="language-java">public class BinarySearch {

public static void main(String[] args) {

int n=30;

int[] d=new int[n];

for(int i=0;i&lt;n;i++) {

d[i]=(int)(1+Math.random()*100); //随机生成1~100的整数

}

System.out.print("随机生成的数组：");

printArray(d);


arraySort(d);

System.out.print("从大到小排序后的数组：");

printArray(d);


int target=45;

int p=binarySearch(d,target,0,d.length-1);

if(p==-1) {

System.out.println("没有找到目标值"+target);

}

else {

System.out.printf("目标值%d的下标是%d",target,p);

}

}


static void printArray(int[] data) { //打印数组

              for(int i=0;i&lt;data.length;i++){
				System.out.print(data[i]+"\t");  
			  }

}


static void arraySort(int[] data) { //数组排序，从大到小

for(int i=0;i&lt;data.length;i++){
	
	for(int j=i+1;j&lt;data.length;j++){
	
		if(data[i]&lt;data[j]){
		
			int temp = data[j];
			data[j]=data[i];
			data[i]=temp;
		}
	}
}

}


//递归方式实现二分查找

public static int binarySearch(int[] data, int target, int beginIndex, int endIndex) {


	if(target&gt;data[beginIndex]||target&lt;data[endIndex]){
	
		return -1;
	}
    //没有异常处理机制容易stackoverflow
	int middle =  beginIndex+(endIndex-beginIndex)/2;
	if(data[middle]&gt;target){
		return binarySearch(data,target,middle+1,endIndex);
	}
	else if(data[middle]&lt;target){
		return binarySearch(data,target,beginIndex,middle-1);
	}
	else{
		return middle;
	}

}



}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="目录"><a class="header" href="#目录">目录</a></h1>
<ul>
<li><a href="%E6%96%87%E4%BB%B6%E7%90%86%E8%AE%BA.html#%E5%89%8D%E8%A8%80">前言</a></li>
<li><a href="%E6%96%87%E4%BB%B6%E7%90%86%E8%AE%BA.html#%E8%B5%84%E6%BA%90%E5%8C%85">资源包</a>
<ul>
<li><a href="%E6%96%87%E4%BB%B6%E7%90%86%E8%AE%BA.html#%E5%9B%BD%E5%86%85ai%E8%B5%84%E6%BA%90%E6%95%B4%E5%90%88%E7%BD%91%E7%AB%99">国内AI资源整合网站</a></li>
<li><a href="%E6%96%87%E4%BB%B6%E7%90%86%E8%AE%BA.html#%E6%A0%B9%E6%8D%AE%E6%88%AA%E5%9B%BE%E7%94%9F%E6%88%90%E5%89%8D%E7%AB%AF%E4%BB%A3%E7%A0%81%E7%9A%84%E9%A1%B9%E7%9B%AE">根据截图生成前端代码的项目</a></li>
<li><a href="%E6%96%87%E4%BB%B6%E7%90%86%E8%AE%BA.html#csdiy">CSDIY</a></li>
<li><a href="%E6%96%87%E4%BB%B6%E7%90%86%E8%AE%BA.html#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E8%87%AA%E5%AD%A6%E6%8C%87%E5%8D%97">计算机科学自学指南</a></li>
<li><a href="%E6%96%87%E4%BB%B6%E7%90%86%E8%AE%BA.html#%E5%89%8D%E7%AB%AF%E7%AE%97%E6%B3%95javascript-algorithms">前端算法JavaScript-Algorithms</a></li>
<li><a href="%E6%96%87%E4%BB%B6%E7%90%86%E8%AE%BA.html#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95">数据结构与算法</a></li>
<li><a href="%E6%96%87%E4%BB%B6%E7%90%86%E8%AE%BA.html#%E5%BC%80%E5%8F%91%E8%80%85%E8%B7%AF%E5%BE%84">开发者路径</a></li>
<li><a href="%E6%96%87%E4%BB%B6%E7%90%86%E8%AE%BA.html#leetcode%E5%88%B7%E9%A2%98">leetcode刷题</a></li>
<li><a href="%E6%96%87%E4%BB%B6%E7%90%86%E8%AE%BA.html#hellogithubgithub%E4%BC%98%E8%B4%A8%E9%A1%B9%E7%9B%AE%E6%8E%A8%E8%8D%90">hellogithub——github优质项目推荐</a></li>
<li><a href="%E6%96%87%E4%BB%B6%E7%90%86%E8%AE%BA.html#github-%E4%B8%AD%E6%96%87%E6%8E%92%E8%A1%8C%E6%A6%9C">GitHub 中文排行榜</a></li>
</ul>
</li>
<li><a href="%E6%96%87%E4%BB%B6%E7%90%86%E8%AE%BA.html#%E9%99%84%E5%8A%A0%E9%A1%B9">附加项</a>
<ul>
<li><a href="%E6%96%87%E4%BB%B6%E7%90%86%E8%AE%BA.html#%E9%A2%88%E6%A4%8E%E7%97%85%E9%98%B2%E6%B2%BB%E6%8C%87%E5%8D%97">颈椎病防治指南</a></li>
<li><a href="%E6%96%87%E4%BB%B6%E7%90%86%E8%AE%BA.html#%E8%A7%86%E5%8A%9B%E6%81%A2%E5%A4%8D%E8%B4%9D%E8%8C%A8%E7%96%97%E6%B3%95">视力恢复——贝茨疗法</a></li>
<li><a href="%E6%96%87%E4%BB%B6%E7%90%86%E8%AE%BA.html#%E5%AD%A6%E8%8B%B1%E8%AF%AD1">学英语1</a></li>
<li><a href="%E6%96%87%E4%BB%B6%E7%90%86%E8%AE%BA.html#%E5%AD%A6%E8%8B%B1%E8%AF%AD2">学英语2</a></li>
<li><a href="%E6%96%87%E4%BB%B6%E7%90%86%E8%AE%BA.html#%E5%81%9A%E9%A5%AD">做饭</a></li>
<li><a href="%E6%96%87%E4%BB%B6%E7%90%86%E8%AE%BA.html#%E7%89%9Bx%E9%A1%B9%E7%9B%AE%E5%A4%A7%E5%85%A8%E9%9B%86">牛X项目大全集</a></li>
<li><a href="%E6%96%87%E4%BB%B6%E7%90%86%E8%AE%BA.html#%E7%94%B5%E5%AD%90%E4%B9%A6%E4%B8%8B%E8%BD%BD">电子书下载</a></li>
<li><a href="%E6%96%87%E4%BB%B6%E7%90%86%E8%AE%BA.html#%E9%80%82%E5%90%88%E4%B8%AA%E4%BA%BA%E5%BC%80%E5%8F%91%E7%9A%84%E5%B0%8F%E9%A1%B9%E7%9B%AE%E5%90%88%E9%9B%86">适合个人开发的小项目合集</a></li>
</ul>
</li>
<li><a href="%E6%96%87%E4%BB%B6%E7%90%86%E8%AE%BA.html#%E9%97%B2%E6%9A%87">闲暇</a>
<ul>
<li><a href="%E6%96%87%E4%BB%B6%E7%90%86%E8%AE%BA.html#%E4%BD%93%E8%82%B2%E9%94%BB%E7%82%BC">体育锻炼</a></li>
<li><a href="%E6%96%87%E4%BB%B6%E7%90%86%E8%AE%BA.html#%E4%B9%A6%E5%8D%95">书单</a></li>
<li><a href="%E6%96%87%E4%BB%B6%E7%90%86%E8%AE%BA.html#%E5%89%A7%E5%8D%95">剧单</a></li>
<li><a href="%E6%96%87%E4%BB%B6%E7%90%86%E8%AE%BA.html#%E9%9D%9E%E5%BF%85%E8%A6%81%E8%AF%BE%E7%A8%8B%E6%B8%85%E5%8D%95">非必要课程清单</a></li>
<li><a href="%E6%96%87%E4%BB%B6%E7%90%86%E8%AE%BA.html#%E6%88%98%E4%B9%B1%E6%9D%A5%E4%B8%B4%E8%87%AA%E6%95%91%E6%89%8B%E5%86%8C">战乱来临自救手册</a>
<ul>
<li><a href="%E6%96%87%E4%BB%B6%E7%90%86%E8%AE%BA.html#%E5%A4%A7%E5%B4%A9%E6%BA%83%E6%97%B6%E6%9C%9F%E7%9A%84%E6%B3%A2%E6%96%AF%E5%B0%BC%E4%BA%9A%E7%94%9F%E5%AD%98%E8%AE%B0%E5%BD%95">大崩溃时期的波斯尼亚生存记录</a></li>
<li><a href="%E6%96%87%E4%BB%B6%E7%90%86%E8%AE%BA.html#%E6%88%98%E4%BA%89%E6%9D%A5%E4%B8%B4%E7%9A%84%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C%E5%B9%B3%E6%B0%91%E7%94%9F%E5%AD%98%E6%89%8B%E5%86%8C">战争来临的准备工作（平民生存手册）</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="前言"><a class="header" href="#前言">前言</a></h1>
<p>虽然程序员35岁门槛离你还有点远，但也要有点准备才行。大龄程序员往往有两条路，一条是转管理、架构师等高端岗位，还一条就是送外卖、开滴滴等低端岗位。</p>
<p><strong>古话说：“人无远虑，必有近忧”。居安思危的态度还是要有的。不然真人吃鸡大赛真爆发了，手足无措之下，容易开局就寄了。</strong></p>
<p>下面写的都是些建议性的内容，希望对你的人生规划有点意义。写成文字，你有空可以多看两遍。</p>
<p>现在社会环境比较差，已经到了崩溃的前夜了。我们这种底层屁民就得有意识早做准备，比如安排好自己当下的生活工作学习，保持良好的心态，定期参加体育锻炼强身健体，还要学点必备的生存技能。</p>
<p>我不了解前端的内容，只能给你介绍下前端算法JavaScript-Algorithms和根据截图生成前端代码的项目screenshottocode。有空可以学点后端开发，当好全栈工程师。后端主要需要的计算机网络、Java、数据库。计网要是忘了可以跳着看。Java可以看B站韩顺平<a href="https://www.bilibili.com/video/BV1fh411y7R8">【零基础 快速学Java】韩顺平 零基础30天学会Java</a>。数据库的话用什么学什么就行。下面的CSDIY网站里面有推荐的课程，中国大学Mooc里面也有，自己选择即可。其他的内容如离散数学、操作系统、编译原理属于高阶内容，最好会，这样才能摆脱码农地位，成为高级工程师，当然不会也无妨。这是以前给你写的<a href="https://github.com/ruoling007/ruoling007.github.io/blob/master/%E5%AD%A6%E4%B9%A0%E8%BF%9B%E6%AD%A5%E8%B7%AF%E7%BA%BF%E5%9B%BE.md">学习进步路线图</a>有空还可以看看。</p>
<p>多看点经济金融的书籍或是课程，了解基本的资产配置道理，规避不必要的风险，才能保住自己辛苦挣的钱。你那挣的都是辛苦钱，不要碰任何投资项目，一碰基本就血本无归了，尤其是避免“杀猪盘”。钱最好分开放，四大行的就行，小银行就不要碰了。可以存定期，不过手里要有一定的流动性。不嫌麻烦的话还可以换点美元、欧元，趁着有额度早点准备。</p>
<p>多看点历史、管理、心理学的内容，既能理解时代变迁，也能洞察人心，更好地处理人际关系，从而活得游刃有余。情况允许的话，也能在被优化之前转管理岗位。真的不幸被优化了，也不要有什么心理压力，好好过日子。多读书学习，开拓眼界，防止患上精神病，避免被优化后茫然无措。</p>
<p>时代的波澜之下，我们主动改变一些事情要好过全程被动被推着走。</p>
<p>周末的时间可以好好玩耍，也可以给自己充充电。最好不要全天打游戏，打游戏也会消耗精力、注意力，加重疲劳感。恢复精力的好方式就是睡觉、冥想、参加体育锻炼等改变注意力注意的方向或是停止注意力的消耗。</p>
<p>累分两种，心累和体累。心累要注意精力和注意力的恢复，这个可以用听音乐、冥想、做运动或睡觉来解决。体累就靠睡觉解决了。</p>
<p>不要碰黄赌毒，一般人碰上一辈子就差不多就完蛋了。比起黄赌毒，两点一线的生活闲着打游戏追剧的生活其实是很好的。</p>
<p>尽量不要去人很多的地方，那种地方更容易成为恐怖分子的袭击目标。现在一年比一年难过，还没有好转的可能，社会怒气值越来越高，容易发生报复社会的事件。各级政府基本上财政都紧张，社会秩序维持功能大不如前，真出了什么事基本上不能指望政府（它们不帮倒忙就不错了）。西北的恐怖分子出再教育营也容易搞点“大新闻”。</p>
<p>要有自己的可靠的朋友圈子，有人可以良性交流的话可以降低换上精神疾病的风险。</p>
<p>周末吃饭的时候可以看看油管上的新闻，了解以下现状。但是不要沉迷于其中，吃饭时看看就行，不要参加键政活动。</p>
<p><strong>现在年轻女人品行大多不行，网上和现实中极端女权分子都很多。闲着多看点知乎上反女权的内容，避免性别战争的“牺牲品”。将来要结婚生孩子，早日认清现状才可能规避掉不必要的风险。避免“被社死”和避免“杀猪盘”、“仙人跳”一样重要。</strong></p>
<p>关于避免被社工的内容，最好也要懂点。密码要强度要高，不要有重复的。简单密码靠google账户就记录了。也可以用Keepass之类的软件。加强个人隐私保护，不是特别关键的内容不要填自己的个人信息包括手机号。淘宝之类的收件人姓名可以用古代名人的名字。闲着的时候可以看看社工库，看看自己有没有被PWN了。Firefox Monitor之类的查信息泄露的网站也可以偶偶看看。社交网站最好不要重名，不知道叫啥就自动生成或叫momo，也不要发容易被和谐的内容。</p>
<p>最好能再搞个成考本科学历。公积金、社保之类的能少交就少交，能尽早取就尽早取，等我们老了应该就是真正的新时代了。现在多交也没意义，可以多看看别人的攻略。</p>
<p>最后附录了书单和剧单，你书荒或剧荒时可以看看。</p>
<h1 id="资源包"><a class="header" href="#资源包">资源包</a></h1>
<p>保持好奇心，多尝试点新事物，日子才不会过得很无聊。</p>
<p>当然写代码这行当就得能钻研，爱折腾。</p>
<p>学过的东西要有记录、总结、降低复现成本。</p>
<p>博客最好还是要有一个，可以用来记录学过的内容，上班天天CURD，技术水平没长进的，将来不好混啊！</p>
<p>搭建博客可以用GitHubPages加Hugo，一般的技术文档可以用mdbook。</p>
<h2 id="国内ai资源整合网站"><a class="header" href="#国内ai资源整合网站">国内AI资源整合网站</a></h2>
<p>https://ai-bot.cn/</p>
<p>要注册好Openai账号，熟练使用ChatGPT、GPT4等辅助写代码</p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost03/img/202401222254466.png" alt="" /></p>
<h2 id="根据截图生成前端代码的项目"><a class="header" href="#根据截图生成前端代码的项目">根据截图生成前端代码的项目</a></h2>
<p>https://screenshottocode.com/</p>
<h2 id="csdiy"><a class="header" href="#csdiy">CSDIY</a></h2>
<p><a href="https://csdiy.wiki/">网址</a></p>
<p>这是一本计算机的自学指南，也是对自己大学三年自学生涯的一个纪念。</p>
<p>这同时也是一份献给北大信科学弟学妹们的礼物。如果这本书能对你们的信科生涯有哪怕一丝一毫的帮助，都是对我极大的鼓励和慰藉。</p>
<p>本书目前包括了以下部分(如果你有其他好的建议，或者想加入贡献者的行列，欢迎邮件 <a href="mailto:zhongyinmin@pku.edu.cn">zhongyinmin@pku.edu.cn</a> 或者在 issue 里提问)：</p>
<ul>
<li>必学工具：IDE, 翻墙, StackOverflow, Git, GitHub, Vim, LaTeX, GNU Make, 实用工具 ...</li>
<li>环境配置：PC端以及服务器端开发环境配置、各类运维相关教材及资料 ...</li>
<li>经典书籍推荐：看过 CSAPP 这本书的同学一定感叹好书的重要，我将列举推荐自己看过的计算机领域的必看好书与资源链接。</li>
<li><strong>国外高质量 CS 课程汇总</strong>：我将把我上过的所有高质量的国外 CS 课程分门别类进行汇总，并给出相关的自学建议，大部分课程都会有一个独立的仓库维护相关的资源以及我的作业实现。</li>
</ul>
<p>CS自学指南
前言
如何使用这本书
一个仅供参考的CS学习规划
必学工具
好书推荐
数学基础
数学进阶
编程入门
电子基础
数据结构与算法
软件工程
体系结构
操作系统
并行与分布式系统
计算机系统安全
计算机网络
数据库系统
编译原理
编程语言设计与分析
计算机图形学
Web开发
数据科学
人工智能
机器学习
机器学习系统
深度学习
机器学习进阶
后记</p>
<h2 id="计算机科学自学指南"><a class="header" href="#计算机科学自学指南">计算机科学自学指南</a></h2>
<p>https://github.com/izackwu/TeachYourselfCS-CN/blob/master/TeachYourselfCS-CN.md</p>
<p>大致按照列出的顺序，借助我们所建议的教材或者视频课程（但是最好二者兼用），学习如下的九门科目。目标是先花 100 到 200 个小时学习完每一个科目，然后在你职业生涯中，不时温习其中的精髓🚀。</p>
<div class="table-wrapper"><table><thead><tr><th>科目</th><th>为何要学？</th><th>最佳书籍</th><th>最佳视频</th></tr></thead><tbody>
<tr><td><a href="https://github.com/izackwu/TeachYourselfCS-CN/blob/master/TeachYourselfCS-CN.md#%E7%BC%96%E7%A8%8B">编程</a></td><td>不要做一个「永远没彻底搞懂」诸如递归等概念的程序员。</td><td><a href="https://book.douban.com/subject/1148282/">《计算机程序的构造和解释》</a></td><td>Brian Harvey’s Berkeley CS 61A</td></tr>
<tr><td><a href="https://github.com/izackwu/TeachYourselfCS-CN/blob/master/TeachYourselfCS-CN.md#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84">计算机系统结构</a></td><td>如果你对于计算机如何工作没有具体的概念，那么你所做出的所有高级抽象都是空中楼阁。</td><td><a href="https://book.douban.com/subject/26912767/">《深入理解计算机系统》</a></td><td>Berkeley CS 61C</td></tr>
<tr><td><a href="https://github.com/izackwu/TeachYourselfCS-CN/blob/master/TeachYourselfCS-CN.md#%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84">算法与数据结构</a></td><td>如果你不懂得如何使用栈、队列、树、图等常见数据结构，遇到有难度的问题时，你将束手无策。</td><td><a href="https://book.douban.com/subject/4048566/">《算法设计手册》</a></td><td>Steven Skiena’s lectures</td></tr>
<tr><td><a href="https://github.com/izackwu/TeachYourselfCS-CN/blob/master/TeachYourselfCS-CN.md#%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86">数学知识</a></td><td>计算机科学基本上是应用数学的一个「跑偏的」分支，因此学习数学将会给你带来竞争优势。</td><td><a href="https://book.douban.com/subject/33396340/">《计算机科学中的数学》</a></td><td>Tom Leighton’s MIT 6.042J</td></tr>
<tr><td><a href="https://github.com/izackwu/TeachYourselfCS-CN/blob/master/TeachYourselfCS-CN.md#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F">操作系统</a></td><td>你所写的代码，基本上都由操作系统来运行，因此你应当了解其运作的原理。</td><td><a href="https://book.douban.com/subject/33463930/">《操作系统导论》</a></td><td>Berkeley CS 162</td></tr>
<tr><td><a href="https://github.com/izackwu/TeachYourselfCS-CN/blob/master/TeachYourselfCS-CN.md#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C">计算机网络</a></td><td>互联网已然势不可挡：理解工作原理才能解锁全部潜力。</td><td><a href="https://book.douban.com/subject/30280001/">《计算机网络：自顶向下方法》</a></td><td>Stanford CS 144</td></tr>
<tr><td><a href="https://github.com/izackwu/TeachYourselfCS-CN/blob/master/TeachYourselfCS-CN.md#%E6%95%B0%E6%8D%AE%E5%BA%93">数据库</a></td><td>对于多数重要程序，数据是其核心，然而很少人理解数据库系统的工作原理。</td><td><em><a href="https://book.douban.com/subject/2256069/">Readings in Database Systems</a></em> （暂无中译本）</td><td>Joe Hellerstein’s Berkeley CS 186</td></tr>
<tr><td><a href="https://github.com/izackwu/TeachYourselfCS-CN/blob/master/TeachYourselfCS-CN.md#%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E4%B8%8E%E7%BC%96%E8%AF%91%E5%99%A8">编程语言与编译器</a></td><td>若你懂得编程语言和编译器如何工作，你就能写出更好的代码，更轻松地学习新的编程语言。</td><td><em><a href="https://craftinginterpreters.com/">Crafting Interpreters</a></em></td><td>Alex Aiken’s course on Lagunita</td></tr>
<tr><td><a href="https://github.com/izackwu/TeachYourselfCS-CN/blob/master/TeachYourselfCS-CN.md#%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F">分布式系统</a></td><td>如今，<strong>多数</strong> 系统都是分布式的。</td><td><a href="https://book.douban.com/subject/30329536/">《数据密集型应用系统设计》</a></td><td>MIT 6.824</td></tr>
<tr><td>还是太多？</td><td></td><td></td><td></td></tr>
</tbody></table>
</div>
<p>如果花几年时间自学 9 门科目让人望而却步，我们建议你只专注于两本书：<strong>《深入理解计算机系统》</strong> 和 <strong>《数据密集型应用系统设计》</strong>。根据我们的经验，投入到这两本书的时间可以获得极高的回报率，特别适合从事网络应用开发的自学工程师。这两本书也可以作为上面表格中其他科目的纲领。</p>
<h2 id="前端算法javascript-algorithms"><a class="header" href="#前端算法javascript-algorithms">前端算法JavaScript-Algorithms</a></h2>
<p>https://github.com/sisterAn/JavaScript-Algorithms</p>
<p>我是瓶子君，前端进阶博客：<a href="https://github.com/sisterAn/blog">https://github.com/sisterAn/blog</a></p>
<p><a href="https://www.pzijun.cn/">线上版本阅读更流畅，点击阅读</a></p>
<p>作为一名前端，虽然在平常开发中很少写算法，但当我们需要深入前端框架、开发语言、开源库时，懂算法将大大提高我们看源码的能力。例如 ：</p>
<ul>
<li>virtual-dom diff 算法做了一些约定，后将原先 O(n3) 的时间复杂度降到了O(n) ，核心原理就是一个树的深度优先搜索</li>
<li>babel 这些就是一些编译原理的 parser 生成抽象语法树的知识，再将抽象语法树进行转换操作生成文件</li>
<li>浏览器的 history，底层可以使用栈来实现</li>
<li>webpack 中利用 tree-shaking 优化</li>
<li>v8 中的调用栈、消息队列等等</li>
</ul>
<p>这些就大量使用了算法，看懂了就能更好的了解它们的性能，更高效的解决问题，提升我们的代码质量与思维视野，进阶到更高 Level，赚更多钱💰💰💰。</p>
<p>所以说，学算法是每个前端进阶必备！⛽️⛽️⛽️</p>
<p>所以，这里我整理了一份适用于前端的数据结构与算法系列，希望能帮助你从0到1构建完整的数据结构与算法体系（<strong>此处所有的题目均来自真实前端面试</strong>）。</p>
<p><a href="https://camo.githubusercontent.com/a3d2708b5c9c19ef6625e18ff240afd3975f3e5a367437cb45ce89d02b88553b/687474703a2f2f7265736f757263652e6d757969792e636e2f696d6167652f32303230303631363030303630342e706e67"><img src="https://camo.githubusercontent.com/a3d2708b5c9c19ef6625e18ff240afd3975f3e5a367437cb45ce89d02b88553b/687474703a2f2f7265736f757263652e6d757969792e636e2f696d6167652f32303230303631363030303630342e706e67" alt="" /></a></p>
<h2 id="数据结构与算法"><a class="header" href="#数据结构与算法">数据结构与算法</a></h2>
<p>基础班——青岛大学王卓</p>
<p>https://www.bilibili.com/video/BV1UQ4y1w7A2</p>
<p>这门课比较简单</p>
<h2 id="开发者路径"><a class="header" href="#开发者路径">开发者路径</a></h2>
<p>https://github.com/kamranahmedse/developer-roadmap</p>
<p>Interactive roadmaps, guides and other educational content to help developers grow in their careers.</p>
<h2 id="leetcode刷题"><a class="header" href="#leetcode刷题">leetcode刷题</a></h2>
<p>https://programmercarl.com/</p>
<p>必读</p>
<ul>
<li><strong>介绍</strong>：本站是一套完整的刷题计划，<strong>旨在帮助大家少走弯路，循序渐进学算法</strong>。</li>
<li><strong>正式出版</strong> ：<a href="https://programmercarl.com/other/publish.html">《代码随想录》 (opens new window)</a>。</li>
<li><strong>PDF版本</strong> ： <a href="https://programmercarl.com/other/algo_pdf.html">代码随想录PDF下载 (opens new window)</a>。</li>
<li><strong>算法公开课</strong> : <a href="https://programmercarl.com/other/gongkaike.html">《代码随想录》算法视频公开课(opens new window)</a></li>
<li><strong>最强八股文：</strong>：<a href="https://www.programmercarl.com/other/kstar_baguwen.html">代码随想录知识星球精华PDF(opens new window)</a></li>
<li><strong>代码随想录知识星球</strong> : 几千录友在这里学习，<a href="https://programmercarl.com/other/kstar.html">点击这里 (opens new window)</a>，了解详情</li>
<li><strong>刷题顺序</strong> ： 左侧菜单栏（如果手机端查看则是在左上角）已经将刷题顺序排好了，按照顺序一道一道刷就可以。</li>
<li><strong>编程语言</strong>：本站统一使用C++语言进行讲解，但已经有Java、Python、Go、JavaScript等等多语言版本，感谢<a href="https://github.com/youngyangyang04/leetcode-master/graphs/contributors">这里的每一位贡献者 (opens new window)</a>，如果你也想贡献代码点亮你的头像，<a href="https://mp.weixin.qq.com/s/tqCxrMEU-ajQumL1i8im9A">点击这里 (opens new window)</a>了解提交代码的方式。</li>
<li><strong>转载须知</strong> ：以下所有文章皆为我（<a href="https://github.com/youngyangyang04">程序员Carl (opens new window)</a>）的原创。引用本项目文章请注明出处，发现恶意抄袭或搬运，会动用法律武器维护自己的权益。让我们一起维护一个良好的技术创作环境！</li>
</ul>
<h2 id="hellogithubgithub优质项目推荐"><a class="header" href="#hellogithubgithub优质项目推荐">hellogithub——github优质项目推荐</a></h2>
<p>https://hellogithub.com/</p>
<p>HelloGitHub 是一个发现和分享有趣、入门级开源项目的平台。 希望大家能够在这里找到编程的快乐、 轻松搞定问题的技术方案、 大呼过瘾的开源神器， 顺其自然地开启开源之旅。</p>
<h2 id="github-中文排行榜"><a class="header" href="#github-中文排行榜">GitHub 中文排行榜</a></h2>
<p>GitHub上最受欢迎的中文开源项目，按照星标排序</p>
<p>https://www.github-zh.com/top-china</p>
<p>29、<a href="https://github.com/MunGell/awesome-for-beginners">Awesome-For-Beginners</a></p>
<p>Star 5.8w</p>
<p>Fork 6.6k</p>
<p>详情</p>
<p>对初学者友好的开源项目集合。如果你想参与到开源项目的建设，可以在这个集合中寻找项目，祝你早日完成第一个贡献（PR）</p>
<p>开源书籍</p>
<p>35、<a href="https://github.com/woai3c/introduction-to-front-end-engineering">Introduction-To-Front-End-Engineering</a></p>
<p>Star 1.8k</p>
<p>Fork 202</p>
<p>详情</p>
<p>一本小书《带你入门前端工程》。该书是作者对过去两年前端工程化实践的经验和心得总结，<a href="https://woai3c.github.io/introduction-to-front-end-engineering/">在线阅读</a></p>
<p>7、<a href="https://github.com/you-dont-need/You-Dont-Need-JavaScript">You-Dont-Need-JavaScript</a></p>
<p>Star 1.9w</p>
<p>Fork 1.3k</p>
<p>详情</p>
<p>看似需要 JavaScript 实现的效果，其实仅用到了 CSS 的示例集合。该项目学习意义大于实用价值，更多的时候是为了让你知道原来 CSS 还能这么用</p>
<h1 id="附加项"><a class="header" href="#附加项">附加项</a></h1>
<h2 id="颈椎病防治指南"><a class="header" href="#颈椎病防治指南">颈椎病防治指南</a></h2>
<p>https://www.zhangningle.top/RehabilitationGuide/</p>
<h2 id="视力恢复贝茨疗法"><a class="header" href="#视力恢复贝茨疗法">视力恢复——贝茨疗法</a></h2>
<p>多看点视力保护的内容，比如不要疲劳用眼，坐姿要正确、适当时候要远眺等。其他的以前跟你分享过。</p>
<h2 id="学英语1"><a class="header" href="#学英语1">学英语1</a></h2>
<p>要成为出色的程序员，英语不能太差！</p>
<p>专为程序员编写的英语学习指南 v1.2。在线版本请点 -&gt;</p>
<p>https://github.com/yujiangshui/A-Programmers-Guide-to-English</p>
<p>专为程序员编写的英语学习指南。</p>
<p><a href="https://a-programmers-guide-to-english.harryyu.me/">点击这里打开在线版本</a> 排版更好看，也可以<a href="https://github.com/yujiangshui/A-Programmers-Guide-to-English">点击查看 GitHub 源码</a>。</p>
<blockquote>
<p>预警：本指南可能会花费你大量时间阅读，建议通过周六上午整块的时间一次性读完，并在下午制定自己的学习策略，然后在周日开始实践一下。</p>
</blockquote>
<p><strong>本指南的内容概要和目标人群</strong></p>
<p>本人上一次正式英语考试大约是五年前大学四级考试，得分 442，大学每学期考试基本是 60 多分过线就好，纯属英语渣底子很差。但是由于一些特殊需求，雅思需要考到 6.5 分及以上，所以自 2018 年 6 月份开始一直在学习英语。在学习过程中，对语言学习从陌生到熟悉，从毫无头绪到了解一些实用的训练方法，从乱看经验经常换方法到总结出自己的学习方法。</p>
<p>经过四个月断续学习和接近两个月的全职突击备考，在 12 月份考了 PTE 考试（类似雅思的英语水平测试）并拿到 63 分，对应雅思 6.5 中上，满足大部分学校留学要求以及出国技术移民的要求。备考过程十分艰苦，个人感觉远超高考。虽然离十分流畅的跟 Native Speaker 交流还有一段距离，但是相比四级 442 的水平有了几倍的提升。故此编写教程进行阶段性总结，一来方便自己制定下一步训练计划，二来希望可以对同等水平有需求的朋友有所帮助。</p>
<p>本教程目标人群是<strong>想要花一些时间真正掌握英语的人</strong>，尤其适合英语渣。对于英语渣来说，网上杂七杂八的英语学习技巧和经验不一定会有很多帮助，甚至会误导。比如<a href="https://www.zhihu.com/question/22968875/answer/529514279">这篇回答</a>就说了，如果别人问答主如何学英语，她顶多给一句“多看美剧，培养语感”，好在这篇回答详细说了答主的水平和长期的努力细节，否则会误导一大片低水平英语渣去拼命的看美剧。所以<strong>在英语学习过程中，要注意查看符合自己水平的经验和教程</strong>，否则可能会走弯路。</p>
<p>如果你在寻找《21 天掌握英语》、《10 天背会 1000 词》、《10 天搞定英语写作》之类的资料，这份指南并不适合你。尤其是语言学习，学习周期都是以月或者年来计的，<strong>你越早明白语言学习没有技巧，就会越少浪费时间和金钱在各种资料和经验上面，走越少的弯路</strong>。</p>
<p>由于网上各种英语学习技巧的效果跟学习者的水平相关，所以<strong>本指南会深挖语言学习的本质（主要用中文举例）并用程序员易于理解的方式去思考，并提供自己根据本质推演出来的训练方法和经验做参考。重中之重是你要根据本质自己设计适合自己的训练方法，同时可以甄别网上看到学习方法和资料，判断是否适合自己使用。</strong></p>
<p>需要补充的是，由于本人的水平有限而且也在持续学习，后续会经常完善、升级、更新本指南，<strong>强烈建议 Watch 并时而回来看看</strong>。因此如果转载本指南，请保留出处避免信息过时。如有异议或者建议，也十分欢迎在 Issue 中讨论。还需要注意的是，由于本文是文本形式，不好播放声音，所以用中文来描述一些单词的错误发音，在日常英语学习中应该使用音标而不能使用中文标注发音。</p>
<h2 id="学英语2"><a class="header" href="#学英语2">学英语2</a></h2>
<p>An advanced guide to learn English which might benefit you a lot 🎉 . 离谱的英语学习指南/英语学习教程。</p>
<p><a href="https://byoungd.github.io/English-level-up-tips/" title="https://byoungd.github.io/English-level-up-tips/">byoungd.github.io/English-level-up-tips/</a></p>
<h2 id="做饭"><a class="header" href="#做饭">做饭</a></h2>
<p>https://github.com/Anduin2017/HowToCook</p>
<p>程序员在家做饭方法指南。Programmer's guide about how to cook at home (Chinese only).</p>
<p><a href="https://cook.aiurs.co/" title="https://cook.aiurs.co">cook.aiurs.co</a></p>
<h2 id="牛x项目大全集"><a class="header" href="#牛x项目大全集">牛X项目大全集</a></h2>
<p>https://github.com/sindresorhus/awesome</p>
<p>Awesome lists about all kinds of interesting topics</p>
<h2 id="电子书下载"><a class="header" href="#电子书下载">电子书下载</a></h2>
<p><a href="https://zh.zlibrary-east.se/"><img src="https://zh.zlibrary-east.se/img/logo.zlibrary.png" alt="ZLibary Z-Library" title="Z-Library" /></a></p>
<p>您通往知识和文化的门户。 每个人都可以使用。</p>
<p>https://zh.zlibrary-east.se/</p>
<h2 id="适合个人开发的小项目合集"><a class="header" href="#适合个人开发的小项目合集">适合个人开发的小项目合集</a></h2>
<p>Curated list of project-based tutorials</p>
<p>https://github.com/practical-tutorials/project-based-learning</p>
<p>Master programming by recreating your favorite technologies from scratch.</p>
<p><a href="https://codecrafters.io/" title="https://codecrafters.io">codecrafters.io</a></p>
<p>https://github.com/codecrafters-io/build-your-own-x</p>
<h1 id="闲暇"><a class="header" href="#闲暇">闲暇</a></h1>
<p>生活要有目标。</p>
<h2 id="体育锻炼"><a class="header" href="#体育锻炼">体育锻炼</a></h2>
<p>下载keep软件，买个垫子，在出租屋里也能进行体育锻炼。</p>
<h2 id="书单"><a class="header" href="#书单">书单</a></h2>
<p>如果现实中不怎么和人交流，那就要和存在一定时空距离的人交流，不然容易得精神病比如抑郁症之类的。</p>
<p>这些书基本上都能在Z-Library下载到。</p>
<p>阅读软件可以用calibre也可以用Koodo Reader。</p>
<div class="table-wrapper"><table><thead><tr><th>书名</th><th>作者</th></tr></thead><tbody>
<tr><td>经济学的思维方式</td><td>托马斯·索维尔</td></tr>
<tr><td>国史大纲</td><td>钱穆</td></tr>
<tr><td>非暴力沟通</td><td>马歇尔</td></tr>
<tr><td>富兰克林自传</td><td>富兰克林</td></tr>
<tr><td>自私的基因</td><td>道金斯</td></tr>
<tr><td>进化心理学</td><td>大卫</td></tr>
<tr><td>思考快与慢</td><td>卡尼曼</td></tr>
<tr><td>网络是怎样连接的</td><td>户根勤</td></tr>
<tr><td>小狗钱钱</td><td>博多·舍费尔</td></tr>
<tr><td>黑天鹅</td><td>塔勒布</td></tr>
<tr><td>浪潮之巅</td><td>吴军</td></tr>
<tr><td>动物农场</td><td>奥威尔</td></tr>
<tr><td>史记</td><td>司马迁</td></tr>
<tr><td>三国演义</td><td>罗贯中</td></tr>
<tr><td>自控力</td><td>麦格尼格尔</td></tr>
<tr><td>学习如何学习</td><td>芭芭拉·奥克利</td></tr>
</tbody></table>
</div>
<h2 id="剧单"><a class="header" href="#剧单">剧单</a></h2>
<p>《是大臣》</p>
<p>《是首相》</p>
<p>《银河英雄传说》</p>
<p>《白色巨塔》</p>
<p>《非自然死亡》</p>
<p>《半泽直树》</p>
<p>《兄弟连》</p>
<h2 id="非必要课程清单"><a class="header" href="#非必要课程清单">非必要课程清单</a></h2>
<p>微观经济学、宏观经济学   武汉大学 文建东</p>
<p>不懂经济学，将来很难守住自己挣的钱</p>
<p>Machine Learning  Stanford Andrew Ng</p>
<p>这是网上最简单的机器学习入门课，看看也有所裨益。</p>
<p>至于提示词工程或是GPT4的高阶用法，网上都能找到，这里全看兴趣了。</p>
<p>心理学：我知无不言，它妙不可言   华中师范大学  田媛</p>
<p>了解人类心理，也能更好的了解自己，避免换上精神疾病</p>
<p>史记、秦始皇 台湾大学 吕世浩</p>
<p>了解中国历史的一门特别棒的课程，能让我激情澎湃去成为一个更好的人！</p>
<p>财务分析与决策  清华大学 肖星</p>
<p>了解财务相关内容的一门特别出色的课，貌似只能在学堂在线上学</p>
<p>至于高等数学、线性代数、概率论与数理统计、离散数学等有能力就学点，没能力都可以避开。</p>
<p>不过有时掌握更多的知识也挺有趣的！</p>
<h2 id="战乱来临自救手册"><a class="header" href="#战乱来临自救手册">战乱来临自救手册</a></h2>
<h3 id="大崩溃时期的波斯尼亚生存记录"><a class="header" href="#大崩溃时期的波斯尼亚生存记录">大崩溃时期的波斯尼亚生存记录</a></h3>
<p>又有人聊起这份东西，再转一个到豆瓣吧。<br />
地狱里的一年：生存在大崩溃时期的波斯尼亚<br />
By Selco<br />
我来自波斯尼亚。众所周知，1992年至1995年期间，那儿就是地狱。有整整一年，我在一座有五六千居民的城市里艰难地活着，没有自来水、电和燃气，没有医疗、民防、食品供给，也没有任何形式的法律或政府。那座城市被军队包围了整整一年，围城期间，情况真是糟糕到了极点。城里没有成组织的军队或警察，只有若干自组织的武装人员，各自保卫其家园和家庭。<br />
一切开始的时候，我们中有些准备还算相对充分，但大多数邻居们家只有够几天吃的食物。有些有手枪，少部分人还有AK-47步枪或霰弹枪。<br />
过了一两个月，匪徒们开始结伙，横行肆虐。把医院变成了屠宰场。警力彻底消失，八成医院员工逃走。<br />
我还算走运，我的家在当时算是大的（有15名成员，住在一栋大房子里，有5、6把手枪，3把AK），所以活了下来——至少大多数活了下来。<br />
每十天，美军会空投一些即食口粮，算是援助被围困的居民，不过那些根本不够。极少数人家里有块小园地，可以种些蔬菜。<br />
三个月后，关于第一批死于饥饿或寒冷的人的消息四下传开。我们把废弃房屋里所有的门窗都拆了下来，连同地板和家具当作木柴。许多人死于疾病，其中大多数因为恶劣的水质（我家有两人即死于此）。我们喝收集起来的雨水，吃过鸽子甚至是老鼠。<br />
钱很快变得毫无价值，人们开始以物易物。一个牛肉罐头可以换取占有一个女人个把钟头（令人难以启齿，但这就是现实）。多数卖身的女人是绝望的母亲们。<br />
武器、弹药、蜡烛、打火机、抗生素、汽油、电池以及食物，我们为了这些东西而战斗，像动物一样。在那种情况下，很多事都变了，很多人变成了怪物，非常的恶心。<br />
实力由人数决定。独居者即使有武器也几乎毫无悬念地难逃被劫掠并杀死的命运。<br />
无论如何，当战争结束时，我们松了一口气。在战争中哪方是正义的根本不重要。<br />
二十年过去了，但一切就像昨天一样历历在目。我学到了不少东西，人生观也变了。我懂得了坏事随时会发生，也不再相信任何政府和权威——因为每次发生前，他们都在声嘶力竭或故作平静地向你保证一切正常，不必担心。如今，我和家人们都时刻处于准备充足、装备精良的状态。我们经历过啊。<br />
下一次是什么？地震、海啸、内战、外族入侵、恐怖袭击、经济崩溃…… 具体是什么不重要，重要的是总会有下一次的。<br />
我的经验是：决不能单打独斗；一家人要齐心协力，也要和可靠的朋友并肩作战。</p>
<ol>
<li>如何安全的行动？<br />
城市按街道划分成不同社区。我们所在的街道有15到20户，自发组织了武装巡逻队，每队五人，按周轮值，以提防匪帮和我们的敌人们。<br />
所有交易都在街面上进行。在五公里外的一整条街上形成了很有组织的市场，但只在夜里进行交易。白天去那儿很危险，沿途的街巷到处都是放冷枪的，你还没等到那儿就会被抢。我只去过两次，都是为了稀缺物品（药品、抗生素）迫不得已才去的。<br />
汽车在城里基本没用，因为路上到处是残砖瓦砾、报废的车辆、毁坏的房屋等，汽油也非常贵。无论去哪儿，都最好夜里去。既不能一个人去，也不能人太多。两、三个人为宜：全副武装，动作迅速，走在阴影里。别在街面上走，尽量从废墟中穿行，注意隐蔽。<br />
匪帮规模从10至15人到50人不等，但你、我这样身为人父、甚至祖父的普通人也都抢劫过、杀过人。没什么“好人”和“坏人”，大多数人处于中间，也随时准备落到最坏的极端。</li>
<li>城里没有树吗？为什么你们要烧门窗家具？<br />
没错，城里有过不少树：学校、公园里，甚至机场周围。但相比之下还是建筑和房屋更多。而且一旦连用来做饭、取暖的电力、燃气都没有了，那些树在头两个月里就被砍光了。然后我们找到什么就烧什么：家具、木制的门窗、地板，那些也烧得飞快。</li>
<li>有哪些技能在那种时期最用得上？<br />
请想象石器时代。我们基本上生活在“那种时期”。物尽其用，无所不用其极。<br />
打个比方，我当时有一罐液化气，但我从没直接点过，那太贵了。我在上面连了一根自制的喷嘴，给用光的一次性打火机充气。这些打火机很抢手，我用它们换了不少东西。有人带着空打火机来，我给他灌满，作为交换，他给我一罐食物或是一枝蜡烛。<br />
我是个注册护理员，在那种环境里，医护知识成了我的财富。技多不压身，如果你会修东西，你能过得相当不错。你储备的东西总有吃完用完的时候，但你的一技之长能给你挣来吃的。<br />
我的忠告：学学修东西吧，那可是能让物品——比如鞋子——甚至是人发挥正常功能的本事。<br />
再举个例子：我的邻居会制灯油，他从没饿过。</li>
<li>如果只有三个月，该准备什么？<br />
三个月？那还是准备逃亡吧。开个玩笑:-D<br />
好吧，现在我知道，事态会在短时间内迅速恶化，所以我储备了够半年用的食物、卫生用品、电池。目前我住的公寓安全措施还可以，但五公里外的村庄里我还有栋房子作为庇护所，那儿也有半年的储备。那是个小村子，村里有我很多亲戚，大都贮备充分，战争教育了他们。我有四把枪，每把各配有2000发弹药。那栋房子有一个挺大的花园，我掌握了必要的园艺和农艺知识。<br />
对于危险的直觉很重要。当所有人都跟你说“没事，一切都会好的”，你却基本可以认定：一切就要完蛋了。<br />
到那时，你必须做好“作恶”的准备，为了保护你的孩子和家庭。<br />
重申一点：单靠你自己一个人不可能活下来，就算你有枪，有准备。你要是落单，就死定了。我看过好多次了。准备充分的家庭和组队，各方面的知识技能，有了这些，活下来的机会更大。如果你家人不多，那就几家人（最好是亲戚）一起，找个大房子住下。</li>
<li>该储备那些东西？<br />
看情况。要是你打算以偷抢为生，那你光准备武器和弹药就行——很多弹药。<br />
否则的话，多储备些吃的、卫生用品、电池（干电池、蓄电池都要），用来换东西的物件（刀、打火机、打火石、肥皂）。还有便于保存的酒精，比如廉价威士忌就很受欢迎。我猜很多人想用它麻醉自己，不过我们经常用它来消毒。<br />
很多人死于恶劣的卫生条件。别小看那些不起眼的东西，有的真是多多益善。比如垃圾袋、胶布（电工胶布，用途十分广泛）、厕纸、卫生巾，还有一次性碗、碟、茶杯，不嫌少！我这么说，是因为我们当时完全没有。就我个人而言，卫生用品甚至比食物更重要。你能打下鸽子，能找到可食用的植物，但消毒水可不是天上飞的地上长的。要储备净水药片、消毒水、洗涤剂、漂白粉、肥皂、手套和面罩。还应该储备很多抗生素，并学会使用。要掌握急救知识，学会处理小型伤口、烧伤和枪伤，因为已经没有医院了，而就算你能找到医生，他也未必有药，就算有，你也未必付得起他开的价。<br />
至于武器，越简单越好。我有一把Glock .45，很好用，但因为型号特殊，弹药不好找，所以我还有两把俄制的7.62毫米TT手枪。我不喜欢AK，不过到了后来几乎人手一把，我也不能例外。<br />
某些不起眼的小东西也是必需品。一台发电机固然好，但比不上一千个一次性打火机。因为发电机体积大，引人注目，容易惹麻烦，而打火机简单便携，便于交易。<br />
我们用白铁皮水桶收集雨水，然后储存在大号油桶里，但要记得煮沸消毒。城里有条小河，河水污染很严重，但如果你别无选择……</li>
<li>金银还有用吗？<br />
有。我把家里的金子全都换了弹药。<br />
有时我们也用美元或是德国马克买一些东西，但很少，而且价钱都近乎天文数字：一听炬豆罐头要30到40美元。本国货币很快就变得毫无价值，必需品全靠物物交换获得。</li>
<li>盐贵吗？<br />
贵，但比起咖啡和香烟还是差远了。多囤点儿烟、蜡烛、打火机和干电池，又省地方又受欢迎。酒也不错，我囤了不少，几乎可以当货币用。酒的消耗量几乎是和平时期的十倍。</li>
<li>买枪难吗？<br />
有很多私藏枪支，就看你拿什么换了。但要记住，局势一开始崩溃时的那几天最为混乱，人们的恐慌也最严重。在那种情况下，你可能连搞抢的工夫都没有，而在一片混乱恐慌中手无寸铁可不是什么好事。<br />
我个人的例子：有个人想给他的收音机配一块蓄电池，我用蓄电池换了他的霰弹枪。有时我也用弹药换食品，过了几个星期再用食品换弹药，但从不在家交易，也不大量交易，所以没有人知道我有什么，有多少。只要有钱，有空间，就尽可能的储备物资，最终你会明白什么更有用。总的说来，武器和弹药的重要性可以排第一，第二大概是防毒面具和滤毒罐。</li>
<li>关于安全措施<br />
我们的防御措施很原始，因为当时准备不甚充分，只能就地取材。屋顶在空袭中炸坏了，窗户也炸碎了，我们就用沙袋、石头或者能找到的随便什么东西把窗户堵住。房屋周围有围墙，墙上的出入口都用建筑废料和垃圾堵上了，然后用一架梯子爬进爬出。我们街上还有一位老兄，他把自己的房子的所有出入口封死，然后在和邻居隔壁的墙上开了个洞，每次出门都是夜里从邻居家的废墟里走，一般人很难发现。<br />
说来奇怪，但安全措施最好的房子一般最早被攻陷。我们那儿有些房子有围墙、狗、报警器，窗户还用铁条封住。你猜怎么着？暴民们就爱挑这种房子最先抢。抢下抢不下全看房子里有几把枪，有多少人手。<br />
所以，我认为，有安全措施固然好，但一定记住要保持低调，报警器就算了吧。你的房子最好从外表看上去简陋，不起眼，让人提不起兴趣，内部有大量的枪支弹药，多少都不够。<br />
目前我住的公寓也安装了防盗门，但只是为了抵挡第一波混乱。过后，我就打算逃离城市，加入我的家人和朋友们（至少我希望如此）。不过我也没有完全的把握，一旦城市被军队包围……<br />
我经历的那次中，根本没有发生外逃，因为一切突如其来，一夜之间，城市就被军队包围了。如果你问我，军队是从哪儿来的，为什么我们之前从没见过他们，答案很简单：那支军队原本是我方的友军，一天早晨我们醒来，发现他们忽然成了敌人，而且正在封锁所有出城的的路。我后来听朋友说国内别的地方，尤其是他们所在的乡村情况要好的多：有土地，生长着玉米、小麦、果树，还有农场等等，所以他们食物充足，虽然也有糟糕的地方，但比城里已经强太多了。<br />
我确信，但凡当时我们有机会逃出城，我们一定会出去。但我们没有机会。<br />
扯远了。接着说安全措施吧。我们轮流观察街上的局势，以防匪帮攻击时毫无准备。确保屋里有五名家庭成员随时准备战斗，街上还有一名隐蔽在掩体里的人，必要时提供火力支援。白天我们尽量呆在家里，以免被人放冷枪。其他人家也采取了这种策略，结果各自的防线拉得很近，导致白天街上基本没有人。许多人死于外出打探消息。我们完全没有消息来源：广播、电视，都没了，只有各种谣传。<br />
一开始，弱者纷纷倒下，剩下的人，战斗。大多数时间，你没法分辨一个人是敌还是友，除了我的家人和朋友，每个人都是潜在的敌人。话说回来，如果你朋友遇到你和他孩子必须死一个的情况，你说他会选谁？<br />
在城里不要穿戴什么贵重的东西，一旦被人看见，他们就会杀了你，把东西抢走。也别带太长的枪支，太显眼。<br />
如果明天局势失控，我也会打扮的破破烂烂的，做出惶惶不可终日状，显得绝望、恐惧，甚至也许哭号两嗓子。我可不会穿上崭新的战术服，一面喊道：“我来了！恶棍们，你们完蛋了！”相反，我会躲到一边，武装好，准备好，一边等待时机一边评估我的能力，和我的朋友们、兄弟们一起。</li>
<li>医疗卫生<br />
大多数伤当然是枪伤，如果受伤者能从哪儿找到个大夫，他大概有30%的机会能活下来。不过毕竟不是电影，他们还是死了。有的人甚至死于一点儿小割伤的伤口感染。我有三四种抗生素，不过只是给家里人用的。<br />
有些死法听上去简直令人难以置信：一般人，特别是儿童，连着拉上几天肚子，没有药，也无法补充失去的水分，离死不远矣。对大多皮肤病和食物中毒人们也无计可施。基本上，我们只能找些当地的草药。如果你受了伤，用酒冲洗一下伤口，然后找点儿抗生素吧。紧急处理伤口我还算在行，但对于长期治疗和预后——无能为力。<br />
学些医药知识吧，特别是关于抗生素的。上网查，参加培训，紧急护理技术（EMT）、急救之类的。至少得知道如何进行静脉注射，以便使用某些药品和抗生素。你需要贮备：破伤风注射剂、蛇毒处理器械、肾上腺素注射器械（对付各种过敏反应）、去蜱虫器械（蜱虫叮咬引起的疾病能致死）……最好再准备一些复苏器械，比如氧气瓶、简易人工呼吸器……用法都不难学。<br />
在和平时期，你没有相关执照的话，是不太可能对真人使用这些东西的。不过在非常时期，没有人会要你先出示相关执照的。学会使用方法，然后囤它一大堆医疗器械吧。<br />
粪便要掩埋。最好有厕纸。我们当时没有，即使有，我大概也用来换别的东西了。<br />
再强调一下，最必需的东西是枪和弹药。别的东西都可以换，但没有枪，你连换东西的资格都没有。</li>
</ol>
<h3 id="战争来临的准备工作平民生存手册"><a class="header" href="#战争来临的准备工作平民生存手册">战争来临的准备工作（平民生存手册）</a></h3>
<p>必要储备与使用方法 （转） 　　水 　　没有食物，一个人可以生存1-2个月；但是没有水，生命最多只能支撑10天。一个成人在正常情况下日消耗2-3升水，限量供应下一天至少需要500毫升水。（大瓶可乐为1.25升，冰红茶为500毫升，缺乏量具时可代替使用。） 　　水不用在战前储备，可以在战争爆发，确定所处环境即将缺水时储存。届时把家中所有可以存水的大型器皿全部盛满水（黑色、很结实的塑料袋也可以存水，注意把袋口封好，避光储存），并采取定量供应，有机会就外出采水。 　　净水设备 　　当今城镇附近的水源基本上都是被污染的，在特殊时期更为如此，因此净水设备在战时为必须，具体物资为： 　　明矾、漂白粉、纱布口袋、沙、木炭、大小不一的鹅卵石、过滤桶（用烧红的金属条在塑料水桶底部钻孔可代替过滤桶，小心别烫到手）。 　　户外采集的水需要沉淀、过滤、消毒、煮沸才能饮用，以上列出的物资可以满足净水的全部过程，价格便宜，并且在各地都能买到。 　　取水后，先投入明矾粉末搅拌（比例为每升水0.5克或每立方水500克），然后静置沉淀一夜（如果等水用，也可在两小时内目测沉淀过程是否完成）。 　　第二个步骤是过滤。先把沙装进纱布口袋内，放在过滤桶底部，全部盖住出水口，上置大小不一的木炭颗粒，再依小至大安放鹅卵石，倒入沉淀过的水（沙、木炭、鹅卵石都应覆盖5-10厘米）。 　　在完成过滤的水中按每立方水10克的比例加入漂白粉消毒，搅拌溶解后安置10分钟。此时的水相当于自来水，如饮用就应当煮沸。生活用水可以循环使用，不要轻易倒掉。 　　食物 　　所有食物都应在阴凉、干燥、通风处保存，贴上标签、写明储存日期和保质期，先存的先用，并在战时实行定量配给，以吃到半饱为准（不会饿死的）。因为楼主无法预测战争会持续多长时间，所以请各位自行决定储备的种类和数量。 　　盐： 　　盐份为人体所必需，按年纪、身体状况、气温、和劳动强度不同，一个人平均每天消耗10-15克盐，储备时应选择加碘盐。注意，不能干吞盐粒，那会损伤肾脏，应用开水溶解后饮用或做进菜里（如果那时候你还能弄到新鲜食物）。 　　白糖、醋、烧烤用的各种调料粉： 　　白糖为身体提供热量，水一冲就能喝，也是不错的调味品；醋可以为储备的干肉之类食物增加味道（吃起来别有风味），也可以用来消毒和预防疾病；烧烤用的调味料中含盐份和各种香料，可以撒在食物上或者做汤，储备它的目的也就是让战时饭菜的口味看起来并不那么糟糕。 　　芥末： 　　芥末有很好的消毒杀菌止泻作用，买牙膏状的芥末需冷藏，推荐芥末粉。 　　植物油： 　　植物油为身体提供脂肪酸和维生素E等身体必须品，做菜时也必不可少。一个成人平均每月消耗500克植物油，储存时买大瓶装的，避光保存。 　　大米、面粉： 　　大米和面粉分别为南北方的主食，其淀粉含量基本相同，在缺乏其他食物的情况下，每人每天至少需要500克左右。一般保存时间为两年，如果购买时的包装并不密闭，那么就应该把它装进密闭包装或倒进容器中密闭保存（盖上适合的盖子，边缘塞上布，然后用宽度5-10厘米的胶带纸封口）。 　　番薯干、炒米粉： 　　番薯在新鲜时提供的淀粉和大米面粉差不多，晒干后营养更为浓缩，可以代替主食干嚼食用，如果有亲戚在农村，那一定可以弄到。这东西几乎可以无限期保存，但为保险起见，还是买些结实点的密闭塑料袋封存起来。因为是干缩食品，所以每天的用量可适当减少。炒米粉也是速食食品，营养差一点，在紧急情况下可干吃，也可以冲水食用，只是比较容易受潮，注意密闭保存。 　　鸡蛋： 　　鸡蛋价格便宜、营养丰富、易于保存（抹上油，然后置于阴凉干燥处）、做菜方法多且简单，必要时可以生吃，应多储备。 　　葡萄干、去壳的盐腌花生、笋干、霉干菜、紫菜干： 　　这些东西一般城市中的超市都有售，购买时应该选择大袋、封闭包装。其中葡萄干和花生营养丰富，可以当菜，也可以哄小孩。笋干、霉干菜和紫菜干都是用来做汤的，味道不错，且价格便宜，可长时间保存。 　　干肉、鱼干、虾干或虾皮： 　　干肉类首推咸牛肉和牛肉干，它们营养丰富、口味一流、可保存很长时间；鱼干类首推海鱼干，它们种类繁多、价格便宜、容易保存；虾干或虾皮中含有丰富的营养及矿物质，可在做汤时加入。 　　罐头食品： 　　种类繁多，口味不错，保存时间非常长，但是价格昂贵。如有多余的钱，那可以储备一些。 　　维生素片： 　　因为在战时很难弄到新鲜食物，还是把维生素片列为食物一类，而人体在紧张状态下维生素消耗得非常快，因此要把它当作食物那样储存它。楼主推荐的是21金维他，每瓶可以供一个成人一月的消耗量。 　　药品 　　在使用任何药物之前都应看清保质期，并仔细阅读说明书或遵医嘱，切记。 　　高锰酸钾： 　　在水中加入高锰酸钾充分搅拌，呈红色时可以消毒，呈深红色时可以灭菌。注意，加过高锰酸钾的水不能饮用，只能用作消毒剂。 　　浓度2%的碘酒： 　　碘酒用来消毒、治疗皮肤病，在紧急状态下可以净水（饮用水），具体方法为每500毫升水加入5滴，充分摇晃10-20分钟。 　　抗生素： 　　青霉素、四环素、头孢菌素： 　　抗生素绝不能乱用，其副作用和危害与它们的疗效一样显著，以上所列为常用抗生素的几个大类，在使用前必须遵医嘱或仔细阅读说明书。 　　抗疟疾药、抗痢疾药： 　　在战时我们的生存环境将比现在糟糕百倍，一些非常少见的传染病可能会大肆传播，因此这些药品必须储备。抗疟疾药可以用来预防和治疗，抗痢疾药有预防和治疗两类，它们的种类非常多，药店一般都有售。再说一遍，使用前必须遵医嘱或仔细阅读说明书，在无法准确判断疾病种类时不要乱用药，那只会使情况更糟糕。 　　胃药、止痛药： 　　我们在和平时期吃惯了新鲜可口的饭菜，到了战时身体可能无法立即适应品种单一、存储多时的食物，储备些胃药，可以给身体更多的适应时间。还有，除非到绝对必要的时候，否则不要使用止痛药，它会使医生无法准确判断病情，对身体也有一定的损害，慎用。 　　防治皮肤病类药： 　　在缺水、脏乱环境下患皮肤病的可能性较大，楼主准备的是皮炎平和达克宁，都不错，买两支储存起来。 　　止血药、纱布、消毒棉、绷带： 　　止血药推荐云南白药，其他辅料都可在药店以很便宜的价格买到。要说明的是药品可以买到，但各种护理知识却是买不到的，限于篇幅，本文不做介绍，请自行在互联网上搜索、并学习相关知识，或者有能力的兄弟站出来，再写一篇关于战时护理的文章，谢谢。 　　燃料 　　燃烧会消耗大量氧气，并释放二氧化碳和一氧化碳，所以使用任何燃料都应在窗口或其它通风处。 　　煤、木炭、金属罐装的固体酒精： 　　煤气和天然气是常用燃料，但无法大量储备，也不安全，而煤弄湿了晒干还能燃烧，且价格便宜；木炭无污染，可直接烧烤食物，还要用作过滤，应多备些；固体酒精是在紧急状态下的燃料，非到万不得已不要使用它（在野外可以捡树枝作燃料，用火要小心，临走时熄灭火堆，最好再带走木炭）。 　　其他装备 　　本文是为普通平民准备的，所考虑的就是如何以最少的资金换取最大的安全与生存机会，以下列举的物资一般家里都有，如果购买，价格也比较便宜，并可应付大部分突发事件。 　　口罩、和密闭程度非常高的游泳眼镜： 　　这些装备可以帮助你在大火中分辨道路，免于浓烟和粉尘的袭击，也可以在短时间内作为紧急防毒面具使用。具体制作方法是两三个口罩叠套，当中放上木炭颗粒、沙土、甚至大量剥开的香烟过滤嘴，用水浸湿，缝上边缘；游泳眼镜周围垫上少许浸过水的脱脂棉。需要说明的是这样简陋的装备防护性是非常差的，楼主没有做过相应实验，现场人员必须尽快抵达安全地带。 PS：鉴于2020新冠状病毒事件：大家每年可储备100-200只口罩。成本也就几十元到100多元（在疫情过后，产量充足时储备，每年小投资，比买保险可靠很多）</p>
<p>使用5号电池的AM、FM收音机： 　　要小一点、带耳机的。当电视电话互联网全部中断之时，可能只有收音机才能为你提供消息。需要小心的是在战时会有无数敌台冒充我国zf发送假消息，届时注意分辨。 (SONY大法的700元左右）</p>
<p>PS：此处可一并购买手摇式发电机（1000元左右的可靠性适用性更高）与5号电池充电套装（电池容量尽量买最大款，减少充电次数）。保障设备供电也是特殊时期生命保障的重要措施。 　　口哨： 　　挂在胸前。被埋在废墟下或者其他需要援救时可以用很少的力气引起他人的注意，也可以作为简单的通讯工具。 　　针线、鱼钩： 　　针线的用处非常大，从缝合伤口到补衣服帐篷都要用到它们，储备时应选择不同大小的针，线应包括棉纱线和尼龙制的鱼线（非常柔韧，还可用于捕鱼）。 　　使用5号电池的小手电筒： 　　小手电筒轻便、可随身携带，用作照明与发送信号，电池可与收音机互换，这样只需储备一种电池（不要忘了储备电池）。 　　肥皂、牙膏牙刷、毛巾： 　　肥皂用于日常清洁，也可以洗去化学制剂和沾染核辐射的尘土。注意，为保护环境，即使在战时也应远离水源使用。 　　可随身携带的铲子： 　　在化学战或核战附近可以立即挖坑，并把挖出来的土盖在身上。在野外可用它上厕所——挖个坑，方便后用土盖上。 　　被单、夹子、绳子： 　　被单应挑选全棉的，夹子和绳子的强度要高一点，并至少学会3种打绳结的方法，用它们可以制作吊床、遮阳篷或雨篷，被单撕碎可以当绷带。综合用途很多。 　　火柴、打火机、放大镜、蜡烛： 　　以上物品都是用来引火的，用火柴或打火机点着蜡烛，然后再用蜡烛点火，蜡烛应该多备些，还要用作照明，注意节约使用。 防风打火机比普通的可靠性更高一些。 　　一大瓶50度以上的烈性白酒： 　　在缺水状态下可以为伤口和器皿消毒，必要时也可以当燃料和引火物使用。 　　防水帐篷、毛毯、睡袋： 　　房屋被毁或撤退时使用。毛毯应该每户人家都有，防水帐篷在超市里卖300元左右，普通人家应该负担得起，战前就应练习搭建帐篷。在天气寒冷、无法携带被子的情况下（体积重量都太大），睡袋是个很好的选择，但是价格和帐篷一样昂贵，如果资金不足，那还是拿出备用的衣服，和衣而睡吧。 　　雨衣： 　　雨衣比雨伞好，使用时双手都可以干活，也可以用作挡雨布或接雨水。 　　救生圈： 　　多买几个，在桥梁被za断或紧急渡河用，不仅是人可以用，在手推车上捆几个，并配合牵引绳的帮助也可以让它安然渡河。 　　手套、鞋： 　　应准备三种手套：防寒手套（气温寒冷时使用）、线织手套（干粗活时使用）、橡胶手套（面对污染物品或其他紧急状况下使用）。三双鞋：球鞋（用于长途跋涉）、拖鞋（在夏季或过浅滩时使用）、大一号的雨鞋（天气寒冷且下雨时使用，垫上厚鞋垫，多穿几双袜子或塞入保暖物）。 　　指南针、地图： 　　撤退时的必须品，但要事先学会使用。 　　袖珍工具箱： 　　在战时你可能需要自行维修各种物品或房屋，工具箱是必不可少的。 　　刀、小型多用途组合刀具： 　　需要一柄长度在20厘米左右、带刀鞘的不锈钢刀，用途很多，在战时应随身携带，最好是做个坚固的挂带，当右手自然下垂时正好可以握住刀柄（如果你习惯使用右手），方便随时拔刀。可随身携带小型多用途组合刀具是必不可少的，德国双立人和瑞士军刀是极品，可惜价格太高了，挑选质量好些的国产刀具，性价比也不错的。 　　笔记本、笔： 　　要小一点，可随身携带的。写下拥有的所有物资，每天记录使用情况和剩余。 　　便携式烧烤炉、小号铁锅、铝制饭盒、汤勺： 　　身处野外时有这些装备可以省不少事情，价格也不贵。 　　质地坚固的塑料袋： 　　用途广泛（比如充气后不慎落水时可当救生圈、还可以用作储水），应多储备。 　　带包装的消毒纸巾： 　　用途很多（保洁、引火、止血、保暖），注意节约使用。 　　登山包、超市用的手推车、防水帆布： 　　这是撤退时的必备品。登山包应挑选重量轻、强度高的，即使价格贵一些也是值得的。超市里的手推车价格便宜、载重量大（有效负载在150公斤以上）、结构简单，且轮子是实芯的，就算被钉子什么的戳破了也可以照常使用，撤退时用硬纸板做内衬，挡住底部和边缘，装入物品后用帆布覆盖，并用绳子捆扎严实。 　　以上列举的所有物资（包括供应三口之家一年的粮食燃料药品在内），大约共花费5000元左右，一般家庭应该都能负担，但是那些挣扎在生存线上的同胞，希望战时的zf可以凭票分配食物和其他生活必须品，尽可能让更多人可以在这场战争中生存下去。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="面向对象理论"><a class="header" href="#面向对象理论">面向对象理论</a></h1>
<pre><code>* [区分类和对象](#区分类和对象)
</code></pre>
<ul>
<li><a href="%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%90%86%E8%AE%BA.html#%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8">方法调用</a>
<ul>
<li><a href="%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%90%86%E8%AE%BA.html#%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E5%8F%AF%E4%BB%A5%E7%9B%B4%E6%8E%A5%E8%B0%83%E7%94%A8">静态方法可以直接调用</a></li>
<li><a href="%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%90%86%E8%AE%BA.html#%E9%9D%9E%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E9%9C%80%E8%A6%81%E5%85%88%E5%AE%9E%E4%BE%8B%E5%8C%96%E5%AF%B9%E8%B1%A1">非静态方法需要先实例化对象</a></li>
<li><a href="%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%90%86%E8%AE%BA.html#%E5%80%BC%E4%BC%A0%E9%80%92">值传递</a></li>
</ul>
</li>
<li><a href="%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%90%86%E8%AE%BA.html#%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA">类与对象的创建</a></li>
<li><a href="%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%90%86%E8%AE%BA.html#%E6%9E%84%E9%80%A0%E5%99%A8%E8%AF%A6%E8%A7%A3">构造器详解</a>
<ul>
<li><a href="%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%90%86%E8%AE%BA.html#%E6%97%A0%E5%8F%82%E6%9E%84%E9%80%A0">无参构造</a></li>
<li><a href="%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%90%86%E8%AE%BA.html#%E6%9C%89%E5%8F%82%E6%9E%84%E9%80%A0">有参构造</a></li>
</ul>
</li>
<li><a href="%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%90%86%E8%AE%BA.html#%E4%B8%89%E5%A4%A7%E5%B1%9E%E6%80%A7">三大属性</a>
<ul>
<li><a href="%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%90%86%E8%AE%BA.html#%E5%B0%81%E8%A3%85">封装</a></li>
<li><a href="%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%90%86%E8%AE%BA.html#%E7%BB%A7%E6%89%BF">继承</a>
<ul>
<li><a href="%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%90%86%E8%AE%BA.html#super%E8%AF%A6%E8%A7%A3">Super详解</a></li>
<li><a href="%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%90%86%E8%AE%BA.html#%E6%96%B9%E6%B3%95%E9%87%8D%E5%86%99">方法重写</a></li>
</ul>
</li>
<li><a href="%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%90%86%E8%AE%BA.html#%E5%A4%9A%E6%80%81">多态</a>
<ul>
<li><a href="%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%90%86%E8%AE%BA.html#instanceof%E5%92%8C%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2">Instanceof和类型转换</a>
<ul>
<li><a href="%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%90%86%E8%AE%BA.html#%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2">类型转换</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%90%86%E8%AE%BA.html#static%E5%85%B3%E9%94%AE%E5%AD%97">Static关键字</a>
<ul>
<li><a href="%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%90%86%E8%AE%BA.html#%E9%9D%99%E6%80%81%E5%AF%BC%E5%85%A5%E5%8C%85">静态导入包</a></li>
</ul>
</li>
<li><a href="%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%90%86%E8%AE%BA.html#%E6%8A%BD%E8%B1%A1%E7%B1%BB">抽象类</a></li>
<li><a href="%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%90%86%E8%AE%BA.html#%E6%8E%A5%E5%8F%A3">接口</a></li>
<li><a href="%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%90%86%E8%AE%BA.html#n%E7%A7%8D%E5%86%85%E9%83%A8%E7%B1%BB">N种内部类</a>
<ul>
<li><a href="%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%90%86%E8%AE%BA.html#%E7%89%B9%E6%AE%8A%E5%86%85%E9%83%A8%E7%B1%BB">特殊内部类</a></li>
<li><a href="%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%90%86%E8%AE%BA.html#%E6%88%90%E5%91%98%E5%86%85%E9%83%A8%E7%B1%BB">成员内部类</a></li>
<li><a href="%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%90%86%E8%AE%BA.html#%E9%9D%99%E6%80%81%E5%86%85%E9%83%A8%E7%B1%BB">静态内部类</a></li>
<li><a href="%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%90%86%E8%AE%BA.html#%E5%B1%80%E9%83%A8%E5%86%85%E9%83%A8%E7%B1%BB">局部内部类</a></li>
<li><a href="%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%90%86%E8%AE%BA.html#%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB">匿名内部类</a></li>
</ul>
</li>
<li><a href="%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%90%86%E8%AE%BA.html#java%E5%A4%9A%E6%80%81%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB">java多态和抽象类</a>
<ul>
<li><a href="%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%90%86%E8%AE%BA.html#%E5%8C%85%E4%B9%8B%E9%97%B4%E7%9A%84%E4%BA%92%E7%9B%B8%E8%B0%83%E7%94%A8ide%E5%8F%AF%E8%A1%8C%E4%BD%86terminal%E4%B8%8D%E8%A1%8C%E4%B8%8D%E7%9F%A5%E5%8E%9F%E5%9B%A0">包之间的互相调用（ide可行但terminal不行，不知原因）</a></li>
<li><a href="%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%90%86%E8%AE%BA.html#%E7%B1%BB%E7%9A%84%E5%BA%94%E7%94%A8%E5%AE%9E%E4%BE%8B">类的应用实例</a>
<ul>
<li><a href="%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%90%86%E8%AE%BA.html#%E6%B3%A8super%E7%9A%84%E4%B8%89%E7%A7%8D%E7%94%A8%E6%B3%95">注：super的三种用法</a></li>
<li><a href="%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%90%86%E8%AE%BA.html#%E6%B3%A8this%E7%9A%84%E4%B8%89%E7%A7%8D%E7%94%A8%E6%B3%95">注：this的三种用法</a></li>
<li><a href="%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%90%86%E8%AE%BA.html#%E4%B8%89%E7%A7%8D%E5%8F%98%E9%87%8F%E7%9A%84%E5%8C%BA%E5%88%AB">三种变量的区别</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<p>面向对象Object-Oriented Programming</p>
<p>本质：<strong>以类的方式组织代码，以对象的组织（封装）数据</strong></p>
<p>抽象</p>
<p>三大特性：封装、继承、多态</p>
<h3 id="区分类和对象"><a class="header" href="#区分类和对象">区分类和对象</a></h3>
<p>1.对象是实体，需要被创建，可以为我们做事情</p>
<p>如这只猫</p>
<ul>
<li>表达东西或事件</li>
<li>运行时响应消息（提供服务）</li>
</ul>
<p>对象=属性+服务</p>
<p>数据：属性或状态</p>
<p>操作：函数</p>
<p>封装：内数据外操作</p>
<p>2.类是规范，根据类的定义来创建对象</p>
<p>如猫</p>
<ul>
<li>定义所有猫的属性</li>
<li>就是java中的类型</li>
<li>可以用来定义变量</li>
</ul>
<p>例子：自动售货机</p>
<pre><code class="language-java">public class VendingMachine {
	
	
	int price=80;
	int balance;
	int total;
	//3个属性即类定义的对象中所具有的成员变量
	int f(){
		return 10;	
	}
	
	VendingMachine(){  //构造函数：成员函数名字和类的名字完全相同，在创建这个类的每一个对象的时候会自动调用这个函数，这个函数不能有返回类型
		total = 0;	
	}
	VendingMachine(int price){ 
        this();//调用另一个构造函数，只能在开头用一次
		this.price = price;	
	}
	
	void setPrice(int price){
		this.price = price;
		this.getFood();//在成员函数内部直接调用自己(this)的其他函数
	}
	
    
    void showPrompt(){
	      System.out.println("Welcome");	
	}
	
	void insertMoney(int amount){
		balance = balance+amount;
	}
	
	void showBalance(){
	      System.out.println(balance);	
	}
	void getFood(){
		if(balance&gt;=price){
			 System.out.println("Here you are.");	
			balance = balance-price;
			total=total+price;
		}
	}
	
	//四个动作
	
	
	public static void main(String[] args) {
		VendingMachine vm = new VendingMachine();//创建对象，对象变量是对象的管理者，不是所有者
		vm.showPrompt();
		vm.showBalance();
		vm.insertMoney(100);
		vm.getFood();
		vm.showBalance();
        
        VendingMachine vm1 = new VendingMachine(100);
		vm1.insertMoney(200);
		vm1.showBalance();
		vm1.getFood();
		vm1.showBalance();
	}
}

</code></pre>
<p>一个类可以有多个构造函数，只要它们的参数表不同。创造对象的时候给出不同的参数值，就会调用不同的构造函数，通过this()还可以调用其他构造函数，一个类里同名但参数表不同的函数构成<code>重载</code>关系。</p>
<pre><code class="language-java">Welcome
10
Here you are.
30
210
Here you are.
110
</code></pre>
<p>本地变量：定义在函数内部的变量，生存期与作用域都是函数内部</p>
<p>成员变量：类中定义的变量，成员变量的生存期是对象的生存期，作用域是类内部的成员函数</p>
<p>成员变量在定义的地方就可以给出初始值，没有给出初始值的成员变量会自动获得零值，对象变量的0值表示没有任何管理对象，也可以主动给null值</p>
<p>定义初始化可以调用函数，甚至可以使用已经定义的成员变量</p>
<h1 id="方法调用-1"><a class="header" href="#方法调用-1">方法调用</a></h1>
<p>带static的方法和类一起加载,而不带static的方法需要类实例化後才能加载</p>
<h2 id="静态方法可以直接调用"><a class="header" href="#静态方法可以直接调用">静态方法可以直接调用</a></h2>
<p>类名.方法()</p>
<pre><code class="language-java">package oop;

public class Student {
    public static void say() {
        System.out.println("学生说话了!!");
    }
}
</code></pre>
<pre><code class="language-java">package oop;

public class Demo2 {
    public static void main(String[] args) {
        Student.say();
    }
}
</code></pre>
<p>输出结果:</p>
<pre><code class="language-txt">学生说话了!!
</code></pre>
<h2 id="非静态方法需要先实例化对象"><a class="header" href="#非静态方法需要先实例化对象">非静态方法需要先实例化对象</a></h2>
<p>用new实例化这个类</p>
<pre><code class="language-java">package oop;

public class Student {
    public void say() {
        System.out.println("学生说话了!!");
    }
}
</code></pre>
<pre><code class="language-java">package oop;

public class Demo2 {
    public static void main(String[] args) {
        //对象类型 对象名 = 对象值
        Student student = new Student();
        student.say();
    }
}
</code></pre>
<p>输出结果:</p>
<pre><code class="language-txt">学生说话了!!
</code></pre>
<h2 id="值传递"><a class="header" href="#值传递">值传递</a></h2>
<pre><code class="language-java">package oop;

public class Demo3 {
    public static void main(String[] args) {
        int a = 1;
        System.out.println(a);
        Demo3.change(a);
        System.out.println(a);
    }
    //返回值为空
    public static void change(int a ){
        a = 10;
    }
}
</code></pre>
<p>输出结果为</p>
<pre><code class="language-txt">1
1
</code></pre>
<h1 id="类与对象的创建"><a class="header" href="#类与对象的创建">类与对象的创建</a></h1>
<p>面向对象Object-Oriented Programming</p>
<p>本质：<strong>以类的方式组织代码，以对象的组织（封装）数据</strong></p>
<pre><code class="language-java">package oop;

public class Student {
    //属性：字段
    String name;//模板，不能直接赋值
    int age;

    //方法
    public void study() {
        System.out.println(this.name+"在学习!!");
    }
}
</code></pre>
<pre><code class="language-java">package oop;
//一个项目应该只存在一个main方法
public class Application {
    public static void main(String[] args) {
        //类是抽象的，需要实例化
        //类实例化後会返回一个自己的对象
        //student对象是Student类的一个具体实例
        Student student = new Student();
        System.out.println(student.name);
        student.name = "小豹子";//需要用""
        System.out.println(student.name);
    }
}
</code></pre>
<p>输出结果：</p>
<pre><code class="language-txt">null
小豹子
</code></pre>
<h1 id="构造器详解"><a class="header" href="#构造器详解">构造器详解</a></h1>
<p>使用new关键字创建和初始化对象，除了分配内存空间之外，还会给创建好的对象进行默认的初始化以及对类中构造器的调用。</p>
<p>类中的构造器也被成为构造方法，是在进行创建对象时侯必须要调用的，并且构造器具有以下两个特点：</p>
<ul>
<li>必须和类的名字相同</li>
<li>必须没有返回类型，也不能写void</li>
</ul>
<h3 id="无参构造"><a class="header" href="#无参构造">无参构造</a></h3>
<pre><code class="language-java">package oop;

public class Person {
    //一个类即使什么都不写，它也会存在一个方法
    //显式定义构造器
    String name;

    //实例化初始值
    //1.使用new关键字，本质上是调用构造器
    //2.用来初始化值
    public Person(){
        this.name = "RM";

    }
}
</code></pre>
<pre><code class="language-java">package oop;
//一个项目应该只存在一个main方法
public class Application {
    public static void main(String[] args) {
        //new 实例化了一个对象
        Person person = new Person();
        System.out.println(person.name);
    }
}
</code></pre>
<p>输出RM</p>
<h3 id="有参构造"><a class="header" href="#有参构造">有参构造</a></h3>
<pre><code class="language-java">package oop;

public class Person {
    //一个类即使什么都不写，它也会存在一个方法
    //显式定义构造器
    String name;

    //实例化初始值
    //1.使用new关键字，本质上是调用构造器
    //2.用来初始化值
    public Person(){

    }
    //有参构造：一旦定义了有参构造，无参构造必须显式定义
    public Person(String name){
        this.name = name;//和上面的不同
    }
}

</code></pre>
<pre><code class="language-java">package oop;
//一个项目应该只存在一个main方法
public class Application {
    public static void main(String[] args) {
        //new 实例化了一个对象
        Person person = new Person("kuangshen");
        System.out.println(person.name);
    }
}
</code></pre>
<p>输出kuangshen</p>
<p>只有有参构造，而无无参构造，将会报错，要默认无参构造为空</p>
<p>快捷键Alt+Insert</p>
<pre><code class="language-txt">java: 无法将类 oop.Person中的构造器 Person应用到给定类型;
  需要: java.lang.String
  找到: 没有参数
  原因: 实际参数列表和形式参数列表长度不同
</code></pre>
<pre><code class="language-java">package oop;

public class Person {
    //一个类即使什么都不写，它也会存在一个方法
    //显式定义构造器
    String name;

    //实例化初始值
    //1.使用new关键字，本质上是调用构造器
    //2.用来初始化值
    
    //有参构造：一旦定义了有参构造，如果想使用无参构造，无参构造必须显式定义
    public Person(String name){
        this.name = name;
    }

}
</code></pre>
<pre><code class="language-java">package oop;
//一个项目应该只存在一个main方法
public class Application {
    public static void main(String[] args) {
        //new 实例化了一个对象
        Person person = new Person();
        System.out.println(person.name);
    }
}
</code></pre>
<h1 id="三大属性"><a class="header" href="#三大属性">三大属性</a></h1>
<h2 id="封装"><a class="header" href="#封装">封装</a></h2>
<p>追求高内聚，低耦合</p>
<p><strong>属性私有，get/set</strong></p>
<p>好处：</p>
<ul>
<li>提高程序的安全性，保护数据</li>
<li>隐藏代码的实现细节</li>
<li>提高系统的可维护性</li>
<li>统一接口</li>
</ul>
<p>IDEA中按右键选择generator，选中setter/getter，自动生成</p>
<pre><code class="language-java">package oop;

public class Student {
    //属性私有
    private String name;
    private int id;
    private char gender;
    //提供一些可以操作这个属性的方法
    //如提供一些get/set方法
    //get获得这个数据
    public String getName(){
        return this.name;
    }
    //set给这个属性设置值
    public void setName(String name){
        this.name=name;
    }
}
</code></pre>
<pre><code class="language-java">package oop;

//一个项目应该只存在一个main方法
public class Application {
    public static void main(String[] args) {

        Student student = new Student();
        student.setName("RM");
        System.out.println(student.getName());
    }
}
</code></pre>
<p>输出结果：RM</p>
<pre><code class="language-java">package oop;

public class Student {
    //属性私有
    private String name;
    private int id;
    private char gender;
    private int age;
    //提供一些可以操作这个属性的方法
    //如提供一些get/set方法
    //get获得这个数据
    public String getName(){
        return this.name;
    }
    //set给这个属性设置值
    public void setName(String name){
        this.name=name;
    }

    public int getId() {
        return id;
    }

    public void setId(int id) {
        this.id = id;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        //检查输入格式
        if(age&gt;120||age&lt;0){
            this.age = 3;
        }else{
            this.age = age;
        }
    }
}
</code></pre>
<pre><code class="language-java">package oop;

//一个项目应该只存在一个main方法
public class Application {
    public static void main(String[] args) {

        Student student = new Student();
        student.setName("RM");
        System.out.println(student.getName());
        student.setAge(999);
        System.out.println(student.getAge());
    }
}
</code></pre>
<p>输出结果：</p>
<pre><code class="language-txt">RM
3
</code></pre>
<h2 id="继承"><a class="header" href="#继承">继承</a></h2>
<p>本质是对某一批类的抽象，Java中类只有单继承，单继承意思是只有一个直接父类，ctrl+H查看继承关系</p>
<p>关键字extends</p>
<p>父类</p>
<pre><code class="language-java">package oop;

public class Person {
    public void say(){
        System.out.println("川普说话了！");
    }
}

</code></pre>
<p>子类：子类继承父类所有的public方法，在java中都默认直接或间接继承Object类</p>
<pre><code class="language-java">package oop;

public class Student extends Person {

}

</code></pre>
<pre><code class="language-java">package oop;

import oop.Student;

//一个项目应该只存在一个main方法
public class Application {
    public static void main(String[] args) {

        Student student = new Student();

        student.say();

    }
}
</code></pre>
<p>输出结果：</p>
<pre><code class="language-txt">川普说话了！
</code></pre>
<h3 id="super详解"><a class="header" href="#super详解">Super详解</a></h3>
<p>super注意点：</p>
<ul>
<li>super调用父类的构造方法，必须在构造方法的第一个</li>
<li>super必须只能出现在子类的方法或构造方法中</li>
<li>super和this不能同时调用构造方法</li>
</ul>
<p>super VS this：</p>
<ul>
<li>代表对象不同：this代表本身调用者这个对象，super代表父类对象的应用</li>
<li>使用前提不同：this没有继承也可以调用，super只有在继承条件下调用</li>
<li>构造方法不同：this()是本类的构造，而super()是父类的构造</li>
</ul>
<pre><code class="language-java">package oop;

public class Person {
    protected String name = "kuangshen";
}
</code></pre>
<pre><code class="language-java">package oop;

public class Student extends Person {
    private  String name = "RM";

    public void test(String name){
        System.out.println(name);//传入的参数如孔夫子
        System.out.println(this.name);//RM，Student类
        System.out.println(super.name);//kuangshen，父类Person
    }

}
</code></pre>
<pre><code class="language-java">package oop;

import oop.Student;

//一个项目应该只存在一个main方法
public class Application {
    public static void main(String[] args) {

        Student student = new Student();

        student.test("孔夫子");

    }
}
</code></pre>
<p>输出结果</p>
<pre><code class="language-txt">孔夫子
RM
kuangshen
</code></pre>
<pre><code class="language-java">package oop;

public class Person {
    protected String name = "kuangshen";

    public void print(){
        System.out.println("Person");
    }
}
</code></pre>
<pre><code class="language-java">package oop;

public class Student extends Person {
    private  String name = "RM";

    public void print(){
        System.out.println("Student");
    }

    public void test(){
        print();//Student
        this.print();//Student
        super.print();//Person
    }

}
</code></pre>
<pre><code class="language-java">package oop;

import oop.Student;

//一个项目应该只存在一个main方法
public class Application {
    public static void main(String[] args) {

        Student student = new Student();

        student.test();

    }
}
</code></pre>
<p>输出结果</p>
<pre><code class="language-txt">Student
Student
Person
</code></pre>
<pre><code class="language-java">package oop;

public class Person {

    public Person() {
        System.out.println("Person无参执行了！");
    }

    protected String name = "kuangshen";

    public void print(){
        System.out.println("Person");
    }
}
</code></pre>
<pre><code class="language-java">package oop;

public class Student extends Person {

    public Student() {
        //这里存在隐藏代码super();，调用了父类的无参构造
        //super();//Call to 'super()' must be first statement in constructor body
        System.out.println("Student无参执行了！");
    }

    private  String name = "RM";

    public void print(){
        System.out.println("Student");
    }

    public void test(){
        print();//Student
        this.print();//Student
        super.print();//Person
    }

}
</code></pre>
<pre><code class="language-java">package oop;

import oop.Student;

//一个项目应该只存在一个main方法
public class Application {
    public static void main(String[] args) {

        Student student = new Student();
    }
}
</code></pre>
<p>输出结果：</p>
<pre><code class="language-txt">Person无参执行了！
Student无参执行了！
</code></pre>
<h3 id="方法重写"><a class="header" href="#方法重写">方法重写</a></h3>
<p>快捷键ctrl+O</p>
<p>重写都是方法的重写，与属性无关。</p>
<p>重写：需要有继承关系，子类重写父类的<code>非静态</code>方法体，执行子类自己的方法！</p>
<ul>
<li>方法名必须相同</li>
<li>参数列表必须相同</li>
<li>修饰符：范围可以扩大，但不能缩小public&gt;protected&gt;default&gt;private</li>
<li>抛出的异常范围可以被缩小，但不能扩大：ClassNotFoundException - &gt; Exception（大）</li>
</ul>
<p>重写原因：父类的方法不一定满足子类的要求</p>
<p>静态方法</p>
<pre><code class="language-java">package oop;

public class B {
    public  static void test(){
        System.out.println("B=&gt;test");
    }
}
</code></pre>
<pre><code class="language-java">package oop;

public class A extends B{
    public static void test() {
        System.out.println("A=&gt;test");
    }
}
</code></pre>
<pre><code class="language-java">package oop;

public class Application {
    public static void main(String[] args) {

        //静态方法的调用只和左边即定义的数据类型有关
        A a = new A();
        a.test();//A

        //父类的引用指向了子类
        B b = new A();
        b.test();//B
    }
}
</code></pre>
<pre><code class="language-txt">A=&gt;test
B=&gt;test
</code></pre>
<p>非静态方法：重写Override</p>
<pre><code class="language-java">package oop;

public class B {
    public  void test(){
        System.out.println("B=&gt;test");
    }
}
</code></pre>
<pre><code class="language-java">package oop;

public class A extends B{
    @Override//重写@代表有功能的注释
    public void test() {
        //super.test();
        System.out.println("A=&gt;test");

    }
}
</code></pre>
<pre><code class="language-java">package oop;

public class Application {
    public static void main(String[] args) {

        A a = new A();
        a.test();//A

        B b = new A();
        b.test();//重写：需要有继承关系，子类重写父类的方法体，执行子类自己的方法！
    }
}
</code></pre>
<p>输出结果</p>
<pre><code class="language-txt">A=&gt;test
A=&gt;test//重写：需要有继承关系，子类重写父类的方法体，执行子类自己的方法！
</code></pre>
<p>静态属于类，含static、final、private的不能重写；非静态属于对象，可以重写（有static看左边，没有static看右边）</p>
<h2 id="多态"><a class="header" href="#多态">多态</a></h2>
<p>含义：同一个方法可以根据发送对象的不同而采用不同的行为方式</p>
<p>一个对象的实际类型是确定的，但能指向对象的引用类型可以不确定，父类的调用指向子类</p>
<p>要点：</p>
<ul>
<li>多态是方法的多态，不是属性的多态</li>
<li>父类和子类必须有联系</li>
<li>存在继承关系，方法需要重写（重写：需要有继承关系，子类重写父类、子类相同的方法的方法体，执行子类自己的方法，否则还执行父类的方法！），父类引用指向字类对象（如Father f1 = new Son();）</li>
</ul>
<p>父类类型的引用可以调用父类中定义的所有属性和方法，而对于子类中定义而父类中没有的方法，父类的引用是不能调用的。</p>
<p>同时，父类中的一个方法只有在在父类中定义而在子类中没有重写的情况下，才可以被父类类型的引用调用父类的方法。</p>
<p>对于父类中定义的方法，如果子类中重写了该方法，那么父类类型的引用将会调用子类中的这个方法，这就是动态连接。</p>
<pre><code class="language-java">//一个对象的实际类型是确定的
//但指向的引用类型可以不确定，父类的调用指向子类
Student s1 = new Student();
Person s2 = new Student();
Object s3 = new Student();
</code></pre>
<pre><code class="language-java">package oop;

public class Person {

    public void run(){
        System.out.println("Run");
    }
}
</code></pre>
<pre><code class="language-java">package oop;

public class Student extends Person {

    @Override
    public void run() {
        System.out.println("Son");
    }
    public void eat(){
        System.out.println("Eat");
    }
}
</code></pre>
<pre><code class="language-java">package oop;

public class Application {
    public static void main(String[] args) {

        //一个对象的实际类型是确定的，但能指向对象的引用类型可以不确定，父类的引用可以指向子类
        //子类Student能调用的方法都是自己的或是继承自父类Person的
        Student s1 = new Student();
        //Person是父类，可以指向子类，但不能调用子类独有的方法
        Person s2 = new Student();
        Object s3 = new Student();

        s1.run();//son原因：子类重写父类的方法体，执行子类自己的方法！
        s2.run();//son原因：子类重写父类的方法体，执行子类自己的方法！

        //对象能执行哪些方法，主要看对象左边类型，和右边的关系不大
        s1.eat();//s2.eat()报错
        }
}
</code></pre>
<p>输出结果：</p>
<pre><code class="language-txt">Son
Son
Eat
</code></pre>
<h3 id="instanceof和类型转换"><a class="header" href="#instanceof和类型转换">Instanceof和类型转换</a></h3>
<pre><code class="language-java">package oop;

public class Person {

    public void run(){
        System.out.println("Run");
    }
}
</code></pre>
<pre><code class="language-java">package oop;

public class Student extends Person {

    @Override
    public void run() {
        System.out.println("Son");
    }
    public void eat(){
        System.out.println("Eat");
    }
}
</code></pre>
<pre><code class="language-java">package oop;


public class Teacher extends Person{
    public static void main(String[] args) {

    }
}
</code></pre>
<pre><code class="language-java">package oop;

public class Application {
    public static void main(String[] args) {

        //Object&gt;Person&gt;Student
        //Object&gt;Person&gt;Teacher
        //Object&gt;String
        Object object = new Student();

        System.out.println(object instanceof Student);//true
        System.out.println(object instanceof Person);//true
        System.out.println(object instanceof Object);//true
        System.out.println(object instanceof Teacher);//false
        System.out.println(object instanceof String);//false

        System.out.println("=====================");

        Person person = new Student();

        System.out.println(person instanceof Student);//true
        System.out.println(person instanceof Person);//true
        System.out.println(person instanceof Object);//true
        System.out.println(person instanceof Teacher);//false
        //System.out.println(person instanceof String);//编译报错

        System.out.println("=====================");


        Student student = new Student();

        System.out.println(student instanceof Student);//true
        System.out.println(student instanceof Person);//true
        System.out.println(student instanceof Object);//true
        //System.out.println(student instanceof Teacher);//编译报错
        //System.out.println(student instanceof String);//编译报错

        }
}
</code></pre>
<h4 id="类型转换-1"><a class="header" href="#类型转换-1">类型转换</a></h4>
<p>要点：</p>
<ul>
<li>父类引用可以指向子类的对象</li>
<li>把子类转换为父类，向上转换</li>
<li>把父类转换为子类，向下转换：需强制</li>
<li>好处：方便调用方法，减少重复代码</li>
</ul>
<pre><code class="language-java">package oop;

public class Person {

    public void run(){
        System.out.println("run");
    }
}
</code></pre>
<pre><code class="language-java">package oop;

public class Student extends Person {

    public void go() {
        System.out.println("go");
    }
}
</code></pre>
<pre><code class="language-java">package oop;

public class Application {
    public static void main(String[] args) {

        //类型之间相互转化：父类（高类型）---&gt;子类（低类型）
        //高 ---&gt;低
        Person object = new Student();
        //object.go();//编译报错

        //student将这个对象转换为Student类型後才可以使用Student类型的方法
        Student student = (Student)object;
        student.go();
        //子类转换为父类，可能丢失一些固有的方法
        Student student1 = new Student();
        student1.go();
        Person person = student1;
        //person.go();//编译报错


        }
}
</code></pre>
<h1 id="static关键字"><a class="header" href="#static关键字">Static关键字</a></h1>
<pre><code class="language-java">package oop;

public class Student  {

    private static  int age;//静态变量或称为类变量，可以被所有实例共享
    private double score;//非静态变量
    
    public void go() {
        
        System.out.println("go");
    }

    public static void main(String[] args) {
        Student s1 = new Student();

        //类
        System.out.println(Student.age);
        //System.out.println(Student.score);//编译报错
        //对象
        System.out.println(s1.age);
        System.out.println(s1.score);
    }
}
</code></pre>
<pre><code class="language-java">package oop;

public class Student  {

    private static  int age;//静态变量或称为类变量，可以被所有实例共享
    private double score;//非静态变量
    
    public void run(){
        
    }

    public static void go() {

        System.out.println("go");
    }

    public static void main(String[] args) {
        go();
        //run();//Non-static method 'run()' cannot be referenced from a static context
    }
}
</code></pre>
<p><strong>静态方法只能调用静态方法，而非静态方法既可以调用非静态方法，也可以调用静态方法</strong></p>
<pre><code class="language-java">package oop;

public class Person {

    {
        System.out.println("匿名代码块");
    }
    
    static{
        System.out.println("静态代码块");
    }
    public Person(){
        System.out.println("构造方法");
    }

    public static void main(String[] args) {
        Person person = new Person();

    }
}
</code></pre>
<p>输出结果：</p>
<pre><code class="language-txt">静态代码块
匿名代码块
构造方法
</code></pre>
<pre><code class="language-java">package oop;

public class Person {

    {
        System.out.println("匿名代码块");//可以用来赋初值
    }
    static{
        System.out.println("静态代码块");//和类一起加载，第一个执行，且只执行一次
    }
    public Person(){
        System.out.println("构造方法");
    }

    public static void main(String[] args) {
        Person person1 = new Person();
        System.out.println("=====================");
        Person person2 = new Person();

    }
}
</code></pre>
<pre><code class="language-txt">静态代码块
匿名代码块
构造方法
=====================
匿名代码块
构造方法
</code></pre>
<h3 id="静态导入包"><a class="header" href="#静态导入包">静态导入包</a></h3>
<pre><code class="language-java">package method;

public class Calculator {
    public static void main(String[] args) {

        System.out.println(Math.random());
    }
}
</code></pre>
<pre><code class="language-java">package method;

import static  java.lang.Math.random;

public class Calculator {
    public static void main(String[] args) {

        System.out.println(random());
    }
}
</code></pre>
<h1 id="抽象类"><a class="header" href="#抽象类">抽象类</a></h1>
<p>Action.java</p>
<pre><code class="language-java">package oop;

//abstract 抽象类：类 extends只能单继承， 但接口可以多继承
public abstract class Action {
    //abstract，抽象方法，只有方法名字，没有方法的实现！
    public abstract void doSomething();

    //特点1：不能new抽象类，只能靠子类去实现它：约束！
    //特点2：抽象类中可以写普通的方法
    //特点3：抽象方法必须在抽象类中
    //抽象的抽象：约束～
    public static void main(String[] args) {
        System.out.println("有构造器吗？");
    }
}
</code></pre>
<p>Action.class</p>
<pre><code class="language-java">//
// Source code recreated from a .class file by IntelliJ IDEA
// (powered by FernFlower decompiler)
//

package oop;

public abstract class Action {
    public Action() {
    }

    public abstract void doSomething();

    public static void main(String[] args) {
        System.out.println("有构造器吗？");
    }
}
</code></pre>
<h1 id="接口"><a class="header" href="#接口">接口</a></h1>
<p>声明类的关键字是class，声明接口的关键字是interface</p>
<p>对比：</p>
<ul>
<li>普通类：只有具体实现</li>
<li>抽象类：具体实现和规范（抽象方法）都有</li>
<li>接口：只有规范，自己无法写方法</li>
</ul>
<p>接口就是规范。作用：</p>
<ul>
<li>约束</li>
<li>定义一些方法，让不同的人实现</li>
<li>public abstract 方法</li>
<li>public static final 变量=&gt;常量</li>
<li>接口不能被实例化，接口中没有构造方法</li>
<li>implements可以实现多个接口</li>
<li>必须重写接口中的方法</li>
</ul>
<pre><code class="language-java">package oop;

public interface UserService {

    //接口中所有定义都是抽象的，接口都要有实现类

    public abstract void add(String name);
    //编译报错Interface abstract methods cannot have body
    //Modifier 'public' is redundant for interface methods
    //Modifier 'abstract' is redundant for interface methods
    void delete(String name);
    void update(String name);
    void query(String name);


    public static final int age = 99;
    //Modifier 'public' is redundant for interface fields
    //Modifier 'static' is redundant for interface fields
    //Modifier 'final' is redundant for interface fields
}
</code></pre>
<pre><code class="language-java">package oop;

public interface TimeService {
    void timer();
}

</code></pre>
<pre><code class="language-java">package oop;

//抽象类：单继承
//类可以是实现接口，implements 接口
//实现了接口的类就需要重写接口中方法
//利用接口实现多继承
public class UserServiceImpl implements UserService,TimeService{
    @Override
    public void add(String name) {

    }

    @Override
    public void delete(String name) {

    }

    @Override
    public void update(String name) {

    }

    @Override
    public void query(String name) {

    }

    @Override
    public void timer() {

    }
}

</code></pre>
<h1 id="n种内部类"><a class="header" href="#n种内部类">N种内部类</a></h1>
<p>内部类就是在一个类的内部再定义一个类，比如A类中定义一个B类，则B类相对A类来说就是内部类，而A类相对B类来说就是外部类。</p>
<p>分类：</p>
<ul>
<li>成员内部类</li>
<li>静态内部类</li>
<li>局部内部类</li>
<li>匿名内部类</li>
</ul>
<h2 id="特殊内部类"><a class="header" href="#特殊内部类">特殊内部类</a></h2>
<p>双类</p>
<pre><code class="language-java">package oop;

public class Outer {

    }
}
//一个java类中可以有多个class类，但是只能有一个public class
class A{

    public static void main(String[] args) {
        
    }
}
</code></pre>
<h2 id="成员内部类"><a class="header" href="#成员内部类">成员内部类</a></h2>
<p>类中类，通过外部类调用内部类</p>
<pre><code class="language-java">package oop;

public class Outer {
    private int id;
    public void out(){
        System.out.println("这是外部类的方法");
    }
    public class Inner{
        public void in(){
            System.out.println("这是内部类的方法");
        }
    }
}
</code></pre>
<pre><code class="language-java">package oop;

public class Application{
    public static void main(String[] args) {
        Outer outer = new Outer();
        //通过这个外部类来实例化内部类
        Outer.Inner inner = outer.new Inner();
        inner.in();
    }
}
</code></pre>
<p>输出结果：</p>
<pre><code class="language-txt">这是内部类的方法
</code></pre>
<p>获得外部类的属性</p>
<pre><code class="language-java">package oop;

public class Outer {
    private int id = 10;
    public void out(){
        System.out.println("这是外部类的方法");
    }
    public class Inner{
        public void in(){
            System.out.println("这是内部类的方法");
        }
        //获得外部类的私有属性
        public void getID(){
            System.out.println(id);
        }
    }
    
}
</code></pre>
<pre><code class="language-java">package oop;

public class Application{
    public static void main(String[] args) {
        Outer outer = new Outer();
        //通过这个外部类来实例化内部类
        Outer.Inner inner = outer.new Inner();
        inner.getID();
    }
}
</code></pre>
<p>输出结果：10</p>
<h2 id="静态内部类"><a class="header" href="#静态内部类">静态内部类</a></h2>
<p>静态内部类无法调用外部非静态类属性</p>
<pre><code class="language-java">package oop;

public class Outer {
    private  int id = 10;
    public void out(){
        System.out.println("这是外部类的方法");
    }
    public static class Inner{
        public void in(){
            System.out.println("这是内部类的方法");
        }
        //获得外部类的私有属性
        public void getID(){
            System.out.println(id);//Non-static field 'id' cannot be referenced from a static context
        }
    }

}
</code></pre>
<pre><code class="language-java">package oop;

public class Outer {
    private static int id = 10;
    public void out(){
        System.out.println("这是外部类的方法");
    }
    public static class Inner{
        public void in(){
            System.out.println("这是内部类的方法");
        }
        //获得外部类的私有属性
        public void getID(){
            System.out.println(id);
        }
    }

}
</code></pre>
<h2 id="局部内部类"><a class="header" href="#局部内部类">局部内部类</a></h2>
<p>类中方法中类</p>
<pre><code class="language-java">package oop;

public class Outer {
    
    //局部内部类
    public void method(){
        class Inner{
            public void in(){
                
            }
        }

    }
}
</code></pre>
<h2 id="匿名内部类"><a class="header" href="#匿名内部类">匿名内部类</a></h2>
<pre><code class="language-java">package oop;

public class Test {
    public static void main(String[] args) {
        //没有名字初始化类
        new Apple().eat();
    }
    
}

class Apple{
    public void eat(){
        System.out.println("1");
    }
}

</code></pre>
<pre><code class="language-java">package oop;

public class Test {
    public static void main(String[] args) {
        //没有名字初始化类
        new Apple().eat();
    }
    UserService1 userservice1 = new UserService1(){
        @Override
        public void hello() {

        }
    } ;
}

class Apple{
    public void eat(){
        System.out.println("1");
    }
}
interface UserService1{
    void hello();
}
</code></pre>
<h1 id="java多态和抽象类"><a class="header" href="#java多态和抽象类">java多态和抽象类</a></h1>
<p>1.(填空题) （程序改错题）GC1.java文件中的程序有4个错误，请修改错误使程序能够正确运行，在错误行的末尾添加注释//******。
该文件中定义了一个接口Area，其中包含一个计算面积的方法CalculateArea(), MyCircle和MyRectangle类分别实现了这个接口，在GC1的main方法中创建了相应的对象并输出面积。</p>
<p>程序正确运行结果如下图所示：</p>
<p><img src="https://p.ananas.chaoxing.com/star3/origin/7b9c9e09d2953c9b3743f94c8f32cb7f.png" alt="r" /></p>
<pre><code class="language-java">public class GC1 {
	public static void main(String[] args) {
		MyCircle c = new MyCircle(2.0);
		System.out.println("圆面积:" + c.CalculateArea());
		MyRectangle r = new MyRectangle(2.0, 3.0);
		System.out.println("矩形面积:" + r.CalculateArea());//*******
	}
}

interface Area {
	public double CalculateArea();//错误写法public double CalculateArea(){};不知为何
}

class MyCircle implements Area {//******
	double r;

	public MyCircle(double r) {
		this.r = r;
	}

	public double CalculateArea() {
		return Math.PI * r * r;
	}
}

class MyRectangle implements Area {
	double width, height;

	public MyRectangle(double w, double h) {
		width = w;
		height = h;
	}

	public double CalculateArea() {
		return width * height;//******
	}
}
</code></pre>
<h3 id="包之间的互相调用ide可行但terminal不行不知原因"><a class="header" href="#包之间的互相调用ide可行但terminal不行不知原因">包之间的互相调用（ide可行但terminal不行，不知原因）</a></h3>
<p>2.（程序填空题）某同学编写的应用程序中包含两个类Person和Employee，分别属于两个包Firstpackage和Secondpackage。Employee继承Person类。创建两个包来组织源程序代码，包结构截图如下。请将下面的程序补充完整，依次粘贴缺失的代码。</p>
<p>Person.java</p>
<pre><code class="language-java">package Firstpackage;

public class Person {

 public String name;

 public Person(String name){

 this.name=name;

 }
	
public  void printInfo() {

 System.out.println("姓名："+this.name);

 } 

}
</code></pre>
<p>EmployeeManagement.java</p>
<pre><code class="language-java">package Secondpackage;

import Firstpackage.Person;



class EmployeeManagement {

 public static void main(String[] args) {

 Employee e=new Employee("Jack",6134.78);

 e.printInfo();

 }



}



class Employee extends Person{

 double salary;

 Employee(String name,double salary){

 super(name);

 this.salary=salary;

 }

 

public void printInfo() {

 System.out.println("姓名："+this.name+" 工资："+this.salary);

 }

}
</code></pre>
<p>3.（程序填空题）下列程序中定义了抽象类Person和它的两个子类Worker和Student，分别创建Worker和Person的对象，显示两个对象的描述信息，程序的运行结果如下图所示。</p>
<p><img src="https://p.ananas.chaoxing.com/star3/origin/07fd49c2e7f5f0ff7cfe9a51ab6c0c7e.png" alt="img" /></p>
<pre><code class="language-java">public class PersonManagement {

public static void main(String[] args) {

Person[] people=new Person[2];

people[0]= new Worker("老张",30000.0);

people[1]=new Student("小王","计算机");

for(int i=0;i&lt;people.length;i++) {

Person p=people[i];

System.out.println(p.getName()+","+p.getDescription());

}

}

}





abstract class Person{

private String name;

public Person(String n) {

name=n;

}


public  abstract String getDescription(); //抽象方法getDescription


public String getName() {

return name;

}

}

class Worker extends Person{

private double salary;

public Worker(String n, double s) {

super(n); //调用父类的构造方法给name赋值

salary=s;

}


public String getDescription() {

return "工人，年薪是 "+salary+"元";

}

}



class Student extends Person{

private String major;

public Student(String n,String m) {

super(n);//不知到为什么这么写，为什么不写成name=super(n);

major=m;

}


public String getDescription() {

return "学生，专业是"+major;

}

}
</code></pre>
<p>4.（编程题）志愿者信息系统管理参与某大型博览会的志愿者的评分情况，并根据评分情况颁发相应的志愿者荣誉证书。每名志愿者的评分情况和线上、线下两部分工作时长有关。Volunteer类定义了四个成员变量（见程序中的注解），评价总分的计算方法如下：       线上工作时长*0.8+线下工作时长。总分20分（含）以上者获得“优秀志愿者”称号。各方法的功能见程序的注解。程序的某次运行结果如下图所示。</p>
<p><img src="https://p.ananas.chaoxing.com/star3/origin/857a1dd0164c5f4532cb1b41e76df40d.png" alt="r" /></p>
<pre><code class="language-java">import java.util.*;

class Volunteer

{

        private String name;    //志愿者姓名

        private int offlineHours;    //线下工作时长

        private int onlineHours;     //线上工作时长

        private double score;   //总分

        public Volunteer(String name,int offline,int online){//姓名，线下工作时长，线上工作时长

                 this.name=name;

                 this.onlineHours=online;         

                 this.offlineHours=offline;

                 this.score=0;//总分初始为0

        }

        public void calScore() {//没有返回值

          //在此处定义方法体（填入第1空）
          this.score =this.offlineHours+this.onlineHours*0.8;

          //计算线上与线下服务的综合得分（线上工作时长计分系数是0.8，线下工作时长计分系数是1.0），即评分=线上工作时长×0.8+线下工作时长,并写入成员变量score。

                

        }

        public void addScore(){//加上应急工作时长后的得分，应急工作时长随机产生，为0~9的整数，应急工作时长积分系数是1.2

         //在此处定义方法体（填入第2空）
		this.score+= 1.2*(int)(Math.random()*9);
                

        }

       

        public String toString() { //获取对象的相关信息

         //在此处定义方法体（填入第3空）

                return this.name+"\t线上工作时长："+this.onlineHours+"\t线下工作时长"+this.offlineHours+"总评分："+this.score;

        }

 

        public void Comare(Volunteer v1) {

                 if (this.score&gt;v1.score){

                         System.out.println(this.name+"的评分较高");

                 }

                 else if (this.score&lt;v1.score) {

                         System.out.println(this.name+"的评分较高");

                 }

                 else {

                         System.out.println(this.name+"和"+v1.name+"的评分相同");

                 }

        }

       

        public void isExcellentVolunteer() {

         //在此处定义方法体（填入第4空）
		if(this.score&gt;=20){
		
			System.out.println(this.name+"获得优秀志愿者称号");
		}else{
			
			System.out.println(this.name+"暂未入选优秀志愿者称号");
			
		}
 

        }

}

 

public class BC2 {

 

        public static void main(String[] args) {

                 Volunteer v1=new Volunteer("小白鹭1号",10,15);

                 v1.calScore();

                 v1.addScore();

                 System.out.println(v1.toString());

                 v1.isExcellentVolunteer();

                 Volunteer v2=new Volunteer("小白鹭6号",5,5);

                 v2.calScore();

                 v2.addScore();

                 System.out.println(v2.toString());

                 v2.isExcellentVolunteer();

                 v1.Comare(v2);

        }

}
</code></pre>
<p>5.（程序填空题）星爸爸咖啡馆有一个订单管理应用程序，其中包含Order类，输出信息如图所示。将Order类补充完整，将完整代码依次填入相应的空中。</p>
<p><img src="https://p.ananas.chaoxing.com/star3/origin/3fc26dd1708b72b68fe6bb8d3bcd39d8.png" alt="r" /></p>
<pre><code class="language-java">public class TK2 {

 public static void main(String[] args) {

 Order o1, o2;

 o1 = new Order(2, 2);

 o2 = new Order(2, 1);

 o1.addCoffees(1);

 o2.addCakes(3);

 o1.addCoffees(1);

 o1.setIsPaid(true);

 o2.setIsPaid(false);

 System.out.println(o1.toString());

 System.out.println(o2.toString());

 }

}



class Order {

 private int numCoffees;

 private int numCakes; 

 private boolean isPaid;



 public Order(int nCoff, int nCakes) {

 numCoffees = nCoff;//传变量的方法，为什么这么传呢？？？

 numCakes = nCakes;

 }



 public void addCoffees(int numToAdd) {

numCoffees+=numToAdd;

 }



 public void addCakes(int numToAdd) {

 numCakes += numToAdd;

 }



 public void setIsPaid(boolean paid) {

isPaid=paid;//这点不会知道补啥

 }



 public int getTotal() {

 return numCoffees * 3 + numCakes * 4;

 }



 public String toString() {//这个通常有什么用呢？，好像是个函数

 String orderInfo = "New Order: \n";

 orderInfo += numCoffees + " Coffees $" + numCoffees * 3 + "\n";

 orderInfo += numCakes + " Cakes $" + numCakes * 4 + "\n";

 orderInfo += " Total $" + getTotal() + " ";

 if (isPaid)

 orderInfo += " has been paid \n";

 else

 orderInfo += " not paid \n";
 return orderInfo;


 }

}
</code></pre>
<p>6.（编程题）声明抽象类Shape，有抽象成员方法area()和girth()。声明类Rectangle为Shape的子类，有两个成员变量width和height分别表示矩形的宽和高，实现继承自Shape的两个抽象方法，分别计算矩形的面积和周长。请编写Shape和Rectangle这两个类。周长计算公式：周长=2x(宽+高)。面积计算公式：面积=宽x高。</p>
<pre><code class="language-java">public class BC1 {

public static void main(String[] args) {

Rectangle r=new Rectangle(3.0,5.0);

System.out.println("周长是"+r.girth());

}

}

abstract class Shape{
	
	abstract double area();
	abstract double girth();//抽象方法不能有主体,不能有{}
		
	}
	
class Rectangle extends Shape{
	
	double width;
	double height;
	
	//用构造方法传值
	Rectangle(double width, double height){
		
		this.width=width;
		this.height=height;
	}
	
	double area(){
		
		return width*height;
	}
	double girth(){//如果添加形式参数double width, double height会报错错误: Rectangle不是抽象的, 并且未覆盖Shape中的抽象方法girth()
		
		return 2*(width+height);
	}
	
}	

</code></pre>
<p>7.（程序填空题）以下是为新冠肺炎疫苗接种开发的一段程序，其中定义了一个抽象类Vaccine，包含成员变量和抽象成员方法vaccinate()；另外分别定义了Vaccine类的子类InactivatedVaccine和AdenovirusVectorVaccine，在主程序中生成对象并使用成员方法，程序正常运行时的输出界面如下图所示，请将程序补充完整。</p>
<p><img src="https://p.ananas.chaoxing.com/star3/origin/93e2321a638944fd76c8c7e09251cc58.png" alt="r" /></p>
<pre><code class="language-java">abstract class Vaccine{

    String manufacturer; //生产厂商

    int n=1; //接种次数

    abstract void vaccinate(); //定义vaccinate()成员方法
	//不能添加public，否则报错“正在尝试分配更低的访问权限; 以前为public”


}

 

class InactivatedVaccine extends Vaccine{//灭活疫苗

    public InactivatedVaccine(String name, int n) {//构造方法

        manufacturer=name;

        this.n=n;

    }

   

    public InactivatedVaccine(String name) {//构造方法

        this(name,2);

    }

 

    void vaccinate() {

        System.out.println("该灭活疫苗的生产厂商是"+manufacturer+"，接种剂次："+n);

    }

}

 

class AdenovirusVectorVaccine extends Vaccine{//腺病毒载体疫苗

    public AdenovirusVectorVaccine(String name) {//构造方法

        manufacturer=name;

    }

 

    void vaccinate() {

        System.out.println("该腺病毒载体疫苗的生产厂商是"+manufacturer+"，只需接种1剂。");

    }

}

 

public class TK2 {

    public static void main(String[] args) {

        InactivatedVaccine v1=new InactivatedVaccine("北京生物",2);

        v1.vaccinate();

        InactivatedVaccine v2=new InactivatedVaccine("科兴",2);

        v2.vaccinate();

        AdenovirusVectorVaccine v3=new AdenovirusVectorVaccine("康希诺");

        v3.vaccinate();

    }

}
</code></pre>
<h2 id="类的应用实例"><a class="header" href="#类的应用实例">类的应用实例</a></h2>
<p>1.（程序填空题）根据已知的程序段和已知的输出结果，将下列程序补充完整。请分别在第一、二、三个空中填写缺失的代码，在第四个空粘贴运行结果截图。输出结果：</p>
<p>Name: John Age: 2 ID: 445</p>
<p>Name: Fred Age: 4 ID: 447</p>
<p>Name: Elma Age: 6 ID: 449</p>
<p>完整代码：</p>
<pre><code class="language-java">public class UsePerson {

 public static void main(String[] args) {

 Person p1, p2, p3;

 //请将下面缺失的一行代码填入第一个空

Person.setID(444);
// 用setID方法给nextID赋初值，根据输出的p1的nextID分析出初值是多少。



 p1 = new Person("John"); // p1赋初值

 p1.changeAge(2); // p1调用changeAge方法

 System.out.println(p1.toString()); // 输出p1的信息



 //请将下面缺失的三行代码填入第二个空
 p2 = new Person("Fred"); // p1赋初值

 p2.changeAge(2); // p1调用changeAge方法

 System.out.println(p2.toString()); // 输出p1的信息



 //请将下面缺失的三行代码填入第三个空
 p3 = new Person("Elma"); // p1赋初值

 p3.changeAge(2); // p1调用changeAge方法

 System.out.println(p3.toString()); // 输出p1的信息


 }

}



class Person {

 private static int age; // 注意age是static变量

 private String name;

 private static int nextID; // 注意nextID是static变量

 private int id;



 public Person(String s) {

 name = s;

 id = nextID;

 nextID++;

 }



 public void changeAge(int i) {

 age += i;

 id = nextID;

  nextID++;//第一个john的nextID没调用这块？？？？？？暂时还不知道原因

 }



 public static void setID(int i) {

 nextID = i;

 }



 public String toString() {

 return "Name: " + name + " Age: " + age + " ID: " + id;

 }

}
</code></pre>
<p>2.（程序填空题）程序中定义了一个类BikeSharing（共享单车），成员变量的说明详见程序中的注释，成员方法getDisPerday用于计算日均行驶里程（日均行驶里程=行驶里程/投放天数）；定义了BikeSharing类的子类Haluo，成员方法getDailyFee用于计算产生的骑行费用(骑行费用=骑行单价*行驶里程)。在TC2的main方法中创建了Haluo单车对象，调用成员方法输出它的日均骑行里程和日均骑行费用。程序正确运行结果如下图所示，请将程序补充完整。</p>
<p><img src="https://p.ananas.chaoxing.com/star3/origin/1159f70554e473724deb633c58ab6c9b.png" alt="img" /></p>
<pre><code class="language-java">class BikeSharing{

    String id;        //单车的序列号

    double distance;  //行驶里程(公里)

    int days;         //投放天数

    BikeSharing(String id,double dis,int d){

             this.id= id; //给成员变量id赋值

             distance=dis;     

             days=d;

    }

    public double getDisPerday() { //计算日均骑行里程

       return  distance/days;

    }

}

class Haluo extends BikeSharing{           

    double price;                  //每公里骑行单价

    Haluo(String id,double dis,int d){               

          super(id,dis,d);       

    }

public void setPrice(double price){ 

       this.price=price;

    }

    public double getDailyFee() {  //计算日均骑行费用

       return price*getDisPerday();       

    }

}

public class TC2 {

    public static void main(String[] args) {

       Haluo h=new Haluo("20210001",2251.2,402);    

       System.out.println("平均每天行驶里程:"+ h.getDisPerday() +"公里");

       h.setPrice(1.8);

       System.out.println("平均每天骑行费用:"+h.getDailyFee()+"元");

    }

}
</code></pre>
<p>super关键字用来访问父类内容，而this关键字用来访问本类内容</p>
<h4 id="注super的三种用法"><a class="header" href="#注super的三种用法">注：super的三种用法</a></h4>
<p>1.在子类的成员方法中访问父类的成员变量num如super.num</p>
<p>2.在子类的成员方法中访问父类的成员方法method如super.method();</p>
<p>3.在子类的构造方法中，访问父类的构造方法如super();</p>
<h4 id="注this的三种用法"><a class="header" href="#注this的三种用法">注：this的三种用法</a></h4>
<p>1.在本类的成员方法中访问本类的成员变量</p>
<p>2.在本类的成员方法中访问本类的另一个成员方法</p>
<p>3.在本类的构造方法中访问本类的另一个构造方法</p>
<ul>
<li>this(...)调用也必须是构造方法的第一个语句，唯一一个</li>
<li>super和this两种构造调用不能同时使用</li>
</ul>
<h4 id="三种变量的区别"><a class="header" href="#三种变量的区别">三种变量的区别</a></h4>
<pre><code class="language-java">class Father{
	int num = 30;
	
}



public class Son extends Father{
	
	int num = 20;
	
	public  Son(){
		this(123);//本类的无参构造调用本类的有参构造
		//this(n:123));错误写法报错需要)
		//this(n:1, m:2);这是错误用法call to this() must be first statement in constructor body
	}
	public Son(int n){
		
	}
	
	public Son(int n, int m){
		
	}
	
	public void showNum(){
		int num = 10;
		System.out.println(num);//局部变量
		System.out.println(this.num);//本类中的成员变量
		System.out.println(super.num);//父类中的成员变量
		
	}
	
	public void methodA(){
		System.out.println("AAA");
	}
	
	public void methodB(){
		this.methodA();//methodA();
		System.out.println("BBB");
	}
	
	
	
	
	public static void main(String[] args) {

       Son son=new Son();    

      son.showNum()
  //System.out.println(son.showNum());错误: 此处不允许使用 '空' 类型
     
      son.methodB();

    }
	
}

</code></pre>
<p>输出结果：</p>
<pre><code class="language-txt">10
20
30
AAA
BBB

</code></pre>
<p>3.(填空题, 20分)（编程题）根据鸢尾花的花瓣长度和宽度来判断它的类别。Iris类的成员变量和成员方法的说明见程序中的注释。已知两朵鸢尾花，第一朵花瓣长1.6cm，花瓣宽0.6cm，类别为"山鸢尾"，第二朵花瓣长5.8cm，花瓣宽3.1cm，类别为"变色鸢尾"；现要判断一朵新的鸢尾花类别，其方法如下：若它距离第一朵鸢尾花更近，则它的类别为"山鸢尾"，如果它距离第二朵鸢尾花更近，其类别就是"变色鸢尾"（如果距离相等，类别设置为"山鸢尾"）。两朵鸢尾花之间的距离计算公式如下：</p>
<p><img src="https://p.ananas.chaoxing.com/star3/origin/6912459a56fd6a8718e674cf97cc4cbd.png" alt="r" /></p>
<p>其中：plen1，pwid1分别为其中一朵鸢尾花的花瓣长度和花瓣宽度，plen2，pwid2为另一朵鸢尾花的花瓣长度和花瓣宽度。程序的运行结果如下图所示：</p>
<p><img src="https://p.ananas.chaoxing.com/star3/origin/bbf40b814edfc712fa791bc75e791638.png" alt="r" /></p>
<p>请将下面的代码补充完整。将缺少的代码依次填入每个空。（缺少的代码可能不止一行）</p>
<p>完整代码：</p>
<pre><code class="language-java">class Iris{

               private  double plen;  //花瓣长度

               private  double pwid;   //花瓣宽度

               private  String target;//鸢尾花的种类     

   

               public Iris(double plen,double pwid,String  target) {

                   this.plen=plen;
	           this.pwid=pwid;
		   this.target=target;

               }

               public Iris(double pl,double pw) {

                               this.plen=pl;

                               this.pwid=pw;

               }   

               public void setTarget(String t) {  //设置鸢尾花的类别

                             target=t;

               }

               public String  toString() {          //生成并返回对象的相关信息

                              String s="花瓣长："+plen+" 花瓣宽："+pwid+" "+" 类别是："+target;
                               return s; 

               }

               public double distance(Iris another) {//计算2朵鸢尾花之间的距离                                             

                 double distance=Math.sqrt(Math.pow((plen-another.plen),2)+Math.pow((pwid-another.pwid),2));
				   
                 return distance; 

               }

}

public class TC2 {

               static Iris iris1=new Iris(1.6,0.6,"山鸢尾");

               static Iris iris2=new Iris(5.8,3.1,"变色鸢尾");

              

               public  static String classify(Iris irisnew) {//判断irisnew的类别

                    if(irisnew.distance(iris1&lt;=irisnew.distance(iris2)){
								   return "山鸢尾";
				    }else{
								   return  "变色鸢尾";
							   }

               }

               public static void main(String args[]) {

                               Iris testSample1=new Iris(2.2,1.5);

                               testSample1.setTarget(classify(testSample1));

                               System.out.println(testSample1.toString());

                              

                               Iris testSample2=new Iris(6.0,2.9);

                               testSample2.setTarget(classify(testSample2));     

                               System.out.println(testSample2.toString());

               }

}
</code></pre>
<p>生成并返回对象的信息：</p>
<pre><code class="language-java">//类中
public String  toString() {          //生成并返回对象的相关信息

                              String s="花瓣长："+plen+" 花瓣宽："+pwid+" "+" 类别是："+target;
                               return s; 

               }
//主方法中
System.out.println(testSample2.toString());
</code></pre>
<p>4.(填空题, 15分)（程序改错题）下列程序完成学生成绩管理功能。请修改程序中出现的三处错误。Student类中定义了学生的姓名（name）、测验分数（testMark）和考试分数（examMark）。程序产生的正确输出如下图所示：</p>
<p><img src="https://p.ananas.chaoxing.com/star3/origin/b5cf899d7e95dd1e7d020c0438675187.png" alt="r" /></p>
<p>请在第一、二、三个空中填写错误代码的行号、修改后的代码、错误原因。格式：第n行，改为...(正确代码)，错误原因。</p>
<p>请在第四个空中上传修改后的源程序文件。</p>
<p>完整代码：</p>
<pre><code class="language-java">public class TestStudent {

 public static void main(String[] args) {

 // TODO 自动生成的方法存根

 Student student1;

 Student student2;

 student1 = new Student("张楠", 70, 85);

 student2 = new Student("李浩", 80, 90);

 student1.displayInfo();

 student2.displayInfo();

 student2.setExamMark(40);

 student2.compareTo(student1);

 }

}



class Student {

 private String name;

 private int testMark;

 private int examMark;



 Student(String theName) {

 name = theName;

 }



 Student(String theName, int test, int exam) {

 name = theName;

 testMark = test;

 examMark = exam;

 }



 public void setExamMark(int exam) {

 examMark = exam;

 System.out.println(name + "\'s exam mark changed to " + examMark);

 }



 public int getTestMark() {

 return testMark;

 }



 public void displayInfo() {

     System.out.println(name + " got " + testMark + " in the test and " + examMark + " in the exam");

   }



 public void compareTo(Student other) { //方法的形参必须指定数据类型，根据方法体中使用other的可知，other是一个Student类型对象。

     if (examMark &gt; other.examMark) 

       System.out.println(name + " did better than " + other.name);

     else

       System.out.println(name + " did worse than " + other.name);

   }

 }
</code></pre>
<p>5.(填空题, 15分)（编程题）创建Melon类，包含初始值为0的静态变量totalNum、私有实例变量weight。编写Melon类的内容，完成以下功能：</p>
<p>每当创建一个新的Melon对象，totalNum增加1。</p>
<p>为Melon类编写实例方法void reduce(){}，每次调用reduce方法，totalNum的值减少1。为私有实例变量weight声明一对访问器方法，分别是int getWeight(){ }和void setWeight(int w){ }，实现对私有实例变量weight的读取和修改，编写这两个方法的方法体。</p>
<p>测试Melon的功能。创建公共类TestMelon，包含main方法，在main方法中完成下面的功能测试。依次创建四个Melon对象m1、m2、m3、m4后，输出totalNum的值。依次调用m1和m2的reduce方法后，输出totalNum的值。</p>
<p>调用m3的访问器方法设置私有成员变量weight的值为10，然后获取weight的值并输出。 要求将Melon类和公共类TestMelon放在同一个源程序文件TestMelon.java中。</p>
<p>请将编写好的源程序截图粘贴到第1个空，源代码文件TestMelon.java以附件形式上传到第2个空，将运行结果截图粘贴第3个空中。</p>
<p>完整代码：</p>
<pre><code class="language-java">public class TestMelon{
	
	public static void main(String[] args) {
		Melon m1 = new Melon();
		Melon m2 = new Melon();
		Melon m3 = new Melon();
		Melon m4 = new Melon();
		
		System.out.println(Melon.totalNum);//不能写totalNum
		
		m1.reduce();//错误写法reduce(m1);
		m2.reduce();
		
		System.out.println(Melon.totalNum);
		
		m3.setWeight(10);
		
		System.out.println(m3.getWeight());
	}
	
}
class Melon{

	static int  totalNum;
	private int weight;
	//每当创建一个新的Melon对象，totalNum增加1。
	Melon(){
		totalNum++;
		}
	//为Melon类编写实例方法void reduce(){}，每次调用reduce方法，totalNum的值减少1。
	void reduce(){
		totalNum--;
	}
	
	void setWeight(int w){ 
		weight=w;
	}
	
	int getWeight(){
		return weight;
	}

}
</code></pre>
<p>6.(填空题, 15分)（编程题）学校图书馆需要设计一个图书信息系统来管理藏书。假设一个简单的图书信息系统需要完成书籍、输出书籍信息、比较书籍的功能。请创建两个类Book和TestBook完成上述功能，输出结果如下：</p>
<p><img src="https://p.ananas.chaoxing.com/star3/origin/8fc1043509126b67819ec4c2d93962fb.png" alt="img" /></p>
<p>编程要求：创建两个类Book和TestBook，其中TestBook是主类。</p>
<p>Book的属性有书名、作者（假设只有一位作者）、出版年份，行为有打印图书信息、比较图书信息。</p>
<p>在Book类中声明实例变量记录各个属性信息，成员变量的名称分别是name、author、publishYear。</p>
<p>在Book类声明两个实例方法，一个实例方法的功能是打印图书信息；另一个实例方法的功能是比较两本图书，如果书名、作者和出版年份都一样，这两本书是同一本书。</p>
<p>第一个实例方法的方法头是 void display(){ //请添加方法体 }</p>
<p>第二个实例方法的方法头是boolean compareBook(Book another){ //请添加方法体 }</p>
<p>在Book类中用静态变量copyCounter记录书的数目。</p>
<p>TestBook类中包含main方法，用于创建图书。</p>
<p>完整代码：</p>
<p>Book.java</p>
<pre><code class="language-java">public class Book{
	
	static int copyCounter=0;
	
	String name ;
	String author;
	int publishYear;
	
	Book(String n,String a, int y){//必须要有构造方法
	
		name=n;
		author=a;
		publishYear=y;
		
		copyCounter++;
	}
	
	void display(){
		System.out.print("《"+name+"》，");
		System.out.print("作者："+author+"，");
		System.out.print("出版年份："+publishYear+'\n');
	}
	
	boolean compareBook(Book another){
		if(name.equals(another.name)&amp;&amp;author.equals(another.author)&amp;&amp;(publishYear==another.publishYear)){
		
			return true;
		}else{
		
			return false;
		}
	}
}
//可以简写为return name.equals(another.name)&amp;&amp;author.equals(another.author)&amp;&amp;(publishYear==another.publishYear
//字符串比较用equals()
</code></pre>
<p>BookTest.java</p>
<pre><code class="language-java">public class TestBook{
	
	public static void main(String[] args) {
		Book book1 = new Book("红楼梦","曹雪芹",1791);
		book1.display();
		Book book2 = new Book("边城","沈从文",1934);
		book2.display();
		
		String str = book1.compareBook(book2)?"":"不";
		
		System.out.println("这两本书"+str+"是同一本书");
		
		System.out.println("一共有"+Book.copyCounter+"本书");
	}
	
}
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
